// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/api/servicecontrol/v1/distribution.proto (package google.api.servicecontrol.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * Distribution represents a frequency distribution of double-valued sample
 * points. It contains the size of the population of sample points plus
 * additional optional information:
 *
 *   - the arithmetic mean of the samples
 *   - the minimum and maximum of the samples
 *   - the sum-squared-deviation of the samples, used to compute variance
 *   - a histogram of the values of the sample points
 *
 * @generated from message google.api.servicecontrol.v1.Distribution
 */
export class Distribution extends Message<Distribution> {
  /**
   * The total number of samples in the distribution. Must be >= 0.
   *
   * @generated from field: int64 count = 1;
   */
  count = protoInt64.zero;

  /**
   * The arithmetic mean of the samples in the distribution. If `count` is
   * zero then this field must be zero.
   *
   * @generated from field: double mean = 2;
   */
  mean = 0;

  /**
   * The minimum of the population of values. Ignored if `count` is zero.
   *
   * @generated from field: double minimum = 3;
   */
  minimum = 0;

  /**
   * The maximum of the population of values. Ignored if `count` is zero.
   *
   * @generated from field: double maximum = 4;
   */
  maximum = 0;

  /**
   * The sum of squared deviations from the mean:
   *   Sum[i=1..count]((x_i - mean)^2)
   * where each x_i is a sample values. If `count` is zero then this field
   * must be zero, otherwise validation of the request fails.
   *
   * @generated from field: double sum_of_squared_deviation = 5;
   */
  sumOfSquaredDeviation = 0;

  /**
   * The number of samples in each histogram bucket. `bucket_counts` are
   * optional. If present, they must sum to the `count` value.
   *
   * The buckets are defined below in `bucket_option`. There are N buckets.
   * `bucket_counts[0]` is the number of samples in the underflow bucket.
   * `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples
   * in each of the finite buckets. And `bucket_counts[N] is the number
   * of samples in the overflow bucket. See the comments of `bucket_option`
   * below for more details.
   *
   * Any suffix of trailing zeros may be omitted.
   *
   * @generated from field: repeated int64 bucket_counts = 6;
   */
  bucketCounts: bigint[] = [];

  /**
   * Defines the buckets in the histogram. `bucket_option` and `bucket_counts`
   * must be both set, or both unset.
   *
   * Buckets are numbered in the range of [0, N], with a total of N+1 buckets.
   * There must be at least two buckets (a single-bucket histogram gives
   * no information that isn't already provided by `count`).
   *
   * The first bucket is the underflow bucket which has a lower bound
   * of -inf. The last bucket is the overflow bucket which has an
   * upper bound of +inf. All other buckets (if any) are called "finite"
   * buckets because they have finite lower and upper bounds. As described
   * below, there are three ways to define the finite buckets.
   *
   *   (1) Buckets with constant width.
   *   (2) Buckets with exponentially growing widths.
   *   (3) Buckets with arbitrary user-provided widths.
   *
   * In all cases, the buckets cover the entire real number line (-inf,
   * +inf). Bucket upper bounds are exclusive and lower bounds are
   * inclusive. The upper bound of the underflow bucket is equal to the
   * lower bound of the smallest finite bucket; the lower bound of the
   * overflow bucket is equal to the upper bound of the largest finite
   * bucket.
   *
   * @generated from oneof google.api.servicecontrol.v1.Distribution.bucket_option
   */
  bucketOption: {
    /**
     * Buckets with constant width.
     *
     * @generated from field: google.api.servicecontrol.v1.Distribution.LinearBuckets linear_buckets = 7;
     */
    value: Distribution_LinearBuckets;
    case: "linearBuckets";
  } | {
    /**
     * Buckets with exponentially growing width.
     *
     * @generated from field: google.api.servicecontrol.v1.Distribution.ExponentialBuckets exponential_buckets = 8;
     */
    value: Distribution_ExponentialBuckets;
    case: "exponentialBuckets";
  } | {
    /**
     * Buckets with arbitrary user-provided width.
     *
     * @generated from field: google.api.servicecontrol.v1.Distribution.ExplicitBuckets explicit_buckets = 9;
     */
    value: Distribution_ExplicitBuckets;
    case: "explicitBuckets";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Distribution>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.servicecontrol.v1.Distribution";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "mean", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "minimum", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "maximum", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 5, name: "sum_of_squared_deviation", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 6, name: "bucket_counts", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
    { no: 7, name: "linear_buckets", kind: "message", T: Distribution_LinearBuckets, oneof: "bucket_option" },
    { no: 8, name: "exponential_buckets", kind: "message", T: Distribution_ExponentialBuckets, oneof: "bucket_option" },
    { no: 9, name: "explicit_buckets", kind: "message", T: Distribution_ExplicitBuckets, oneof: "bucket_option" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Distribution {
    return new Distribution().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Distribution {
    return new Distribution().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Distribution {
    return new Distribution().fromJsonString(jsonString, options);
  }

  static equals(a: Distribution | PlainMessage<Distribution> | undefined, b: Distribution | PlainMessage<Distribution> | undefined): boolean {
    return proto3.util.equals(Distribution, a, b);
  }
}

/**
 * Describing buckets with constant width.
 *
 * @generated from message google.api.servicecontrol.v1.Distribution.LinearBuckets
 */
export class Distribution_LinearBuckets extends Message<Distribution_LinearBuckets> {
  /**
   * The number of finite buckets. With the underflow and overflow buckets,
   * the total number of buckets is `num_finite_buckets` + 2.
   * See comments on `bucket_options` for details.
   *
   * @generated from field: int32 num_finite_buckets = 1;
   */
  numFiniteBuckets = 0;

  /**
   * The i'th linear bucket covers the interval
   *   [offset + (i-1) * width, offset + i * width)
   * where i ranges from 1 to num_finite_buckets, inclusive.
   * Must be strictly positive.
   *
   * @generated from field: double width = 2;
   */
  width = 0;

  /**
   * The i'th linear bucket covers the interval
   *   [offset + (i-1) * width, offset + i * width)
   * where i ranges from 1 to num_finite_buckets, inclusive.
   *
   * @generated from field: double offset = 3;
   */
  offset = 0;

  constructor(data?: PartialMessage<Distribution_LinearBuckets>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.servicecontrol.v1.Distribution.LinearBuckets";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "num_finite_buckets", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "width", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "offset", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Distribution_LinearBuckets {
    return new Distribution_LinearBuckets().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Distribution_LinearBuckets {
    return new Distribution_LinearBuckets().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Distribution_LinearBuckets {
    return new Distribution_LinearBuckets().fromJsonString(jsonString, options);
  }

  static equals(a: Distribution_LinearBuckets | PlainMessage<Distribution_LinearBuckets> | undefined, b: Distribution_LinearBuckets | PlainMessage<Distribution_LinearBuckets> | undefined): boolean {
    return proto3.util.equals(Distribution_LinearBuckets, a, b);
  }
}

/**
 * Describing buckets with exponentially growing width.
 *
 * @generated from message google.api.servicecontrol.v1.Distribution.ExponentialBuckets
 */
export class Distribution_ExponentialBuckets extends Message<Distribution_ExponentialBuckets> {
  /**
   * The number of finite buckets. With the underflow and overflow buckets,
   * the total number of buckets is `num_finite_buckets` + 2.
   * See comments on `bucket_options` for details.
   *
   * @generated from field: int32 num_finite_buckets = 1;
   */
  numFiniteBuckets = 0;

  /**
   * The i'th exponential bucket covers the interval
   *   [scale * growth_factor^(i-1), scale * growth_factor^i)
   * where i ranges from 1 to num_finite_buckets inclusive.
   * Must be larger than 1.0.
   *
   * @generated from field: double growth_factor = 2;
   */
  growthFactor = 0;

  /**
   * The i'th exponential bucket covers the interval
   *   [scale * growth_factor^(i-1), scale * growth_factor^i)
   * where i ranges from 1 to num_finite_buckets inclusive.
   * Must be > 0.
   *
   * @generated from field: double scale = 3;
   */
  scale = 0;

  constructor(data?: PartialMessage<Distribution_ExponentialBuckets>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.servicecontrol.v1.Distribution.ExponentialBuckets";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "num_finite_buckets", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "growth_factor", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "scale", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Distribution_ExponentialBuckets {
    return new Distribution_ExponentialBuckets().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Distribution_ExponentialBuckets {
    return new Distribution_ExponentialBuckets().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Distribution_ExponentialBuckets {
    return new Distribution_ExponentialBuckets().fromJsonString(jsonString, options);
  }

  static equals(a: Distribution_ExponentialBuckets | PlainMessage<Distribution_ExponentialBuckets> | undefined, b: Distribution_ExponentialBuckets | PlainMessage<Distribution_ExponentialBuckets> | undefined): boolean {
    return proto3.util.equals(Distribution_ExponentialBuckets, a, b);
  }
}

/**
 * Describing buckets with arbitrary user-provided width.
 *
 * @generated from message google.api.servicecontrol.v1.Distribution.ExplicitBuckets
 */
export class Distribution_ExplicitBuckets extends Message<Distribution_ExplicitBuckets> {
  /**
   * 'bound' is a list of strictly increasing boundaries between
   * buckets. Note that a list of length N-1 defines N buckets because
   * of fenceposting. See comments on `bucket_options` for details.
   *
   * The i'th finite bucket covers the interval
   *   [bound[i-1], bound[i])
   * where i ranges from 1 to bound_size() - 1. Note that there are no
   * finite buckets at all if 'bound' only contains a single element; in
   * that special case the single bound defines the boundary between the
   * underflow and overflow buckets.
   *
   * bucket number                   lower bound    upper bound
   *  i == 0 (underflow)              -inf           bound[i]
   *  0 < i < bound_size()            bound[i-1]     bound[i]
   *  i == bound_size() (overflow)    bound[i-1]     +inf
   *
   * @generated from field: repeated double bounds = 1;
   */
  bounds: number[] = [];

  constructor(data?: PartialMessage<Distribution_ExplicitBuckets>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.servicecontrol.v1.Distribution.ExplicitBuckets";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bounds", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Distribution_ExplicitBuckets {
    return new Distribution_ExplicitBuckets().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Distribution_ExplicitBuckets {
    return new Distribution_ExplicitBuckets().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Distribution_ExplicitBuckets {
    return new Distribution_ExplicitBuckets().fromJsonString(jsonString, options);
  }

  static equals(a: Distribution_ExplicitBuckets | PlainMessage<Distribution_ExplicitBuckets> | undefined, b: Distribution_ExplicitBuckets | PlainMessage<Distribution_ExplicitBuckets> | undefined): boolean {
    return proto3.util.equals(Distribution_ExplicitBuckets, a, b);
  }
}

