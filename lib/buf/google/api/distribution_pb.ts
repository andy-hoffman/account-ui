// Copyright 2016 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/api/distribution.proto (package google.api, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * Distribution contains summary statistics for a population of values and,
 * optionally, a histogram representing the distribution of those values across
 * a specified set of histogram buckets.
 *
 * The summary statistics are the count, mean, sum of the squared deviation from
 * the mean, the minimum, and the maximum of the set of population of values.
 *
 * The histogram is based on a sequence of buckets and gives a count of values
 * that fall into each bucket.  The boundaries of the buckets are given either
 * explicitly or by specifying parameters for a method of computing them
 * (buckets of fixed width or buckets of exponentially increasing width).
 *
 * Although it is not forbidden, it is generally a bad idea to include
 * non-finite values (infinities or NaNs) in the population of values, as this
 * will render the `mean` and `sum_of_squared_deviation` fields meaningless.
 *
 * @generated from message google.api.Distribution
 */
export class Distribution extends Message<Distribution> {
  /**
   * The number of values in the population. Must be non-negative.
   *
   * @generated from field: int64 count = 1;
   */
  count = protoInt64.zero;

  /**
   * The arithmetic mean of the values in the population. If `count` is zero
   * then this field must be zero.
   *
   * @generated from field: double mean = 2;
   */
  mean = 0;

  /**
   * The sum of squared deviations from the mean of the values in the
   * population.  For values x_i this is:
   *
   *     Sum[i=1..n]((x_i - mean)^2)
   *
   * Knuth, "The Art of Computer Programming", Vol. 2, page 323, 3rd edition
   * describes Welford's method for accumulating this sum in one pass.
   *
   * If `count` is zero then this field must be zero.
   *
   * @generated from field: double sum_of_squared_deviation = 3;
   */
  sumOfSquaredDeviation = 0;

  /**
   * If specified, contains the range of the population values. The field
   * must not be present if the `count` is zero.
   *
   * @generated from field: google.api.Distribution.Range range = 4;
   */
  range?: Distribution_Range;

  /**
   * Defines the histogram bucket boundaries.
   *
   * @generated from field: google.api.Distribution.BucketOptions bucket_options = 6;
   */
  bucketOptions?: Distribution_BucketOptions;

  /**
   * If `bucket_options` is given, then the sum of the values in `bucket_counts`
   * must equal the value in `count`.  If `bucket_options` is not given, no
   * `bucket_counts` fields may be given.
   *
   * Bucket counts are given in order under the numbering scheme described
   * above (the underflow bucket has number 0; the finite buckets, if any,
   * have numbers 1 through N-2; the overflow bucket has number N-1).
   *
   * The size of `bucket_counts` must be no greater than N as defined in
   * `bucket_options`.
   *
   * Any suffix of trailing zero bucket_count fields may be omitted.
   *
   * @generated from field: repeated int64 bucket_counts = 7;
   */
  bucketCounts: bigint[] = [];

  constructor(data?: PartialMessage<Distribution>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.Distribution";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "mean", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "sum_of_squared_deviation", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "range", kind: "message", T: Distribution_Range },
    { no: 6, name: "bucket_options", kind: "message", T: Distribution_BucketOptions },
    { no: 7, name: "bucket_counts", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Distribution {
    return new Distribution().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Distribution {
    return new Distribution().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Distribution {
    return new Distribution().fromJsonString(jsonString, options);
  }

  static equals(a: Distribution | PlainMessage<Distribution> | undefined, b: Distribution | PlainMessage<Distribution> | undefined): boolean {
    return proto3.util.equals(Distribution, a, b);
  }
}

/**
 * The range of the population values.
 *
 * @generated from message google.api.Distribution.Range
 */
export class Distribution_Range extends Message<Distribution_Range> {
  /**
   * The minimum of the population values.
   *
   * @generated from field: double min = 1;
   */
  min = 0;

  /**
   * The maximum of the population values.
   *
   * @generated from field: double max = 2;
   */
  max = 0;

  constructor(data?: PartialMessage<Distribution_Range>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.Distribution.Range";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "max", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Distribution_Range {
    return new Distribution_Range().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Distribution_Range {
    return new Distribution_Range().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Distribution_Range {
    return new Distribution_Range().fromJsonString(jsonString, options);
  }

  static equals(a: Distribution_Range | PlainMessage<Distribution_Range> | undefined, b: Distribution_Range | PlainMessage<Distribution_Range> | undefined): boolean {
    return proto3.util.equals(Distribution_Range, a, b);
  }
}

/**
 * A Distribution may optionally contain a histogram of the values in the
 * population.  The histogram is given in `bucket_counts` as counts of values
 * that fall into one of a sequence of non-overlapping buckets.  The sequence
 * of buckets is described by `bucket_options`.
 *
 * A bucket specifies an inclusive lower bound and exclusive upper bound for
 * the values that are counted for that bucket.  The upper bound of a bucket
 * is strictly greater than the lower bound.
 *
 * The sequence of N buckets for a Distribution consists of an underflow
 * bucket (number 0), zero or more finite buckets (number 1 through N - 2) and
 * an overflow bucket (number N - 1).  The buckets are contiguous:  the lower
 * bound of bucket i (i > 0) is the same as the upper bound of bucket i - 1.
 * The buckets span the whole range of finite values: lower bound of the
 * underflow bucket is -infinity and the upper bound of the overflow bucket is
 * +infinity.  The finite buckets are so-called because both bounds are
 * finite.
 *
 * `BucketOptions` describes bucket boundaries in one of three ways.  Two
 * describe the boundaries by giving parameters for a formula to generate
 * boundaries and one gives the bucket boundaries explicitly.
 *
 * If `bucket_boundaries` is not given, then no `bucket_counts` may be given.
 *
 * @generated from message google.api.Distribution.BucketOptions
 */
export class Distribution_BucketOptions extends Message<Distribution_BucketOptions> {
  /**
   * Exactly one of these three fields must be set.
   *
   * @generated from oneof google.api.Distribution.BucketOptions.options
   */
  options: {
    /**
     * The linear bucket.
     *
     * @generated from field: google.api.Distribution.BucketOptions.Linear linear_buckets = 1;
     */
    value: Distribution_BucketOptions_Linear;
    case: "linearBuckets";
  } | {
    /**
     * The exponential buckets.
     *
     * @generated from field: google.api.Distribution.BucketOptions.Exponential exponential_buckets = 2;
     */
    value: Distribution_BucketOptions_Exponential;
    case: "exponentialBuckets";
  } | {
    /**
     * The explicit buckets.
     *
     * @generated from field: google.api.Distribution.BucketOptions.Explicit explicit_buckets = 3;
     */
    value: Distribution_BucketOptions_Explicit;
    case: "explicitBuckets";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Distribution_BucketOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.Distribution.BucketOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "linear_buckets", kind: "message", T: Distribution_BucketOptions_Linear, oneof: "options" },
    { no: 2, name: "exponential_buckets", kind: "message", T: Distribution_BucketOptions_Exponential, oneof: "options" },
    { no: 3, name: "explicit_buckets", kind: "message", T: Distribution_BucketOptions_Explicit, oneof: "options" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Distribution_BucketOptions {
    return new Distribution_BucketOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Distribution_BucketOptions {
    return new Distribution_BucketOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Distribution_BucketOptions {
    return new Distribution_BucketOptions().fromJsonString(jsonString, options);
  }

  static equals(a: Distribution_BucketOptions | PlainMessage<Distribution_BucketOptions> | undefined, b: Distribution_BucketOptions | PlainMessage<Distribution_BucketOptions> | undefined): boolean {
    return proto3.util.equals(Distribution_BucketOptions, a, b);
  }
}

/**
 * Specify a sequence of buckets that all have the same width (except
 * overflow and underflow).  Each bucket represents a constant absolute
 * uncertainty on the specific value in the bucket.
 *
 * Defines `num_finite_buckets + 2` (= N) buckets with these boundaries for
 * bucket `i`:
 *
 *    Upper bound (0 <= i < N-1):     offset + (width * i).
 *    Lower bound (1 <= i < N):       offset + (width * (i - 1)).
 *
 * @generated from message google.api.Distribution.BucketOptions.Linear
 */
export class Distribution_BucketOptions_Linear extends Message<Distribution_BucketOptions_Linear> {
  /**
   * Must be greater than 0.
   *
   * @generated from field: int32 num_finite_buckets = 1;
   */
  numFiniteBuckets = 0;

  /**
   * Must be greater than 0.
   *
   * @generated from field: double width = 2;
   */
  width = 0;

  /**
   * Lower bound of the first bucket.
   *
   * @generated from field: double offset = 3;
   */
  offset = 0;

  constructor(data?: PartialMessage<Distribution_BucketOptions_Linear>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.Distribution.BucketOptions.Linear";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "num_finite_buckets", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "width", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "offset", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Distribution_BucketOptions_Linear {
    return new Distribution_BucketOptions_Linear().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Distribution_BucketOptions_Linear {
    return new Distribution_BucketOptions_Linear().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Distribution_BucketOptions_Linear {
    return new Distribution_BucketOptions_Linear().fromJsonString(jsonString, options);
  }

  static equals(a: Distribution_BucketOptions_Linear | PlainMessage<Distribution_BucketOptions_Linear> | undefined, b: Distribution_BucketOptions_Linear | PlainMessage<Distribution_BucketOptions_Linear> | undefined): boolean {
    return proto3.util.equals(Distribution_BucketOptions_Linear, a, b);
  }
}

/**
 * Specify a sequence of buckets that have a width that is proportional to
 * the value of the lower bound.  Each bucket represents a constant relative
 * uncertainty on a specific value in the bucket.
 *
 * Defines `num_finite_buckets + 2` (= N) buckets with these boundaries for
 * bucket i:
 *
 *    Upper bound (0 <= i < N-1):     scale * (growth_factor ^ i).
 *    Lower bound (1 <= i < N):       scale * (growth_factor ^ (i - 1)).
 *
 * @generated from message google.api.Distribution.BucketOptions.Exponential
 */
export class Distribution_BucketOptions_Exponential extends Message<Distribution_BucketOptions_Exponential> {
  /**
   * Must be greater than 0.
   *
   * @generated from field: int32 num_finite_buckets = 1;
   */
  numFiniteBuckets = 0;

  /**
   * Must be greater than 1.
   *
   * @generated from field: double growth_factor = 2;
   */
  growthFactor = 0;

  /**
   * Must be greater than 0.
   *
   * @generated from field: double scale = 3;
   */
  scale = 0;

  constructor(data?: PartialMessage<Distribution_BucketOptions_Exponential>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.Distribution.BucketOptions.Exponential";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "num_finite_buckets", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "growth_factor", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "scale", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Distribution_BucketOptions_Exponential {
    return new Distribution_BucketOptions_Exponential().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Distribution_BucketOptions_Exponential {
    return new Distribution_BucketOptions_Exponential().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Distribution_BucketOptions_Exponential {
    return new Distribution_BucketOptions_Exponential().fromJsonString(jsonString, options);
  }

  static equals(a: Distribution_BucketOptions_Exponential | PlainMessage<Distribution_BucketOptions_Exponential> | undefined, b: Distribution_BucketOptions_Exponential | PlainMessage<Distribution_BucketOptions_Exponential> | undefined): boolean {
    return proto3.util.equals(Distribution_BucketOptions_Exponential, a, b);
  }
}

/**
 * A set of buckets with arbitrary widths.
 *
 * Defines `size(bounds) + 1` (= N) buckets with these boundaries for
 * bucket i:
 *
 *    Upper bound (0 <= i < N-1):     bounds[i]
 *    Lower bound (1 <= i < N);       bounds[i - 1]
 *
 * There must be at least one element in `bounds`.  If `bounds` has only one
 * element, there are no finite buckets, and that single element is the
 * common boundary of the overflow and underflow buckets.
 *
 * @generated from message google.api.Distribution.BucketOptions.Explicit
 */
export class Distribution_BucketOptions_Explicit extends Message<Distribution_BucketOptions_Explicit> {
  /**
   * The values must be monotonically increasing.
   *
   * @generated from field: repeated double bounds = 1;
   */
  bounds: number[] = [];

  constructor(data?: PartialMessage<Distribution_BucketOptions_Explicit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.api.Distribution.BucketOptions.Explicit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bounds", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Distribution_BucketOptions_Explicit {
    return new Distribution_BucketOptions_Explicit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Distribution_BucketOptions_Explicit {
    return new Distribution_BucketOptions_Explicit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Distribution_BucketOptions_Explicit {
    return new Distribution_BucketOptions_Explicit().fromJsonString(jsonString, options);
  }

  static equals(a: Distribution_BucketOptions_Explicit | PlainMessage<Distribution_BucketOptions_Explicit> | undefined, b: Distribution_BucketOptions_Explicit | PlainMessage<Distribution_BucketOptions_Explicit> | undefined): boolean {
    return proto3.util.equals(Distribution_BucketOptions_Explicit, a, b);
  }
}

