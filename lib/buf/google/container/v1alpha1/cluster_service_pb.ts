// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/container/v1alpha1/cluster_service.proto (package google.container.v1alpha1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * Parameters that describe the nodes in a cluster.
 *
 * @generated from message google.container.v1alpha1.NodeConfig
 */
export class NodeConfig extends Message<NodeConfig> {
  /**
   * The name of a Google Compute Engine [machine
   * type](/compute/docs/machine-types) (e.g.
   * `n1-standard-1`).
   *
   * If unspecified, the default machine type is
   * `n1-standard-1`.
   *
   * @generated from field: string machine_type = 1;
   */
  machineType = "";

  /**
   * Size of the disk attached to each node, specified in GB.
   * The smallest allowed disk size is 10GB.
   *
   * If unspecified, the default disk size is 100GB.
   *
   * @generated from field: int32 disk_size_gb = 2;
   */
  diskSizeGb = 0;

  /**
   * The set of Google API scopes to be made available on all of the
   * node VMs under the "default" service account.
   *
   * The following scopes are recommended, but not required, and by default are
   * not included:
   *
   * * `https://www.googleapis.com/auth/compute` is required for mounting
   * persistent storage on your nodes.
   * * `https://www.googleapis.com/auth/devstorage.read_only` is required for
   * communicating with **gcr.io**
   * (the [Google Container Registry](/container-registry/)).
   *
   * If unspecified, no scopes are added, unless Cloud Logging or Cloud
   * Monitoring are enabled, in which case their required scopes will be added.
   *
   * @generated from field: repeated string oauth_scopes = 3;
   */
  oauthScopes: string[] = [];

  /**
   * The Google Cloud Platform Service Account to be used by the node VMs. If
   * no Service Account is specified, the "default" service account is used.
   *
   * @generated from field: string service_account = 9;
   */
  serviceAccount = "";

  /**
   * The metadata key/value pairs assigned to instances in the cluster.
   *
   * Keys must conform to the regexp [a-zA-Z0-9-_]+ and be less than 128 bytes
   * in length. These are reflected as part of a URL in the metadata server.
   * Additionally, to avoid ambiguity, keys must not conflict with any other
   * metadata keys for the project or be one of the four reserved keys:
   * "instance-template", "kube-env", "startup-script", and "user-data"
   *
   * Values are free-form strings, and only have meaning as interpreted by
   * the image running in the instance. The only restriction placed on them is
   * that each value's size must be less than or equal to 32 KB.
   *
   * The total size of all keys and values must be less than 512 KB.
   *
   * @generated from field: map<string, string> metadata = 4;
   */
  metadata: { [key: string]: string } = {};

  /**
   * The image type to use for this node. Note that for a given image type,
   * the latest version of it will be used.
   *
   * @generated from field: string image_type = 5;
   */
  imageType = "";

  /**
   * The map of Kubernetes labels (key/value pairs) to be applied to each node.
   * These will added in addition to any default label(s) that
   * Kubernetes may apply to the node.
   * In case of conflict in label keys, the applied set may differ depending on
   * the Kubernetes version -- it's best to assume the behavior is undefined
   * and conflicts should be avoided.
   * For more information, including usage and the valid values, see:
   * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
   *
   * @generated from field: map<string, string> labels = 6;
   */
  labels: { [key: string]: string } = {};

  /**
   * The number of local SSD disks to be attached to the node.
   *
   * The limit for this value is dependant upon the maximum number of
   * disks available on a machine per zone. See:
   * https://cloud.google.com/compute/docs/disks/local-ssd#local_ssd_limits
   * for more information.
   *
   * @generated from field: int32 local_ssd_count = 7;
   */
  localSsdCount = 0;

  /**
   * The list of instance tags applied to all nodes. Tags are used to identify
   * valid sources or targets for network firewalls and are specified by
   * the client during cluster or node pool creation. Each tag within the list
   * must comply with RFC1035.
   *
   * @generated from field: repeated string tags = 8;
   */
  tags: string[] = [];

  /**
   * Whether the nodes are created as preemptible VM instances. See:
   * https://cloud.google.com/compute/docs/instances/preemptible for more
   * inforamtion about preemptible VM instances.
   *
   * @generated from field: bool preemptible = 10;
   */
  preemptible = false;

  /**
   * A list of hardware accelerators to be attached to each node.
   * See https://cloud.google.com/compute/docs/gpus for more information about
   * support for GPUs.
   *
   * @generated from field: repeated google.container.v1alpha1.AcceleratorConfig accelerators = 11;
   */
  accelerators: AcceleratorConfig[] = [];

  /**
   * Minimum CPU platform to be used by this instance. The instance may be
   * scheduled on the specified or newer CPU platform. Applicable values are the
   * friendly names of CPU platforms, such as
   * <code>minCpuPlatform: &quot;Intel Haswell&quot;</code> or
   * <code>minCpuPlatform: &quot;Intel Sandy Bridge&quot;</code>. For more
   * information, read [how to specify min CPU platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
   *
   * @generated from field: string min_cpu_platform = 13;
   */
  minCpuPlatform = "";

  /**
   * List of kubernetes taints to be applied to each node.
   *
   * For more information, including usage and the valid values, see:
   * https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
   *
   * @generated from field: repeated google.container.v1alpha1.NodeTaint taints = 15;
   */
  taints: NodeTaint[] = [];

  constructor(data?: PartialMessage<NodeConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.NodeConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "machine_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "disk_size_gb", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "oauth_scopes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 9, name: "service_account", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 5, name: "image_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 7, name: "local_ssd_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 8, name: "tags", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 10, name: "preemptible", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "accelerators", kind: "message", T: AcceleratorConfig, repeated: true },
    { no: 13, name: "min_cpu_platform", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 15, name: "taints", kind: "message", T: NodeTaint, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NodeConfig {
    return new NodeConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NodeConfig {
    return new NodeConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NodeConfig {
    return new NodeConfig().fromJsonString(jsonString, options);
  }

  static equals(a: NodeConfig | PlainMessage<NodeConfig> | undefined, b: NodeConfig | PlainMessage<NodeConfig> | undefined): boolean {
    return proto3.util.equals(NodeConfig, a, b);
  }
}

/**
 * Kubernetes taint is comprised of three fields: key, value, and effect. Effect
 * can only be one of three types:  NoSchedule, PreferNoSchedule or NoExecute.
 *
 * For more information, including usage and the valid values, see:
 * https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
 *
 * @generated from message google.container.v1alpha1.NodeTaint
 */
export class NodeTaint extends Message<NodeTaint> {
  /**
   * Key for taint.
   *
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * Value for taint.
   *
   * @generated from field: string value = 2;
   */
  value = "";

  /**
   * Effect for taint.
   *
   * @generated from field: google.container.v1alpha1.NodeTaint.Effect effect = 3;
   */
  effect = NodeTaint_Effect.EFFECT_UNSPECIFIED;

  constructor(data?: PartialMessage<NodeTaint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.NodeTaint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "effect", kind: "enum", T: proto3.getEnumType(NodeTaint_Effect) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NodeTaint {
    return new NodeTaint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NodeTaint {
    return new NodeTaint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NodeTaint {
    return new NodeTaint().fromJsonString(jsonString, options);
  }

  static equals(a: NodeTaint | PlainMessage<NodeTaint> | undefined, b: NodeTaint | PlainMessage<NodeTaint> | undefined): boolean {
    return proto3.util.equals(NodeTaint, a, b);
  }
}

/**
 * Possible values for Effect in taint.
 *
 * @generated from enum google.container.v1alpha1.NodeTaint.Effect
 */
export enum NodeTaint_Effect {
  /**
   * Not set
   *
   * @generated from enum value: EFFECT_UNSPECIFIED = 0;
   */
  EFFECT_UNSPECIFIED = 0,

  /**
   * NoSchedule
   *
   * @generated from enum value: NO_SCHEDULE = 1;
   */
  NO_SCHEDULE = 1,

  /**
   * PreferNoSchedule
   *
   * @generated from enum value: PREFER_NO_SCHEDULE = 2;
   */
  PREFER_NO_SCHEDULE = 2,

  /**
   * NoExecute
   *
   * @generated from enum value: NO_EXECUTE = 3;
   */
  NO_EXECUTE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(NodeTaint_Effect)
proto3.util.setEnumType(NodeTaint_Effect, "google.container.v1alpha1.NodeTaint.Effect", [
  { no: 0, name: "EFFECT_UNSPECIFIED" },
  { no: 1, name: "NO_SCHEDULE" },
  { no: 2, name: "PREFER_NO_SCHEDULE" },
  { no: 3, name: "NO_EXECUTE" },
]);

/**
 * The authentication information for accessing the master endpoint.
 * Authentication can be done using HTTP basic auth or using client
 * certificates.
 *
 * @generated from message google.container.v1alpha1.MasterAuth
 */
export class MasterAuth extends Message<MasterAuth> {
  /**
   * The username to use for HTTP basic authentication to the master endpoint.
   * For clusters v1.6.0 and later, you can disable basic authentication by
   * providing an empty username.
   *
   * @generated from field: string username = 1;
   */
  username = "";

  /**
   * The password to use for HTTP basic authentication to the master endpoint.
   * Because the master endpoint is open to the Internet, you should create a
   * strong password.  If a password is provided for cluster creation, username
   * must be non-empty.
   *
   * @generated from field: string password = 2;
   */
  password = "";

  /**
   * Configuration for client certificate authentication on the cluster.  If no
   * configuration is specified, a client certificate is issued.
   *
   * @generated from field: google.container.v1alpha1.ClientCertificateConfig client_certificate_config = 3;
   */
  clientCertificateConfig?: ClientCertificateConfig;

  /**
   * [Output only] Base64-encoded public certificate that is the root of
   * trust for the cluster.
   *
   * @generated from field: string cluster_ca_certificate = 100;
   */
  clusterCaCertificate = "";

  /**
   * [Output only] Base64-encoded public certificate used by clients to
   * authenticate to the cluster endpoint.
   *
   * @generated from field: string client_certificate = 101;
   */
  clientCertificate = "";

  /**
   * [Output only] Base64-encoded private key used by clients to authenticate
   * to the cluster endpoint.
   *
   * @generated from field: string client_key = 102;
   */
  clientKey = "";

  constructor(data?: PartialMessage<MasterAuth>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.MasterAuth";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "password", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "client_certificate_config", kind: "message", T: ClientCertificateConfig },
    { no: 100, name: "cluster_ca_certificate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 101, name: "client_certificate", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 102, name: "client_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MasterAuth {
    return new MasterAuth().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MasterAuth {
    return new MasterAuth().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MasterAuth {
    return new MasterAuth().fromJsonString(jsonString, options);
  }

  static equals(a: MasterAuth | PlainMessage<MasterAuth> | undefined, b: MasterAuth | PlainMessage<MasterAuth> | undefined): boolean {
    return proto3.util.equals(MasterAuth, a, b);
  }
}

/**
 * Configuration for client certificates on the cluster.
 *
 * @generated from message google.container.v1alpha1.ClientCertificateConfig
 */
export class ClientCertificateConfig extends Message<ClientCertificateConfig> {
  /**
   * Issue a client certificate.
   *
   * @generated from field: bool issue_client_certificate = 1;
   */
  issueClientCertificate = false;

  constructor(data?: PartialMessage<ClientCertificateConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.ClientCertificateConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "issue_client_certificate", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClientCertificateConfig {
    return new ClientCertificateConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClientCertificateConfig {
    return new ClientCertificateConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClientCertificateConfig {
    return new ClientCertificateConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ClientCertificateConfig | PlainMessage<ClientCertificateConfig> | undefined, b: ClientCertificateConfig | PlainMessage<ClientCertificateConfig> | undefined): boolean {
    return proto3.util.equals(ClientCertificateConfig, a, b);
  }
}

/**
 * Configuration for the addons that can be automatically spun up in the
 * cluster, enabling additional functionality.
 *
 * @generated from message google.container.v1alpha1.AddonsConfig
 */
export class AddonsConfig extends Message<AddonsConfig> {
  /**
   * Configuration for the HTTP (L7) load balancing controller addon, which
   * makes it easy to set up HTTP load balancers for services in a cluster.
   *
   * @generated from field: google.container.v1alpha1.HttpLoadBalancing http_load_balancing = 1;
   */
  httpLoadBalancing?: HttpLoadBalancing;

  /**
   * Configuration for the horizontal pod autoscaling feature, which
   * increases or decreases the number of replica pods a replication controller
   * has based on the resource usage of the existing pods.
   *
   * @generated from field: google.container.v1alpha1.HorizontalPodAutoscaling horizontal_pod_autoscaling = 2;
   */
  horizontalPodAutoscaling?: HorizontalPodAutoscaling;

  /**
   * Configuration for the Kubernetes Dashboard.
   *
   * @generated from field: google.container.v1alpha1.KubernetesDashboard kubernetes_dashboard = 3;
   */
  kubernetesDashboard?: KubernetesDashboard;

  /**
   * Configuration for NetworkPolicy. This only tracks whether the addon
   * is enabled or not on the Master, it does not track whether network policy
   * is enabled for the nodes.
   *
   * @generated from field: google.container.v1alpha1.NetworkPolicyConfig network_policy_config = 4;
   */
  networkPolicyConfig?: NetworkPolicyConfig;

  constructor(data?: PartialMessage<AddonsConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.AddonsConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "http_load_balancing", kind: "message", T: HttpLoadBalancing },
    { no: 2, name: "horizontal_pod_autoscaling", kind: "message", T: HorizontalPodAutoscaling },
    { no: 3, name: "kubernetes_dashboard", kind: "message", T: KubernetesDashboard },
    { no: 4, name: "network_policy_config", kind: "message", T: NetworkPolicyConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AddonsConfig {
    return new AddonsConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AddonsConfig {
    return new AddonsConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AddonsConfig {
    return new AddonsConfig().fromJsonString(jsonString, options);
  }

  static equals(a: AddonsConfig | PlainMessage<AddonsConfig> | undefined, b: AddonsConfig | PlainMessage<AddonsConfig> | undefined): boolean {
    return proto3.util.equals(AddonsConfig, a, b);
  }
}

/**
 * Configuration options for the HTTP (L7) load balancing controller addon,
 * which makes it easy to set up HTTP load balancers for services in a cluster.
 *
 * @generated from message google.container.v1alpha1.HttpLoadBalancing
 */
export class HttpLoadBalancing extends Message<HttpLoadBalancing> {
  /**
   * Whether the HTTP Load Balancing controller is enabled in the cluster.
   * When enabled, it runs a small pod in the cluster that manages the load
   * balancers.
   *
   * @generated from field: bool disabled = 1;
   */
  disabled = false;

  constructor(data?: PartialMessage<HttpLoadBalancing>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.HttpLoadBalancing";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "disabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HttpLoadBalancing {
    return new HttpLoadBalancing().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HttpLoadBalancing {
    return new HttpLoadBalancing().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HttpLoadBalancing {
    return new HttpLoadBalancing().fromJsonString(jsonString, options);
  }

  static equals(a: HttpLoadBalancing | PlainMessage<HttpLoadBalancing> | undefined, b: HttpLoadBalancing | PlainMessage<HttpLoadBalancing> | undefined): boolean {
    return proto3.util.equals(HttpLoadBalancing, a, b);
  }
}

/**
 * Configuration options for the horizontal pod autoscaling feature, which
 * increases or decreases the number of replica pods a replication controller
 * has based on the resource usage of the existing pods.
 *
 * @generated from message google.container.v1alpha1.HorizontalPodAutoscaling
 */
export class HorizontalPodAutoscaling extends Message<HorizontalPodAutoscaling> {
  /**
   * Whether the Horizontal Pod Autoscaling feature is enabled in the cluster.
   * When enabled, it ensures that a Heapster pod is running in the cluster,
   * which is also used by the Cloud Monitoring service.
   *
   * @generated from field: bool disabled = 1;
   */
  disabled = false;

  constructor(data?: PartialMessage<HorizontalPodAutoscaling>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.HorizontalPodAutoscaling";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "disabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HorizontalPodAutoscaling {
    return new HorizontalPodAutoscaling().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HorizontalPodAutoscaling {
    return new HorizontalPodAutoscaling().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HorizontalPodAutoscaling {
    return new HorizontalPodAutoscaling().fromJsonString(jsonString, options);
  }

  static equals(a: HorizontalPodAutoscaling | PlainMessage<HorizontalPodAutoscaling> | undefined, b: HorizontalPodAutoscaling | PlainMessage<HorizontalPodAutoscaling> | undefined): boolean {
    return proto3.util.equals(HorizontalPodAutoscaling, a, b);
  }
}

/**
 * Configuration for the Kubernetes Dashboard.
 *
 * @generated from message google.container.v1alpha1.KubernetesDashboard
 */
export class KubernetesDashboard extends Message<KubernetesDashboard> {
  /**
   * Whether the Kubernetes Dashboard is enabled for this cluster.
   *
   * @generated from field: bool disabled = 1;
   */
  disabled = false;

  constructor(data?: PartialMessage<KubernetesDashboard>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.KubernetesDashboard";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "disabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KubernetesDashboard {
    return new KubernetesDashboard().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KubernetesDashboard {
    return new KubernetesDashboard().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KubernetesDashboard {
    return new KubernetesDashboard().fromJsonString(jsonString, options);
  }

  static equals(a: KubernetesDashboard | PlainMessage<KubernetesDashboard> | undefined, b: KubernetesDashboard | PlainMessage<KubernetesDashboard> | undefined): boolean {
    return proto3.util.equals(KubernetesDashboard, a, b);
  }
}

/**
 * Configuration for NetworkPolicy. This only tracks whether the addon
 * is enabled or not on the Master, it does not track whether network policy
 * is enabled for the nodes.
 *
 * @generated from message google.container.v1alpha1.NetworkPolicyConfig
 */
export class NetworkPolicyConfig extends Message<NetworkPolicyConfig> {
  /**
   * Whether NetworkPolicy is enabled for this cluster.
   *
   * @generated from field: bool disabled = 1;
   */
  disabled = false;

  constructor(data?: PartialMessage<NetworkPolicyConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.NetworkPolicyConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "disabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NetworkPolicyConfig {
    return new NetworkPolicyConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NetworkPolicyConfig {
    return new NetworkPolicyConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NetworkPolicyConfig {
    return new NetworkPolicyConfig().fromJsonString(jsonString, options);
  }

  static equals(a: NetworkPolicyConfig | PlainMessage<NetworkPolicyConfig> | undefined, b: NetworkPolicyConfig | PlainMessage<NetworkPolicyConfig> | undefined): boolean {
    return proto3.util.equals(NetworkPolicyConfig, a, b);
  }
}

/**
 * Configuration options for the master authorized networks feature. Enabled
 * master authorized networks will disallow all external traffic to access
 * Kubernetes master through HTTPS except traffic from the given CIDR blocks,
 * Google Compute Engine Public IPs and Google Prod IPs.
 *
 * @generated from message google.container.v1alpha1.MasterAuthorizedNetworksConfig
 */
export class MasterAuthorizedNetworksConfig extends Message<MasterAuthorizedNetworksConfig> {
  /**
   * Whether or not master authorized networks is enabled.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * cidr_blocks define up to 10 external networks that could access
   * Kubernetes master through HTTPS.
   *
   * @generated from field: repeated google.container.v1alpha1.MasterAuthorizedNetworksConfig.CidrBlock cidr_blocks = 2;
   */
  cidrBlocks: MasterAuthorizedNetworksConfig_CidrBlock[] = [];

  constructor(data?: PartialMessage<MasterAuthorizedNetworksConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.MasterAuthorizedNetworksConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "cidr_blocks", kind: "message", T: MasterAuthorizedNetworksConfig_CidrBlock, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MasterAuthorizedNetworksConfig {
    return new MasterAuthorizedNetworksConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MasterAuthorizedNetworksConfig {
    return new MasterAuthorizedNetworksConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MasterAuthorizedNetworksConfig {
    return new MasterAuthorizedNetworksConfig().fromJsonString(jsonString, options);
  }

  static equals(a: MasterAuthorizedNetworksConfig | PlainMessage<MasterAuthorizedNetworksConfig> | undefined, b: MasterAuthorizedNetworksConfig | PlainMessage<MasterAuthorizedNetworksConfig> | undefined): boolean {
    return proto3.util.equals(MasterAuthorizedNetworksConfig, a, b);
  }
}

/**
 * CidrBlock contains an optional name and one CIDR block.
 *
 * @generated from message google.container.v1alpha1.MasterAuthorizedNetworksConfig.CidrBlock
 */
export class MasterAuthorizedNetworksConfig_CidrBlock extends Message<MasterAuthorizedNetworksConfig_CidrBlock> {
  /**
   * display_name is an optional field for users to identify CIDR blocks.
   *
   * @generated from field: string display_name = 1;
   */
  displayName = "";

  /**
   * cidr_block must be specified in CIDR notation.
   *
   * @generated from field: string cidr_block = 2;
   */
  cidrBlock = "";

  constructor(data?: PartialMessage<MasterAuthorizedNetworksConfig_CidrBlock>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.MasterAuthorizedNetworksConfig.CidrBlock";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cidr_block", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MasterAuthorizedNetworksConfig_CidrBlock {
    return new MasterAuthorizedNetworksConfig_CidrBlock().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MasterAuthorizedNetworksConfig_CidrBlock {
    return new MasterAuthorizedNetworksConfig_CidrBlock().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MasterAuthorizedNetworksConfig_CidrBlock {
    return new MasterAuthorizedNetworksConfig_CidrBlock().fromJsonString(jsonString, options);
  }

  static equals(a: MasterAuthorizedNetworksConfig_CidrBlock | PlainMessage<MasterAuthorizedNetworksConfig_CidrBlock> | undefined, b: MasterAuthorizedNetworksConfig_CidrBlock | PlainMessage<MasterAuthorizedNetworksConfig_CidrBlock> | undefined): boolean {
    return proto3.util.equals(MasterAuthorizedNetworksConfig_CidrBlock, a, b);
  }
}

/**
 * Configuration options for the NetworkPolicy feature.
 * https://kubernetes.io/docs/concepts/services-networking/networkpolicies/
 *
 * @generated from message google.container.v1alpha1.NetworkPolicy
 */
export class NetworkPolicy extends Message<NetworkPolicy> {
  /**
   * The selected network policy provider.
   *
   * @generated from field: google.container.v1alpha1.NetworkPolicy.Provider provider = 1;
   */
  provider = NetworkPolicy_Provider.PROVIDER_UNSPECIFIED;

  /**
   * Whether network policy is enabled on the cluster.
   *
   * @generated from field: bool enabled = 2;
   */
  enabled = false;

  constructor(data?: PartialMessage<NetworkPolicy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.NetworkPolicy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "provider", kind: "enum", T: proto3.getEnumType(NetworkPolicy_Provider) },
    { no: 2, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NetworkPolicy {
    return new NetworkPolicy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NetworkPolicy {
    return new NetworkPolicy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NetworkPolicy {
    return new NetworkPolicy().fromJsonString(jsonString, options);
  }

  static equals(a: NetworkPolicy | PlainMessage<NetworkPolicy> | undefined, b: NetworkPolicy | PlainMessage<NetworkPolicy> | undefined): boolean {
    return proto3.util.equals(NetworkPolicy, a, b);
  }
}

/**
 * Allowed Network Policy providers.
 *
 * @generated from enum google.container.v1alpha1.NetworkPolicy.Provider
 */
export enum NetworkPolicy_Provider {
  /**
   * Not set
   *
   * @generated from enum value: PROVIDER_UNSPECIFIED = 0;
   */
  PROVIDER_UNSPECIFIED = 0,

  /**
   * Tigera (Calico Felix).
   *
   * @generated from enum value: CALICO = 1;
   */
  CALICO = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(NetworkPolicy_Provider)
proto3.util.setEnumType(NetworkPolicy_Provider, "google.container.v1alpha1.NetworkPolicy.Provider", [
  { no: 0, name: "PROVIDER_UNSPECIFIED" },
  { no: 1, name: "CALICO" },
]);

/**
 * Configuration for controlling how IPs are allocated in the cluster.
 *
 * @generated from message google.container.v1alpha1.IPAllocationPolicy
 */
export class IPAllocationPolicy extends Message<IPAllocationPolicy> {
  /**
   * Whether alias IPs will be used for pod IPs in the cluster.
   *
   * @generated from field: bool use_ip_aliases = 1;
   */
  useIpAliases = false;

  /**
   * Whether a new subnetwork will be created automatically for the cluster.
   *
   * This field is only applicable when `use_ip_aliases` is true.
   *
   * @generated from field: bool create_subnetwork = 2;
   */
  createSubnetwork = false;

  /**
   * A custom subnetwork name to be used if `create_subnetwork` is true.  If
   * this field is empty, then an automatic name will be chosen for the new
   * subnetwork.
   *
   * @generated from field: string subnetwork_name = 3;
   */
  subnetworkName = "";

  /**
   * This field is deprecated, use cluster_ipv4_cidr_block.
   *
   * @generated from field: string cluster_ipv4_cidr = 4;
   */
  clusterIpv4Cidr = "";

  /**
   * This field is deprecated, use node_ipv4_cidr_block.
   *
   * @generated from field: string node_ipv4_cidr = 5;
   */
  nodeIpv4Cidr = "";

  /**
   * This field is deprecated, use services_ipv4_cidr_block.
   *
   * @generated from field: string services_ipv4_cidr = 6;
   */
  servicesIpv4Cidr = "";

  /**
   * The name of the secondary range to be used for the cluster CIDR
   * block.  The secondary range will be used for pod IP
   * addresses. This must be an existing secondary range associated
   * with the cluster subnetwork.
   *
   * This field is only applicable if use_ip_aliases is true and
   * create_subnetwork is false.
   *
   * @generated from field: string cluster_secondary_range_name = 7;
   */
  clusterSecondaryRangeName = "";

  /**
   * The name of the secondary range to be used as for the services
   * CIDR block.  The secondary range will be used for service
   * ClusterIPs. This must be an existing secondary range associated
   * with the cluster subnetwork.
   *
   * This field is only applicable with use_ip_aliases is true and
   * create_subnetwork is false.
   *
   * @generated from field: string services_secondary_range_name = 8;
   */
  servicesSecondaryRangeName = "";

  /**
   * The IP address range for the cluster pod IPs. If this field is set, then
   * `cluster.cluster_ipv4_cidr` must be left blank.
   *
   * This field is only applicable when `use_ip_aliases` is true.
   *
   * Set to blank to have a range chosen with the default size.
   *
   * Set to /netmask (e.g. `/14`) to have a range chosen with a specific
   * netmask.
   *
   * Set to a
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
   * `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
   * to use.
   *
   * @generated from field: string cluster_ipv4_cidr_block = 9;
   */
  clusterIpv4CidrBlock = "";

  /**
   * The IP address range of the instance IPs in this cluster.
   *
   * This is applicable only if `create_subnetwork` is true.
   *
   * Set to blank to have a range chosen with the default size.
   *
   * Set to /netmask (e.g. `/14`) to have a range chosen with a specific
   * netmask.
   *
   * Set to a
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
   * `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
   * to use.
   *
   * @generated from field: string node_ipv4_cidr_block = 10;
   */
  nodeIpv4CidrBlock = "";

  /**
   * The IP address range of the services IPs in this cluster. If blank, a range
   * will be automatically chosen with the default size.
   *
   * This field is only applicable when `use_ip_aliases` is true.
   *
   * Set to blank to have a range chosen with the default size.
   *
   * Set to /netmask (e.g. `/14`) to have a range chosen with a specific
   * netmask.
   *
   * Set to a
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
   * `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
   * to use.
   *
   * @generated from field: string services_ipv4_cidr_block = 11;
   */
  servicesIpv4CidrBlock = "";

  constructor(data?: PartialMessage<IPAllocationPolicy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.IPAllocationPolicy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "use_ip_aliases", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "create_subnetwork", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "subnetwork_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "cluster_ipv4_cidr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "node_ipv4_cidr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "services_ipv4_cidr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "cluster_secondary_range_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "services_secondary_range_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "cluster_ipv4_cidr_block", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "node_ipv4_cidr_block", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "services_ipv4_cidr_block", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IPAllocationPolicy {
    return new IPAllocationPolicy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IPAllocationPolicy {
    return new IPAllocationPolicy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IPAllocationPolicy {
    return new IPAllocationPolicy().fromJsonString(jsonString, options);
  }

  static equals(a: IPAllocationPolicy | PlainMessage<IPAllocationPolicy> | undefined, b: IPAllocationPolicy | PlainMessage<IPAllocationPolicy> | undefined): boolean {
    return proto3.util.equals(IPAllocationPolicy, a, b);
  }
}

/**
 * Configuration for the PodSecurityPolicy feature.
 *
 * @generated from message google.container.v1alpha1.PodSecurityPolicyConfig
 */
export class PodSecurityPolicyConfig extends Message<PodSecurityPolicyConfig> {
  /**
   * Enable the PodSecurityPolicy controller for this cluster. If enabled, pods
   * must be valid under a PodSecurityPolicy to be created.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  constructor(data?: PartialMessage<PodSecurityPolicyConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.PodSecurityPolicyConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PodSecurityPolicyConfig {
    return new PodSecurityPolicyConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PodSecurityPolicyConfig {
    return new PodSecurityPolicyConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PodSecurityPolicyConfig {
    return new PodSecurityPolicyConfig().fromJsonString(jsonString, options);
  }

  static equals(a: PodSecurityPolicyConfig | PlainMessage<PodSecurityPolicyConfig> | undefined, b: PodSecurityPolicyConfig | PlainMessage<PodSecurityPolicyConfig> | undefined): boolean {
    return proto3.util.equals(PodSecurityPolicyConfig, a, b);
  }
}

/**
 * A Google Container Engine cluster.
 *
 * @generated from message google.container.v1alpha1.Cluster
 */
export class Cluster extends Message<Cluster> {
  /**
   * The name of this cluster. The name must be unique within this project
   * and zone, and can be up to 40 characters with the following restrictions:
   *
   * * Lowercase letters, numbers, and hyphens only.
   * * Must start with a letter.
   * * Must end with a number or a letter.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * An optional description of this cluster.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * The number of nodes to create in this cluster. You must ensure that your
   * Compute Engine <a href="/compute/docs/resource-quotas">resource quota</a>
   * is sufficient for this number of instances. You must also have available
   * firewall and routes quota.
   * For requests, this field should only be used in lieu of a
   * "node_pool" object, since this configuration (along with the
   * "node_config") will be used to create a "NodePool" object with an
   * auto-generated name. Do not use this and a node_pool at the same time.
   *
   * @generated from field: int32 initial_node_count = 3;
   */
  initialNodeCount = 0;

  /**
   * Parameters used in creating the cluster's nodes.
   * See `nodeConfig` for the description of its properties.
   * For requests, this field should only be used in lieu of a
   * "node_pool" object, since this configuration (along with the
   * "initial_node_count") will be used to create a "NodePool" object with an
   * auto-generated name. Do not use this and a node_pool at the same time.
   * For responses, this field will be populated with the node configuration of
   * the first node pool.
   *
   * If unspecified, the defaults are used.
   *
   * @generated from field: google.container.v1alpha1.NodeConfig node_config = 4;
   */
  nodeConfig?: NodeConfig;

  /**
   * The authentication information for accessing the master endpoint.
   *
   * @generated from field: google.container.v1alpha1.MasterAuth master_auth = 5;
   */
  masterAuth?: MasterAuth;

  /**
   * The logging service the cluster should use to write logs.
   * Currently available options:
   *
   * * `logging.googleapis.com` - the Google Cloud Logging service.
   * * `none` - no logs will be exported from the cluster.
   * * if left as an empty string,`logging.googleapis.com` will be used.
   *
   * @generated from field: string logging_service = 6;
   */
  loggingService = "";

  /**
   * The monitoring service the cluster should use to write metrics.
   * Currently available options:
   *
   * * `monitoring.googleapis.com` - the Google Cloud Monitoring service.
   * * `none` - no metrics will be exported from the cluster.
   * * if left as an empty string, `monitoring.googleapis.com` will be used.
   *
   * @generated from field: string monitoring_service = 7;
   */
  monitoringService = "";

  /**
   * The name of the Google Compute Engine
   * [network](/compute/docs/networks-and-firewalls#networks) to which the
   * cluster is connected. If left unspecified, the `default` network
   * will be used.
   *
   * @generated from field: string network = 8;
   */
  network = "";

  /**
   * The IP address range of the container pods in this cluster, in
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `10.96.0.0/14`). Leave blank to have
   * one automatically chosen or specify a `/14` block in `10.0.0.0/8`.
   *
   * @generated from field: string cluster_ipv4_cidr = 9;
   */
  clusterIpv4Cidr = "";

  /**
   * Configurations for the various addons available to run in the cluster.
   *
   * @generated from field: google.container.v1alpha1.AddonsConfig addons_config = 10;
   */
  addonsConfig?: AddonsConfig;

  /**
   * The name of the Google Compute Engine
   * [subnetwork](/compute/docs/subnetworks) to which the
   * cluster is connected.
   *
   * @generated from field: string subnetwork = 11;
   */
  subnetwork = "";

  /**
   * The node pools associated with this cluster.
   * This field should not be set if "node_config" or "initial_node_count" are
   * specified.
   *
   * @generated from field: repeated google.container.v1alpha1.NodePool node_pools = 12;
   */
  nodePools: NodePool[] = [];

  /**
   * The list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located.
   *
   * @generated from field: repeated string locations = 13;
   */
  locations: string[] = [];

  /**
   * Kubernetes alpha features are enabled on this cluster. This includes alpha
   * API groups (e.g. v1alpha1) and features that may not be production ready in
   * the kubernetes version of the master and nodes.
   * The cluster has no SLA for uptime and master/node upgrades are disabled.
   * Alpha enabled clusters are automatically deleted thirty days after
   * creation.
   *
   * @generated from field: bool enable_kubernetes_alpha = 14;
   */
  enableKubernetesAlpha = false;

  /**
   * Configuration options for the NetworkPolicy feature.
   *
   * @generated from field: google.container.v1alpha1.NetworkPolicy network_policy = 19;
   */
  networkPolicy?: NetworkPolicy;

  /**
   * Configuration for cluster IP allocation.
   *
   * @generated from field: google.container.v1alpha1.IPAllocationPolicy ip_allocation_policy = 20;
   */
  ipAllocationPolicy?: IPAllocationPolicy;

  /**
   * The configuration options for master authorized networks feature.
   *
   * @generated from field: google.container.v1alpha1.MasterAuthorizedNetworksConfig master_authorized_networks_config = 22;
   */
  masterAuthorizedNetworksConfig?: MasterAuthorizedNetworksConfig;

  /**
   * Configure the maintenance policy for this cluster.
   *
   * @generated from field: google.container.v1alpha1.MaintenancePolicy maintenance_policy = 23;
   */
  maintenancePolicy?: MaintenancePolicy;

  /**
   * Configuration for the PodSecurityPolicy feature.
   *
   * @generated from field: google.container.v1alpha1.PodSecurityPolicyConfig pod_security_policy_config = 25;
   */
  podSecurityPolicyConfig?: PodSecurityPolicyConfig;

  /**
   * [Output only] Server-defined URL for the resource.
   *
   * @generated from field: string self_link = 100;
   */
  selfLink = "";

  /**
   * [Output only] The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use location instead.
   *
   * @generated from field: string zone = 101;
   */
  zone = "";

  /**
   * [Output only] The IP address of this cluster's master endpoint.
   * The endpoint can be accessed from the internet at
   * `https://username:password@endpoint/`.
   *
   * See the `masterAuth` property of this resource for username and
   * password information.
   *
   * @generated from field: string endpoint = 102;
   */
  endpoint = "";

  /**
   * The initial Kubernetes version for this cluster.  Valid versions are those
   * found in validMasterVersions returned by getServerConfig.  The version can
   * be upgraded over time; such upgrades are reflected in
   * currentMasterVersion and currentNodeVersion.
   *
   * @generated from field: string initial_cluster_version = 103;
   */
  initialClusterVersion = "";

  /**
   * [Output only] The current software version of the master endpoint.
   *
   * @generated from field: string current_master_version = 104;
   */
  currentMasterVersion = "";

  /**
   * [Output only] The current version of the node software components.
   * If they are currently at multiple versions because they're in the process
   * of being upgraded, this reflects the minimum version of all nodes.
   *
   * @generated from field: string current_node_version = 105;
   */
  currentNodeVersion = "";

  /**
   * [Output only] The time the cluster was created, in
   * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   *
   * @generated from field: string create_time = 106;
   */
  createTime = "";

  /**
   * [Output only] The current status of this cluster.
   *
   * @generated from field: google.container.v1alpha1.Cluster.Status status = 107;
   */
  status = Cluster_Status.STATUS_UNSPECIFIED;

  /**
   * [Output only] Additional information about the current status of this
   * cluster, if available.
   *
   * @generated from field: string status_message = 108;
   */
  statusMessage = "";

  /**
   * [Output only] The size of the address space on each node for hosting
   * containers. This is provisioned from within the `container_ipv4_cidr`
   * range.
   *
   * @generated from field: int32 node_ipv4_cidr_size = 109;
   */
  nodeIpv4CidrSize = 0;

  /**
   * [Output only] The IP address range of the Kubernetes services in
   * this cluster, in
   * [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
   * notation (e.g. `1.2.3.4/29`). Service addresses are
   * typically put in the last `/16` from the container CIDR.
   *
   * @generated from field: string services_ipv4_cidr = 110;
   */
  servicesIpv4Cidr = "";

  /**
   * [Output only] The resource URLs of [instance
   * groups](/compute/docs/instance-groups/) associated with this
   * cluster.
   *
   * @generated from field: repeated string instance_group_urls = 111;
   */
  instanceGroupUrls: string[] = [];

  /**
   * [Output only] The number of nodes currently in the cluster.
   *
   * @generated from field: int32 current_node_count = 112;
   */
  currentNodeCount = 0;

  /**
   * [Output only] The time the cluster will be automatically
   * deleted in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   *
   * @generated from field: string expire_time = 113;
   */
  expireTime = "";

  /**
   * [Output only] The name of the Google Compute Engine
   * [zone](/compute/docs/regions-zones/regions-zones#available) or
   * [region](/compute/docs/regions-zones/regions-zones#available) in which
   * the cluster resides.
   *
   * @generated from field: string location = 114;
   */
  location = "";

  constructor(data?: PartialMessage<Cluster>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.Cluster";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "initial_node_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "node_config", kind: "message", T: NodeConfig },
    { no: 5, name: "master_auth", kind: "message", T: MasterAuth },
    { no: 6, name: "logging_service", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "monitoring_service", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "network", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "cluster_ipv4_cidr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "addons_config", kind: "message", T: AddonsConfig },
    { no: 11, name: "subnetwork", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 12, name: "node_pools", kind: "message", T: NodePool, repeated: true },
    { no: 13, name: "locations", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 14, name: "enable_kubernetes_alpha", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 19, name: "network_policy", kind: "message", T: NetworkPolicy },
    { no: 20, name: "ip_allocation_policy", kind: "message", T: IPAllocationPolicy },
    { no: 22, name: "master_authorized_networks_config", kind: "message", T: MasterAuthorizedNetworksConfig },
    { no: 23, name: "maintenance_policy", kind: "message", T: MaintenancePolicy },
    { no: 25, name: "pod_security_policy_config", kind: "message", T: PodSecurityPolicyConfig },
    { no: 100, name: "self_link", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 101, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 102, name: "endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 103, name: "initial_cluster_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 104, name: "current_master_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 105, name: "current_node_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 106, name: "create_time", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 107, name: "status", kind: "enum", T: proto3.getEnumType(Cluster_Status) },
    { no: 108, name: "status_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 109, name: "node_ipv4_cidr_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 110, name: "services_ipv4_cidr", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 111, name: "instance_group_urls", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 112, name: "current_node_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 113, name: "expire_time", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 114, name: "location", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Cluster {
    return new Cluster().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Cluster {
    return new Cluster().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Cluster {
    return new Cluster().fromJsonString(jsonString, options);
  }

  static equals(a: Cluster | PlainMessage<Cluster> | undefined, b: Cluster | PlainMessage<Cluster> | undefined): boolean {
    return proto3.util.equals(Cluster, a, b);
  }
}

/**
 * The current status of the cluster.
 *
 * @generated from enum google.container.v1alpha1.Cluster.Status
 */
export enum Cluster_Status {
  /**
   * Not set.
   *
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  STATUS_UNSPECIFIED = 0,

  /**
   * The PROVISIONING state indicates the cluster is being created.
   *
   * @generated from enum value: PROVISIONING = 1;
   */
  PROVISIONING = 1,

  /**
   * The RUNNING state indicates the cluster has been created and is fully
   * usable.
   *
   * @generated from enum value: RUNNING = 2;
   */
  RUNNING = 2,

  /**
   * The RECONCILING state indicates that some work is actively being done on
   * the cluster, such as upgrading the master or node software. Details can
   * be found in the `statusMessage` field.
   *
   * @generated from enum value: RECONCILING = 3;
   */
  RECONCILING = 3,

  /**
   * The STOPPING state indicates the cluster is being deleted.
   *
   * @generated from enum value: STOPPING = 4;
   */
  STOPPING = 4,

  /**
   * The ERROR state indicates the cluster may be unusable. Details
   * can be found in the `statusMessage` field.
   *
   * @generated from enum value: ERROR = 5;
   */
  ERROR = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(Cluster_Status)
proto3.util.setEnumType(Cluster_Status, "google.container.v1alpha1.Cluster.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "PROVISIONING" },
  { no: 2, name: "RUNNING" },
  { no: 3, name: "RECONCILING" },
  { no: 4, name: "STOPPING" },
  { no: 5, name: "ERROR" },
]);

/**
 * ClusterUpdate describes an update to the cluster. Exactly one update can
 * be applied to a cluster with each request, so at most one field can be
 * provided.
 *
 * @generated from message google.container.v1alpha1.ClusterUpdate
 */
export class ClusterUpdate extends Message<ClusterUpdate> {
  /**
   * The Kubernetes version to change the nodes to (typically an
   * upgrade). Use `-` to upgrade to the latest version supported by
   * the server.
   *
   * @generated from field: string desired_node_version = 4;
   */
  desiredNodeVersion = "";

  /**
   * The monitoring service the cluster should use to write metrics.
   * Currently available options:
   *
   * * "monitoring.googleapis.com" - the Google Cloud Monitoring service
   * * "none" - no metrics will be exported from the cluster
   *
   * @generated from field: string desired_monitoring_service = 5;
   */
  desiredMonitoringService = "";

  /**
   * Configurations for the various addons available to run in the cluster.
   *
   * @generated from field: google.container.v1alpha1.AddonsConfig desired_addons_config = 6;
   */
  desiredAddonsConfig?: AddonsConfig;

  /**
   * The node pool to be upgraded. This field is mandatory if
   * "desired_node_version", "desired_image_family" or
   * "desired_node_pool_autoscaling" is specified and there is more than one
   * node pool on the cluster.
   *
   * @generated from field: string desired_node_pool_id = 7;
   */
  desiredNodePoolId = "";

  /**
   * The desired image type for the node pool.
   * NOTE: Set the "desired_node_pool" field as well.
   *
   * @generated from field: string desired_image_type = 8;
   */
  desiredImageType = "";

  /**
   * Autoscaler configuration for the node pool specified in
   * desired_node_pool_id. If there is only one pool in the
   * cluster and desired_node_pool_id is not provided then
   * the change applies to that single node pool.
   *
   * @generated from field: google.container.v1alpha1.NodePoolAutoscaling desired_node_pool_autoscaling = 9;
   */
  desiredNodePoolAutoscaling?: NodePoolAutoscaling;

  /**
   * The desired list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located. Changing the locations a cluster is in will result
   * in nodes being either created or removed from the cluster, depending on
   * whether locations are being added or removed.
   *
   * This list must always include the cluster's primary zone.
   *
   * @generated from field: repeated string desired_locations = 10;
   */
  desiredLocations: string[] = [];

  /**
   * The desired configuration options for master authorized networks feature.
   *
   * @generated from field: google.container.v1alpha1.MasterAuthorizedNetworksConfig desired_master_authorized_networks_config = 12;
   */
  desiredMasterAuthorizedNetworksConfig?: MasterAuthorizedNetworksConfig;

  /**
   * The desired configuration options for the PodSecurityPolicy feature.
   *
   * @generated from field: google.container.v1alpha1.PodSecurityPolicyConfig desired_pod_security_policy_config = 14;
   */
  desiredPodSecurityPolicyConfig?: PodSecurityPolicyConfig;

  /**
   * The Kubernetes version to change the master to. The only valid value is the
   * latest supported version. Use "-" to have the server automatically select
   * the latest version.
   *
   * @generated from field: string desired_master_version = 100;
   */
  desiredMasterVersion = "";

  constructor(data?: PartialMessage<ClusterUpdate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.ClusterUpdate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 4, name: "desired_node_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "desired_monitoring_service", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "desired_addons_config", kind: "message", T: AddonsConfig },
    { no: 7, name: "desired_node_pool_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "desired_image_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "desired_node_pool_autoscaling", kind: "message", T: NodePoolAutoscaling },
    { no: 10, name: "desired_locations", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 12, name: "desired_master_authorized_networks_config", kind: "message", T: MasterAuthorizedNetworksConfig },
    { no: 14, name: "desired_pod_security_policy_config", kind: "message", T: PodSecurityPolicyConfig },
    { no: 100, name: "desired_master_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterUpdate {
    return new ClusterUpdate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterUpdate {
    return new ClusterUpdate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterUpdate {
    return new ClusterUpdate().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterUpdate | PlainMessage<ClusterUpdate> | undefined, b: ClusterUpdate | PlainMessage<ClusterUpdate> | undefined): boolean {
    return proto3.util.equals(ClusterUpdate, a, b);
  }
}

/**
 * This operation resource represents operations that may have happened or are
 * happening on the cluster. All fields are output only.
 *
 * @generated from message google.container.v1alpha1.Operation
 */
export class Operation extends Message<Operation> {
  /**
   * The server-assigned ID for the operation.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the operation
   * is taking place.
   * This field is deprecated, use location instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The operation type.
   *
   * @generated from field: google.container.v1alpha1.Operation.Type operation_type = 3;
   */
  operationType = Operation_Type.TYPE_UNSPECIFIED;

  /**
   * The current status of the operation.
   *
   * @generated from field: google.container.v1alpha1.Operation.Status status = 4;
   */
  status = Operation_Status.STATUS_UNSPECIFIED;

  /**
   * Detailed operation progress, if available.
   *
   * @generated from field: string detail = 8;
   */
  detail = "";

  /**
   * If an error has occurred, a textual description of the error.
   *
   * @generated from field: string status_message = 5;
   */
  statusMessage = "";

  /**
   * Server-defined URL for the resource.
   *
   * @generated from field: string self_link = 6;
   */
  selfLink = "";

  /**
   * Server-defined URL for the target of the operation.
   *
   * @generated from field: string target_link = 7;
   */
  targetLink = "";

  /**
   * [Output only] The name of the Google Compute Engine
   * [zone](/compute/docs/regions-zones/regions-zones#available) or
   * [region](/compute/docs/regions-zones/regions-zones#available) in which
   * the cluster resides.
   *
   * @generated from field: string location = 9;
   */
  location = "";

  /**
   * [Output only] The time the operation started, in
   * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   *
   * @generated from field: string start_time = 10;
   */
  startTime = "";

  /**
   * [Output only] The time the operation completed, in
   * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   *
   * @generated from field: string end_time = 11;
   */
  endTime = "";

  constructor(data?: PartialMessage<Operation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.Operation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "operation_type", kind: "enum", T: proto3.getEnumType(Operation_Type) },
    { no: 4, name: "status", kind: "enum", T: proto3.getEnumType(Operation_Status) },
    { no: 8, name: "detail", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "status_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "self_link", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "target_link", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "location", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "start_time", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 11, name: "end_time", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Operation {
    return new Operation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Operation {
    return new Operation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Operation {
    return new Operation().fromJsonString(jsonString, options);
  }

  static equals(a: Operation | PlainMessage<Operation> | undefined, b: Operation | PlainMessage<Operation> | undefined): boolean {
    return proto3.util.equals(Operation, a, b);
  }
}

/**
 * Current status of the operation.
 *
 * @generated from enum google.container.v1alpha1.Operation.Status
 */
export enum Operation_Status {
  /**
   * Not set.
   *
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  STATUS_UNSPECIFIED = 0,

  /**
   * The operation has been created.
   *
   * @generated from enum value: PENDING = 1;
   */
  PENDING = 1,

  /**
   * The operation is currently running.
   *
   * @generated from enum value: RUNNING = 2;
   */
  RUNNING = 2,

  /**
   * The operation is done, either cancelled or completed.
   *
   * @generated from enum value: DONE = 3;
   */
  DONE = 3,

  /**
   * The operation is aborting.
   *
   * @generated from enum value: ABORTING = 4;
   */
  ABORTING = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(Operation_Status)
proto3.util.setEnumType(Operation_Status, "google.container.v1alpha1.Operation.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "PENDING" },
  { no: 2, name: "RUNNING" },
  { no: 3, name: "DONE" },
  { no: 4, name: "ABORTING" },
]);

/**
 * Operation type.
 *
 * @generated from enum google.container.v1alpha1.Operation.Type
 */
export enum Operation_Type {
  /**
   * Not set.
   *
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * Cluster create.
   *
   * @generated from enum value: CREATE_CLUSTER = 1;
   */
  CREATE_CLUSTER = 1,

  /**
   * Cluster delete.
   *
   * @generated from enum value: DELETE_CLUSTER = 2;
   */
  DELETE_CLUSTER = 2,

  /**
   * A master upgrade.
   *
   * @generated from enum value: UPGRADE_MASTER = 3;
   */
  UPGRADE_MASTER = 3,

  /**
   * A node upgrade.
   *
   * @generated from enum value: UPGRADE_NODES = 4;
   */
  UPGRADE_NODES = 4,

  /**
   * Cluster repair.
   *
   * @generated from enum value: REPAIR_CLUSTER = 5;
   */
  REPAIR_CLUSTER = 5,

  /**
   * Cluster update.
   *
   * @generated from enum value: UPDATE_CLUSTER = 6;
   */
  UPDATE_CLUSTER = 6,

  /**
   * Node pool create.
   *
   * @generated from enum value: CREATE_NODE_POOL = 7;
   */
  CREATE_NODE_POOL = 7,

  /**
   * Node pool delete.
   *
   * @generated from enum value: DELETE_NODE_POOL = 8;
   */
  DELETE_NODE_POOL = 8,

  /**
   * Set node pool management.
   *
   * @generated from enum value: SET_NODE_POOL_MANAGEMENT = 9;
   */
  SET_NODE_POOL_MANAGEMENT = 9,

  /**
   * Automatic node pool repair.
   *
   * @generated from enum value: AUTO_REPAIR_NODES = 10;
   */
  AUTO_REPAIR_NODES = 10,

  /**
   * Automatic node upgrade.
   *
   * @generated from enum value: AUTO_UPGRADE_NODES = 11;
   */
  AUTO_UPGRADE_NODES = 11,

  /**
   * Set labels.
   *
   * @generated from enum value: SET_LABELS = 12;
   */
  SET_LABELS = 12,

  /**
   * Set/generate master auth materials
   *
   * @generated from enum value: SET_MASTER_AUTH = 13;
   */
  SET_MASTER_AUTH = 13,

  /**
   * Set node pool size.
   *
   * @generated from enum value: SET_NODE_POOL_SIZE = 14;
   */
  SET_NODE_POOL_SIZE = 14,

  /**
   * Updates network policy for a cluster.
   *
   * @generated from enum value: SET_NETWORK_POLICY = 15;
   */
  SET_NETWORK_POLICY = 15,

  /**
   * Set the maintenance policy.
   *
   * @generated from enum value: SET_MAINTENANCE_POLICY = 16;
   */
  SET_MAINTENANCE_POLICY = 16,
}
// Retrieve enum metadata with: proto3.getEnumType(Operation_Type)
proto3.util.setEnumType(Operation_Type, "google.container.v1alpha1.Operation.Type", [
  { no: 0, name: "TYPE_UNSPECIFIED" },
  { no: 1, name: "CREATE_CLUSTER" },
  { no: 2, name: "DELETE_CLUSTER" },
  { no: 3, name: "UPGRADE_MASTER" },
  { no: 4, name: "UPGRADE_NODES" },
  { no: 5, name: "REPAIR_CLUSTER" },
  { no: 6, name: "UPDATE_CLUSTER" },
  { no: 7, name: "CREATE_NODE_POOL" },
  { no: 8, name: "DELETE_NODE_POOL" },
  { no: 9, name: "SET_NODE_POOL_MANAGEMENT" },
  { no: 10, name: "AUTO_REPAIR_NODES" },
  { no: 11, name: "AUTO_UPGRADE_NODES" },
  { no: 12, name: "SET_LABELS" },
  { no: 13, name: "SET_MASTER_AUTH" },
  { no: 14, name: "SET_NODE_POOL_SIZE" },
  { no: 15, name: "SET_NETWORK_POLICY" },
  { no: 16, name: "SET_MAINTENANCE_POLICY" },
]);

/**
 * CreateClusterRequest creates a cluster.
 *
 * @generated from message google.container.v1alpha1.CreateClusterRequest
 */
export class CreateClusterRequest extends Message<CreateClusterRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use parent instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use parent instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * A [cluster
   * resource](/container-engine/reference/rest/v1alpha1/projects.zones.clusters)
   *
   * @generated from field: google.container.v1alpha1.Cluster cluster = 3;
   */
  cluster?: Cluster;

  /**
   * The parent (project and location) where the cluster will be created.
   * Specified in the format 'projects/*\/locations/*'.
   *
   * @generated from field: string parent = 5;
   */
  parent = "";

  constructor(data?: PartialMessage<CreateClusterRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.CreateClusterRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster", kind: "message", T: Cluster },
    { no: 5, name: "parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateClusterRequest {
    return new CreateClusterRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateClusterRequest {
    return new CreateClusterRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateClusterRequest {
    return new CreateClusterRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateClusterRequest | PlainMessage<CreateClusterRequest> | undefined, b: CreateClusterRequest | PlainMessage<CreateClusterRequest> | undefined): boolean {
    return proto3.util.equals(CreateClusterRequest, a, b);
  }
}

/**
 * GetClusterRequest gets the settings of a cluster.
 *
 * @generated from message google.container.v1alpha1.GetClusterRequest
 */
export class GetClusterRequest extends Message<GetClusterRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster to retrieve.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * The name (project, location, cluster) of the cluster to retrieve.
   * Specified in the format 'projects/*\/locations/*\/clusters/*'.
   *
   * @generated from field: string name = 5;
   */
  name = "";

  constructor(data?: PartialMessage<GetClusterRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.GetClusterRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetClusterRequest {
    return new GetClusterRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetClusterRequest {
    return new GetClusterRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetClusterRequest {
    return new GetClusterRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetClusterRequest | PlainMessage<GetClusterRequest> | undefined, b: GetClusterRequest | PlainMessage<GetClusterRequest> | undefined): boolean {
    return proto3.util.equals(GetClusterRequest, a, b);
  }
}

/**
 * UpdateClusterRequest updates the settings of a cluster.
 *
 * @generated from message google.container.v1alpha1.UpdateClusterRequest
 */
export class UpdateClusterRequest extends Message<UpdateClusterRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster to upgrade.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * A description of the update.
   *
   * @generated from field: google.container.v1alpha1.ClusterUpdate update = 4;
   */
  update?: ClusterUpdate;

  /**
   * The name (project, location, cluster) of the cluster to update.
   * Specified in the format 'projects/*\/locations/*\/clusters/*'.
   *
   * @generated from field: string name = 5;
   */
  name = "";

  constructor(data?: PartialMessage<UpdateClusterRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.UpdateClusterRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "update", kind: "message", T: ClusterUpdate },
    { no: 5, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateClusterRequest {
    return new UpdateClusterRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateClusterRequest {
    return new UpdateClusterRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateClusterRequest {
    return new UpdateClusterRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateClusterRequest | PlainMessage<UpdateClusterRequest> | undefined, b: UpdateClusterRequest | PlainMessage<UpdateClusterRequest> | undefined): boolean {
    return proto3.util.equals(UpdateClusterRequest, a, b);
  }
}

/**
 * SetNodePoolVersionRequest updates the version of a node pool.
 *
 * @generated from message google.container.v1alpha1.UpdateNodePoolRequest
 */
export class UpdateNodePoolRequest extends Message<UpdateNodePoolRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster to upgrade.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * The name of the node pool to upgrade.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string node_pool_id = 4;
   */
  nodePoolId = "";

  /**
   * The Kubernetes version to change the nodes to (typically an
   * upgrade). Use `-` to upgrade to the latest version supported by
   * the server.
   *
   * @generated from field: string node_version = 5;
   */
  nodeVersion = "";

  /**
   * The desired image type for the node pool.
   *
   * @generated from field: string image_type = 6;
   */
  imageType = "";

  /**
   * The name (project, location, cluster, node pool) of the node pool to update.
   * Specified in the format 'projects/*\/locations/*\/clusters/*\/nodePools/*'.
   *
   * @generated from field: string name = 8;
   */
  name = "";

  constructor(data?: PartialMessage<UpdateNodePoolRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.UpdateNodePoolRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "node_pool_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "node_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "image_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateNodePoolRequest {
    return new UpdateNodePoolRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateNodePoolRequest {
    return new UpdateNodePoolRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateNodePoolRequest {
    return new UpdateNodePoolRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateNodePoolRequest | PlainMessage<UpdateNodePoolRequest> | undefined, b: UpdateNodePoolRequest | PlainMessage<UpdateNodePoolRequest> | undefined): boolean {
    return proto3.util.equals(UpdateNodePoolRequest, a, b);
  }
}

/**
 * SetNodePoolAutoscalingRequest sets the autoscaler settings of a node pool.
 *
 * @generated from message google.container.v1alpha1.SetNodePoolAutoscalingRequest
 */
export class SetNodePoolAutoscalingRequest extends Message<SetNodePoolAutoscalingRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster to upgrade.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * The name of the node pool to upgrade.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string node_pool_id = 4;
   */
  nodePoolId = "";

  /**
   * Autoscaling configuration for the node pool.
   *
   * @generated from field: google.container.v1alpha1.NodePoolAutoscaling autoscaling = 5;
   */
  autoscaling?: NodePoolAutoscaling;

  /**
   * The name (project, location, cluster, node pool) of the node pool to set
   * autoscaler settings. Specified in the format
   * 'projects/*\/locations/*\/clusters/*\/nodePools/*'.
   *
   * @generated from field: string name = 6;
   */
  name = "";

  constructor(data?: PartialMessage<SetNodePoolAutoscalingRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.SetNodePoolAutoscalingRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "node_pool_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "autoscaling", kind: "message", T: NodePoolAutoscaling },
    { no: 6, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetNodePoolAutoscalingRequest {
    return new SetNodePoolAutoscalingRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetNodePoolAutoscalingRequest {
    return new SetNodePoolAutoscalingRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetNodePoolAutoscalingRequest {
    return new SetNodePoolAutoscalingRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetNodePoolAutoscalingRequest | PlainMessage<SetNodePoolAutoscalingRequest> | undefined, b: SetNodePoolAutoscalingRequest | PlainMessage<SetNodePoolAutoscalingRequest> | undefined): boolean {
    return proto3.util.equals(SetNodePoolAutoscalingRequest, a, b);
  }
}

/**
 * SetLoggingServiceRequest sets the logging service of a cluster.
 *
 * @generated from message google.container.v1alpha1.SetLoggingServiceRequest
 */
export class SetLoggingServiceRequest extends Message<SetLoggingServiceRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster to upgrade.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * The logging service the cluster should use to write metrics.
   * Currently available options:
   *
   * * "logging.googleapis.com" - the Google Cloud Logging service
   * * "none" - no metrics will be exported from the cluster
   *
   * @generated from field: string logging_service = 4;
   */
  loggingService = "";

  /**
   * The name (project, location, cluster) of the cluster to set logging.
   * Specified in the format 'projects/*\/locations/*\/clusters/*'.
   *
   * @generated from field: string name = 5;
   */
  name = "";

  constructor(data?: PartialMessage<SetLoggingServiceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.SetLoggingServiceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "logging_service", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetLoggingServiceRequest {
    return new SetLoggingServiceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetLoggingServiceRequest {
    return new SetLoggingServiceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetLoggingServiceRequest {
    return new SetLoggingServiceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetLoggingServiceRequest | PlainMessage<SetLoggingServiceRequest> | undefined, b: SetLoggingServiceRequest | PlainMessage<SetLoggingServiceRequest> | undefined): boolean {
    return proto3.util.equals(SetLoggingServiceRequest, a, b);
  }
}

/**
 * SetMonitoringServiceRequest sets the monitoring service of a cluster.
 *
 * @generated from message google.container.v1alpha1.SetMonitoringServiceRequest
 */
export class SetMonitoringServiceRequest extends Message<SetMonitoringServiceRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster to upgrade.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * The monitoring service the cluster should use to write metrics.
   * Currently available options:
   *
   * * "monitoring.googleapis.com" - the Google Cloud Monitoring service
   * * "none" - no metrics will be exported from the cluster
   *
   * @generated from field: string monitoring_service = 4;
   */
  monitoringService = "";

  /**
   * The name (project, location, cluster) of the cluster to set monitoring.
   * Specified in the format 'projects/*\/locations/*\/clusters/*'.
   *
   * @generated from field: string name = 6;
   */
  name = "";

  constructor(data?: PartialMessage<SetMonitoringServiceRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.SetMonitoringServiceRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "monitoring_service", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetMonitoringServiceRequest {
    return new SetMonitoringServiceRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetMonitoringServiceRequest {
    return new SetMonitoringServiceRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetMonitoringServiceRequest {
    return new SetMonitoringServiceRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetMonitoringServiceRequest | PlainMessage<SetMonitoringServiceRequest> | undefined, b: SetMonitoringServiceRequest | PlainMessage<SetMonitoringServiceRequest> | undefined): boolean {
    return proto3.util.equals(SetMonitoringServiceRequest, a, b);
  }
}

/**
 * SetAddonsRequest sets the addons associated with the cluster.
 *
 * @generated from message google.container.v1alpha1.SetAddonsConfigRequest
 */
export class SetAddonsConfigRequest extends Message<SetAddonsConfigRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster to upgrade.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * The desired configurations for the various addons available to run in the
   * cluster.
   *
   * @generated from field: google.container.v1alpha1.AddonsConfig addons_config = 4;
   */
  addonsConfig?: AddonsConfig;

  /**
   * The name (project, location, cluster) of the cluster to set addons.
   * Specified in the format 'projects/*\/locations/*\/clusters/*'.
   *
   * @generated from field: string name = 6;
   */
  name = "";

  constructor(data?: PartialMessage<SetAddonsConfigRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.SetAddonsConfigRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "addons_config", kind: "message", T: AddonsConfig },
    { no: 6, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetAddonsConfigRequest {
    return new SetAddonsConfigRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetAddonsConfigRequest {
    return new SetAddonsConfigRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetAddonsConfigRequest {
    return new SetAddonsConfigRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetAddonsConfigRequest | PlainMessage<SetAddonsConfigRequest> | undefined, b: SetAddonsConfigRequest | PlainMessage<SetAddonsConfigRequest> | undefined): boolean {
    return proto3.util.equals(SetAddonsConfigRequest, a, b);
  }
}

/**
 * SetLocationsRequest sets the locations of the cluster.
 *
 * @generated from message google.container.v1alpha1.SetLocationsRequest
 */
export class SetLocationsRequest extends Message<SetLocationsRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster to upgrade.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * The desired list of Google Compute Engine
   * [locations](/compute/docs/zones#available) in which the cluster's nodes
   * should be located. Changing the locations a cluster is in will result
   * in nodes being either created or removed from the cluster, depending on
   * whether locations are being added or removed.
   *
   * This list must always include the cluster's primary zone.
   *
   * @generated from field: repeated string locations = 4;
   */
  locations: string[] = [];

  /**
   * The name (project, location, cluster) of the cluster to set locations.
   * Specified in the format 'projects/*\/locations/*\/clusters/*'.
   *
   * @generated from field: string name = 6;
   */
  name = "";

  constructor(data?: PartialMessage<SetLocationsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.SetLocationsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "locations", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetLocationsRequest {
    return new SetLocationsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetLocationsRequest {
    return new SetLocationsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetLocationsRequest {
    return new SetLocationsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetLocationsRequest | PlainMessage<SetLocationsRequest> | undefined, b: SetLocationsRequest | PlainMessage<SetLocationsRequest> | undefined): boolean {
    return proto3.util.equals(SetLocationsRequest, a, b);
  }
}

/**
 * UpdateMasterRequest updates the master of the cluster.
 *
 * @generated from message google.container.v1alpha1.UpdateMasterRequest
 */
export class UpdateMasterRequest extends Message<UpdateMasterRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster to upgrade.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * The Kubernetes version to change the master to. The only valid value is the
   * latest supported version. Use "-" to have the server automatically select
   * the latest version.
   *
   * @generated from field: string master_version = 4;
   */
  masterVersion = "";

  /**
   * The name (project, location, cluster) of the cluster to update.
   * Specified in the format 'projects/*\/locations/*\/clusters/*'.
   *
   * @generated from field: string name = 7;
   */
  name = "";

  constructor(data?: PartialMessage<UpdateMasterRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.UpdateMasterRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "master_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateMasterRequest {
    return new UpdateMasterRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateMasterRequest {
    return new UpdateMasterRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateMasterRequest {
    return new UpdateMasterRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateMasterRequest | PlainMessage<UpdateMasterRequest> | undefined, b: UpdateMasterRequest | PlainMessage<UpdateMasterRequest> | undefined): boolean {
    return proto3.util.equals(UpdateMasterRequest, a, b);
  }
}

/**
 * SetMasterAuthRequest updates the admin password of a cluster.
 *
 * @generated from message google.container.v1alpha1.SetMasterAuthRequest
 */
export class SetMasterAuthRequest extends Message<SetMasterAuthRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster to upgrade.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * The exact form of action to be taken on the master auth.
   *
   * @generated from field: google.container.v1alpha1.SetMasterAuthRequest.Action action = 4;
   */
  action = SetMasterAuthRequest_Action.UNKNOWN;

  /**
   * A description of the update.
   *
   * @generated from field: google.container.v1alpha1.MasterAuth update = 5;
   */
  update?: MasterAuth;

  /**
   * The name (project, location, cluster) of the cluster to set auth.
   * Specified in the format 'projects/*\/locations/*\/clusters/*'.
   *
   * @generated from field: string name = 7;
   */
  name = "";

  constructor(data?: PartialMessage<SetMasterAuthRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.SetMasterAuthRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "action", kind: "enum", T: proto3.getEnumType(SetMasterAuthRequest_Action) },
    { no: 5, name: "update", kind: "message", T: MasterAuth },
    { no: 7, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetMasterAuthRequest {
    return new SetMasterAuthRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetMasterAuthRequest {
    return new SetMasterAuthRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetMasterAuthRequest {
    return new SetMasterAuthRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetMasterAuthRequest | PlainMessage<SetMasterAuthRequest> | undefined, b: SetMasterAuthRequest | PlainMessage<SetMasterAuthRequest> | undefined): boolean {
    return proto3.util.equals(SetMasterAuthRequest, a, b);
  }
}

/**
 * Operation type: what type update to perform.
 *
 * @generated from enum google.container.v1alpha1.SetMasterAuthRequest.Action
 */
export enum SetMasterAuthRequest_Action {
  /**
   * Operation is unknown and will error out.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Set the password to a user generated value.
   *
   * @generated from enum value: SET_PASSWORD = 1;
   */
  SET_PASSWORD = 1,

  /**
   * Generate a new password and set it to that.
   *
   * @generated from enum value: GENERATE_PASSWORD = 2;
   */
  GENERATE_PASSWORD = 2,

  /**
   * Set the username.  If an empty username is provided, basic authentication
   * is disabled for the cluster.  If a non-empty username is provided, basic
   * authentication is enabled, with either a provided password or a generated
   * one.
   *
   * @generated from enum value: SET_USERNAME = 3;
   */
  SET_USERNAME = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(SetMasterAuthRequest_Action)
proto3.util.setEnumType(SetMasterAuthRequest_Action, "google.container.v1alpha1.SetMasterAuthRequest.Action", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "SET_PASSWORD" },
  { no: 2, name: "GENERATE_PASSWORD" },
  { no: 3, name: "SET_USERNAME" },
]);

/**
 * DeleteClusterRequest deletes a cluster.
 *
 * @generated from message google.container.v1alpha1.DeleteClusterRequest
 */
export class DeleteClusterRequest extends Message<DeleteClusterRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster to delete.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * The name (project, location, cluster) of the cluster to delete.
   * Specified in the format 'projects/*\/locations/*\/clusters/*'.
   *
   * @generated from field: string name = 4;
   */
  name = "";

  constructor(data?: PartialMessage<DeleteClusterRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.DeleteClusterRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteClusterRequest {
    return new DeleteClusterRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteClusterRequest {
    return new DeleteClusterRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteClusterRequest {
    return new DeleteClusterRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteClusterRequest | PlainMessage<DeleteClusterRequest> | undefined, b: DeleteClusterRequest | PlainMessage<DeleteClusterRequest> | undefined): boolean {
    return proto3.util.equals(DeleteClusterRequest, a, b);
  }
}

/**
 * ListClustersRequest lists clusters.
 *
 * @generated from message google.container.v1alpha1.ListClustersRequest
 */
export class ListClustersRequest extends Message<ListClustersRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use parent instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides, or "-" for all zones.
   * This field is deprecated, use parent instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The parent (project and location) where the clusters will be listed.
   * Specified in the format 'projects/*\/locations/*'.
   * Location "-" matches all zones and all regions.
   *
   * @generated from field: string parent = 4;
   */
  parent = "";

  constructor(data?: PartialMessage<ListClustersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.ListClustersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListClustersRequest {
    return new ListClustersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListClustersRequest {
    return new ListClustersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListClustersRequest {
    return new ListClustersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListClustersRequest | PlainMessage<ListClustersRequest> | undefined, b: ListClustersRequest | PlainMessage<ListClustersRequest> | undefined): boolean {
    return proto3.util.equals(ListClustersRequest, a, b);
  }
}

/**
 * ListClustersResponse is the result of ListClustersRequest.
 *
 * @generated from message google.container.v1alpha1.ListClustersResponse
 */
export class ListClustersResponse extends Message<ListClustersResponse> {
  /**
   * A list of clusters in the project in the specified zone, or
   * across all ones.
   *
   * @generated from field: repeated google.container.v1alpha1.Cluster clusters = 1;
   */
  clusters: Cluster[] = [];

  /**
   * If any zones are listed here, the list of clusters returned
   * may be missing those zones.
   *
   * @generated from field: repeated string missing_zones = 2;
   */
  missingZones: string[] = [];

  constructor(data?: PartialMessage<ListClustersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.ListClustersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "clusters", kind: "message", T: Cluster, repeated: true },
    { no: 2, name: "missing_zones", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListClustersResponse {
    return new ListClustersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListClustersResponse {
    return new ListClustersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListClustersResponse {
    return new ListClustersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListClustersResponse | PlainMessage<ListClustersResponse> | undefined, b: ListClustersResponse | PlainMessage<ListClustersResponse> | undefined): boolean {
    return proto3.util.equals(ListClustersResponse, a, b);
  }
}

/**
 * GetOperationRequest gets a single operation.
 *
 * @generated from message google.container.v1alpha1.GetOperationRequest
 */
export class GetOperationRequest extends Message<GetOperationRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The server-assigned `name` of the operation.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string operation_id = 3;
   */
  operationId = "";

  /**
   * The name (project, location, operation id) of the operation to get.
   * Specified in the format 'projects/*\/locations/*\/operations/*'.
   *
   * @generated from field: string name = 5;
   */
  name = "";

  constructor(data?: PartialMessage<GetOperationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.GetOperationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "operation_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetOperationRequest {
    return new GetOperationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetOperationRequest {
    return new GetOperationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetOperationRequest {
    return new GetOperationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetOperationRequest | PlainMessage<GetOperationRequest> | undefined, b: GetOperationRequest | PlainMessage<GetOperationRequest> | undefined): boolean {
    return proto3.util.equals(GetOperationRequest, a, b);
  }
}

/**
 * ListOperationsRequest lists operations.
 *
 * @generated from message google.container.v1alpha1.ListOperationsRequest
 */
export class ListOperationsRequest extends Message<ListOperationsRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use parent instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine [zone](/compute/docs/zones#available)
   * to return operations for, or `-` for all zones.
   * This field is deprecated, use parent instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The parent (project and location) where the operations will be listed.
   * Specified in the format 'projects/*\/locations/*'.
   * Location "-" matches all zones and all regions.
   *
   * @generated from field: string parent = 4;
   */
  parent = "";

  constructor(data?: PartialMessage<ListOperationsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.ListOperationsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListOperationsRequest {
    return new ListOperationsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListOperationsRequest {
    return new ListOperationsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListOperationsRequest {
    return new ListOperationsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListOperationsRequest | PlainMessage<ListOperationsRequest> | undefined, b: ListOperationsRequest | PlainMessage<ListOperationsRequest> | undefined): boolean {
    return proto3.util.equals(ListOperationsRequest, a, b);
  }
}

/**
 * CancelOperationRequest cancels a single operation.
 *
 * @generated from message google.container.v1alpha1.CancelOperationRequest
 */
export class CancelOperationRequest extends Message<CancelOperationRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the operation resides.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The server-assigned `name` of the operation.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string operation_id = 3;
   */
  operationId = "";

  /**
   * The name (project, location, operation id) of the operation to cancel.
   * Specified in the format 'projects/*\/locations/*\/operations/*'.
   *
   * @generated from field: string name = 4;
   */
  name = "";

  constructor(data?: PartialMessage<CancelOperationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.CancelOperationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "operation_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CancelOperationRequest {
    return new CancelOperationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CancelOperationRequest {
    return new CancelOperationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CancelOperationRequest {
    return new CancelOperationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CancelOperationRequest | PlainMessage<CancelOperationRequest> | undefined, b: CancelOperationRequest | PlainMessage<CancelOperationRequest> | undefined): boolean {
    return proto3.util.equals(CancelOperationRequest, a, b);
  }
}

/**
 * ListOperationsResponse is the result of ListOperationsRequest.
 *
 * @generated from message google.container.v1alpha1.ListOperationsResponse
 */
export class ListOperationsResponse extends Message<ListOperationsResponse> {
  /**
   * A list of operations in the project in the specified zone.
   *
   * @generated from field: repeated google.container.v1alpha1.Operation operations = 1;
   */
  operations: Operation[] = [];

  /**
   * If any zones are listed here, the list of operations returned
   * may be missing the operations from those zones.
   *
   * @generated from field: repeated string missing_zones = 2;
   */
  missingZones: string[] = [];

  constructor(data?: PartialMessage<ListOperationsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.ListOperationsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "operations", kind: "message", T: Operation, repeated: true },
    { no: 2, name: "missing_zones", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListOperationsResponse {
    return new ListOperationsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListOperationsResponse {
    return new ListOperationsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListOperationsResponse {
    return new ListOperationsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListOperationsResponse | PlainMessage<ListOperationsResponse> | undefined, b: ListOperationsResponse | PlainMessage<ListOperationsResponse> | undefined): boolean {
    return proto3.util.equals(ListOperationsResponse, a, b);
  }
}

/**
 * Gets the current Container Engine service configuration.
 *
 * @generated from message google.container.v1alpha1.GetServerConfigRequest
 */
export class GetServerConfigRequest extends Message<GetServerConfigRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine [zone](/compute/docs/zones#available)
   * to return operations for.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name (project and location) of the server config to get
   * Specified in the format 'projects/*\/locations/*'.
   *
   * @generated from field: string name = 4;
   */
  name = "";

  constructor(data?: PartialMessage<GetServerConfigRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.GetServerConfigRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetServerConfigRequest {
    return new GetServerConfigRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetServerConfigRequest {
    return new GetServerConfigRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetServerConfigRequest {
    return new GetServerConfigRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetServerConfigRequest | PlainMessage<GetServerConfigRequest> | undefined, b: GetServerConfigRequest | PlainMessage<GetServerConfigRequest> | undefined): boolean {
    return proto3.util.equals(GetServerConfigRequest, a, b);
  }
}

/**
 * Container Engine service configuration.
 *
 * @generated from message google.container.v1alpha1.ServerConfig
 */
export class ServerConfig extends Message<ServerConfig> {
  /**
   * Version of Kubernetes the service deploys by default.
   *
   * @generated from field: string default_cluster_version = 1;
   */
  defaultClusterVersion = "";

  /**
   * List of valid node upgrade target versions.
   *
   * @generated from field: repeated string valid_node_versions = 3;
   */
  validNodeVersions: string[] = [];

  /**
   * Default image type.
   *
   * @generated from field: string default_image_type = 4;
   */
  defaultImageType = "";

  /**
   * List of valid image types.
   *
   * @generated from field: repeated string valid_image_types = 5;
   */
  validImageTypes: string[] = [];

  /**
   * List of valid master versions.
   *
   * @generated from field: repeated string valid_master_versions = 6;
   */
  validMasterVersions: string[] = [];

  constructor(data?: PartialMessage<ServerConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.ServerConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "default_cluster_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "valid_node_versions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "default_image_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "valid_image_types", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "valid_master_versions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ServerConfig {
    return new ServerConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ServerConfig {
    return new ServerConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ServerConfig {
    return new ServerConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ServerConfig | PlainMessage<ServerConfig> | undefined, b: ServerConfig | PlainMessage<ServerConfig> | undefined): boolean {
    return proto3.util.equals(ServerConfig, a, b);
  }
}

/**
 * CreateNodePoolRequest creates a node pool for a cluster.
 *
 * @generated from message google.container.v1alpha1.CreateNodePoolRequest
 */
export class CreateNodePoolRequest extends Message<CreateNodePoolRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://developers.google.com/console/help/new/#projectnumber).
   * This field is deprecated, use parent instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use parent instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster.
   * This field is deprecated, use parent instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * The node pool to create.
   *
   * @generated from field: google.container.v1alpha1.NodePool node_pool = 4;
   */
  nodePool?: NodePool;

  /**
   * The parent (project, location, cluster id) where the node pool will be created.
   * Specified in the format 'projects/*\/locations/*\/clusters/*\/nodePools/*'.
   *
   * @generated from field: string parent = 6;
   */
  parent = "";

  constructor(data?: PartialMessage<CreateNodePoolRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.CreateNodePoolRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "node_pool", kind: "message", T: NodePool },
    { no: 6, name: "parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateNodePoolRequest {
    return new CreateNodePoolRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateNodePoolRequest {
    return new CreateNodePoolRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateNodePoolRequest {
    return new CreateNodePoolRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateNodePoolRequest | PlainMessage<CreateNodePoolRequest> | undefined, b: CreateNodePoolRequest | PlainMessage<CreateNodePoolRequest> | undefined): boolean {
    return proto3.util.equals(CreateNodePoolRequest, a, b);
  }
}

/**
 * DeleteNodePoolRequest deletes a node pool for a cluster.
 *
 * @generated from message google.container.v1alpha1.DeleteNodePoolRequest
 */
export class DeleteNodePoolRequest extends Message<DeleteNodePoolRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://developers.google.com/console/help/new/#projectnumber).
   * This field is deprecated, use name instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * The name of the node pool to delete.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string node_pool_id = 4;
   */
  nodePoolId = "";

  /**
   * The name (project, location, cluster, node pool id) of the node pool to delete.
   * Specified in the format 'projects/*\/locations/*\/clusters/*\/nodePools/*'.
   *
   * @generated from field: string name = 6;
   */
  name = "";

  constructor(data?: PartialMessage<DeleteNodePoolRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.DeleteNodePoolRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "node_pool_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteNodePoolRequest {
    return new DeleteNodePoolRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteNodePoolRequest {
    return new DeleteNodePoolRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteNodePoolRequest {
    return new DeleteNodePoolRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteNodePoolRequest | PlainMessage<DeleteNodePoolRequest> | undefined, b: DeleteNodePoolRequest | PlainMessage<DeleteNodePoolRequest> | undefined): boolean {
    return proto3.util.equals(DeleteNodePoolRequest, a, b);
  }
}

/**
 * ListNodePoolsRequest lists the node pool(s) for a cluster.
 *
 * @generated from message google.container.v1alpha1.ListNodePoolsRequest
 */
export class ListNodePoolsRequest extends Message<ListNodePoolsRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://developers.google.com/console/help/new/#projectnumber).
   * This field is deprecated, use parent instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use parent instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster.
   * This field is deprecated, use parent instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * The parent (project, location, cluster id) where the node pools will be listed.
   * Specified in the format 'projects/*\/locations/*\/clusters/*'.
   *
   * @generated from field: string parent = 5;
   */
  parent = "";

  constructor(data?: PartialMessage<ListNodePoolsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.ListNodePoolsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListNodePoolsRequest {
    return new ListNodePoolsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListNodePoolsRequest {
    return new ListNodePoolsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListNodePoolsRequest {
    return new ListNodePoolsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListNodePoolsRequest | PlainMessage<ListNodePoolsRequest> | undefined, b: ListNodePoolsRequest | PlainMessage<ListNodePoolsRequest> | undefined): boolean {
    return proto3.util.equals(ListNodePoolsRequest, a, b);
  }
}

/**
 * GetNodePoolRequest retrieves a node pool for a cluster.
 *
 * @generated from message google.container.v1alpha1.GetNodePoolRequest
 */
export class GetNodePoolRequest extends Message<GetNodePoolRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://developers.google.com/console/help/new/#projectnumber).
   * This field is deprecated, use name instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * The name of the node pool.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string node_pool_id = 4;
   */
  nodePoolId = "";

  /**
   * The name (project, location, cluster, node pool id) of the node pool to get.
   * Specified in the format 'projects/*\/locations/*\/clusters/*\/nodePools/*'.
   *
   * @generated from field: string name = 6;
   */
  name = "";

  constructor(data?: PartialMessage<GetNodePoolRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.GetNodePoolRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "node_pool_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetNodePoolRequest {
    return new GetNodePoolRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetNodePoolRequest {
    return new GetNodePoolRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetNodePoolRequest {
    return new GetNodePoolRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetNodePoolRequest | PlainMessage<GetNodePoolRequest> | undefined, b: GetNodePoolRequest | PlainMessage<GetNodePoolRequest> | undefined): boolean {
    return proto3.util.equals(GetNodePoolRequest, a, b);
  }
}

/**
 * NodePool contains the name and configuration for a cluster's node pool.
 * Node pools are a set of nodes (i.e. VM's), with a common configuration and
 * specification, under the control of the cluster master. They may have a set
 * of Kubernetes labels applied to them, which may be used to reference them
 * during pod scheduling. They may also be resized up or down, to accommodate
 * the workload.
 *
 * @generated from message google.container.v1alpha1.NodePool
 */
export class NodePool extends Message<NodePool> {
  /**
   * The name of the node pool.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The node configuration of the pool.
   *
   * @generated from field: google.container.v1alpha1.NodeConfig config = 2;
   */
  config?: NodeConfig;

  /**
   * The initial node count for the pool. You must ensure that your
   * Compute Engine <a href="/compute/docs/resource-quotas">resource quota</a>
   * is sufficient for this number of instances. You must also have available
   * firewall and routes quota.
   *
   * @generated from field: int32 initial_node_count = 3;
   */
  initialNodeCount = 0;

  /**
   * Autoscaler configuration for this NodePool. Autoscaler is enabled
   * only if a valid configuration is present.
   *
   * @generated from field: google.container.v1alpha1.NodePoolAutoscaling autoscaling = 4;
   */
  autoscaling?: NodePoolAutoscaling;

  /**
   * NodeManagement configuration for this NodePool.
   *
   * @generated from field: google.container.v1alpha1.NodeManagement management = 5;
   */
  management?: NodeManagement;

  /**
   * [Output only] Server-defined URL for the resource.
   *
   * @generated from field: string self_link = 100;
   */
  selfLink = "";

  /**
   * [Output only] The version of the Kubernetes of this node.
   *
   * @generated from field: string version = 101;
   */
  version = "";

  /**
   * [Output only] The resource URLs of [instance
   * groups](/compute/docs/instance-groups/) associated with this
   * node pool.
   *
   * @generated from field: repeated string instance_group_urls = 102;
   */
  instanceGroupUrls: string[] = [];

  /**
   * [Output only] The status of the nodes in this pool instance.
   *
   * @generated from field: google.container.v1alpha1.NodePool.Status status = 103;
   */
  status = NodePool_Status.STATUS_UNSPECIFIED;

  /**
   * [Output only] Additional information about the current status of this
   * node pool instance, if available.
   *
   * @generated from field: string status_message = 104;
   */
  statusMessage = "";

  constructor(data?: PartialMessage<NodePool>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.NodePool";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "config", kind: "message", T: NodeConfig },
    { no: 3, name: "initial_node_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "autoscaling", kind: "message", T: NodePoolAutoscaling },
    { no: 5, name: "management", kind: "message", T: NodeManagement },
    { no: 100, name: "self_link", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 101, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 102, name: "instance_group_urls", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 103, name: "status", kind: "enum", T: proto3.getEnumType(NodePool_Status) },
    { no: 104, name: "status_message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NodePool {
    return new NodePool().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NodePool {
    return new NodePool().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NodePool {
    return new NodePool().fromJsonString(jsonString, options);
  }

  static equals(a: NodePool | PlainMessage<NodePool> | undefined, b: NodePool | PlainMessage<NodePool> | undefined): boolean {
    return proto3.util.equals(NodePool, a, b);
  }
}

/**
 * The current status of the node pool instance.
 *
 * @generated from enum google.container.v1alpha1.NodePool.Status
 */
export enum NodePool_Status {
  /**
   * Not set.
   *
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  STATUS_UNSPECIFIED = 0,

  /**
   * The PROVISIONING state indicates the node pool is being created.
   *
   * @generated from enum value: PROVISIONING = 1;
   */
  PROVISIONING = 1,

  /**
   * The RUNNING state indicates the node pool has been created
   * and is fully usable.
   *
   * @generated from enum value: RUNNING = 2;
   */
  RUNNING = 2,

  /**
   * The RUNNING_WITH_ERROR state indicates the node pool has been created
   * and is partially usable. Some error state has occurred and some
   * functionality may be impaired. Customer may need to reissue a request
   * or trigger a new update.
   *
   * @generated from enum value: RUNNING_WITH_ERROR = 3;
   */
  RUNNING_WITH_ERROR = 3,

  /**
   * The RECONCILING state indicates that some work is actively being done on
   * the node pool, such as upgrading node software. Details can
   * be found in the `statusMessage` field.
   *
   * @generated from enum value: RECONCILING = 4;
   */
  RECONCILING = 4,

  /**
   * The STOPPING state indicates the node pool is being deleted.
   *
   * @generated from enum value: STOPPING = 5;
   */
  STOPPING = 5,

  /**
   * The ERROR state indicates the node pool may be unusable. Details
   * can be found in the `statusMessage` field.
   *
   * @generated from enum value: ERROR = 6;
   */
  ERROR = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(NodePool_Status)
proto3.util.setEnumType(NodePool_Status, "google.container.v1alpha1.NodePool.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "PROVISIONING" },
  { no: 2, name: "RUNNING" },
  { no: 3, name: "RUNNING_WITH_ERROR" },
  { no: 4, name: "RECONCILING" },
  { no: 5, name: "STOPPING" },
  { no: 6, name: "ERROR" },
]);

/**
 * NodeManagement defines the set of node management services turned on for the
 * node pool.
 *
 * @generated from message google.container.v1alpha1.NodeManagement
 */
export class NodeManagement extends Message<NodeManagement> {
  /**
   * Whether the nodes will be automatically upgraded.
   *
   * @generated from field: bool auto_upgrade = 1;
   */
  autoUpgrade = false;

  /**
   * Whether the nodes will be automatically repaired.
   *
   * @generated from field: bool auto_repair = 2;
   */
  autoRepair = false;

  /**
   * Specifies the Auto Upgrade knobs for the node pool.
   *
   * @generated from field: google.container.v1alpha1.AutoUpgradeOptions upgrade_options = 10;
   */
  upgradeOptions?: AutoUpgradeOptions;

  constructor(data?: PartialMessage<NodeManagement>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.NodeManagement";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "auto_upgrade", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "auto_repair", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "upgrade_options", kind: "message", T: AutoUpgradeOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NodeManagement {
    return new NodeManagement().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NodeManagement {
    return new NodeManagement().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NodeManagement {
    return new NodeManagement().fromJsonString(jsonString, options);
  }

  static equals(a: NodeManagement | PlainMessage<NodeManagement> | undefined, b: NodeManagement | PlainMessage<NodeManagement> | undefined): boolean {
    return proto3.util.equals(NodeManagement, a, b);
  }
}

/**
 * AutoUpgradeOptions defines the set of options for the user to control how
 * the Auto Upgrades will proceed.
 *
 * @generated from message google.container.v1alpha1.AutoUpgradeOptions
 */
export class AutoUpgradeOptions extends Message<AutoUpgradeOptions> {
  /**
   * [Output only] This field is set when upgrades are about to commence
   * with the approximate start time for the upgrades, in
   * [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
   *
   * @generated from field: string auto_upgrade_start_time = 1;
   */
  autoUpgradeStartTime = "";

  /**
   * [Output only] This field is set when upgrades are about to commence
   * with the description of the upgrade.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  constructor(data?: PartialMessage<AutoUpgradeOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.AutoUpgradeOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "auto_upgrade_start_time", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AutoUpgradeOptions {
    return new AutoUpgradeOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AutoUpgradeOptions {
    return new AutoUpgradeOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AutoUpgradeOptions {
    return new AutoUpgradeOptions().fromJsonString(jsonString, options);
  }

  static equals(a: AutoUpgradeOptions | PlainMessage<AutoUpgradeOptions> | undefined, b: AutoUpgradeOptions | PlainMessage<AutoUpgradeOptions> | undefined): boolean {
    return proto3.util.equals(AutoUpgradeOptions, a, b);
  }
}

/**
 * MaintenancePolicy defines the maintenance policy to be used for the cluster.
 *
 * @generated from message google.container.v1alpha1.MaintenancePolicy
 */
export class MaintenancePolicy extends Message<MaintenancePolicy> {
  /**
   * Specifies the maintenance window in which maintenance may be performed.
   *
   * @generated from field: google.container.v1alpha1.MaintenanceWindow window = 1;
   */
  window?: MaintenanceWindow;

  constructor(data?: PartialMessage<MaintenancePolicy>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.MaintenancePolicy";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "window", kind: "message", T: MaintenanceWindow },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MaintenancePolicy {
    return new MaintenancePolicy().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MaintenancePolicy {
    return new MaintenancePolicy().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MaintenancePolicy {
    return new MaintenancePolicy().fromJsonString(jsonString, options);
  }

  static equals(a: MaintenancePolicy | PlainMessage<MaintenancePolicy> | undefined, b: MaintenancePolicy | PlainMessage<MaintenancePolicy> | undefined): boolean {
    return proto3.util.equals(MaintenancePolicy, a, b);
  }
}

/**
 * MaintenanceWindow defines the maintenance window to be used for the cluster.
 *
 * @generated from message google.container.v1alpha1.MaintenanceWindow
 */
export class MaintenanceWindow extends Message<MaintenanceWindow> {
  /**
   * Unimplemented, reserved for future use.
   * HourlyMaintenanceWindow hourly_maintenance_window = 1;
   *
   * @generated from oneof google.container.v1alpha1.MaintenanceWindow.policy
   */
  policy: {
    /**
     * DailyMaintenanceWindow specifies a daily maintenance operation window.
     *
     * @generated from field: google.container.v1alpha1.DailyMaintenanceWindow daily_maintenance_window = 2;
     */
    value: DailyMaintenanceWindow;
    case: "dailyMaintenanceWindow";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<MaintenanceWindow>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.MaintenanceWindow";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "daily_maintenance_window", kind: "message", T: DailyMaintenanceWindow, oneof: "policy" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MaintenanceWindow {
    return new MaintenanceWindow().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MaintenanceWindow {
    return new MaintenanceWindow().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MaintenanceWindow {
    return new MaintenanceWindow().fromJsonString(jsonString, options);
  }

  static equals(a: MaintenanceWindow | PlainMessage<MaintenanceWindow> | undefined, b: MaintenanceWindow | PlainMessage<MaintenanceWindow> | undefined): boolean {
    return proto3.util.equals(MaintenanceWindow, a, b);
  }
}

/**
 * Time window specified for daily maintenance operations.
 *
 * @generated from message google.container.v1alpha1.DailyMaintenanceWindow
 */
export class DailyMaintenanceWindow extends Message<DailyMaintenanceWindow> {
  /**
   * Time within the maintenance window to start the maintenance operations.
   * It must be in format "HH:MM, where HH : [00-23] and MM : [00-59] GMT.
   *
   * @generated from field: string start_time = 2;
   */
  startTime = "";

  /**
   * [Output only] Duration of the time window, automatically chosen to be
   * smallest possible in the given scenario.
   *
   * @generated from field: string duration = 3;
   */
  duration = "";

  constructor(data?: PartialMessage<DailyMaintenanceWindow>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.DailyMaintenanceWindow";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "start_time", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "duration", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DailyMaintenanceWindow {
    return new DailyMaintenanceWindow().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DailyMaintenanceWindow {
    return new DailyMaintenanceWindow().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DailyMaintenanceWindow {
    return new DailyMaintenanceWindow().fromJsonString(jsonString, options);
  }

  static equals(a: DailyMaintenanceWindow | PlainMessage<DailyMaintenanceWindow> | undefined, b: DailyMaintenanceWindow | PlainMessage<DailyMaintenanceWindow> | undefined): boolean {
    return proto3.util.equals(DailyMaintenanceWindow, a, b);
  }
}

/**
 * SetNodePoolManagementRequest sets the node management properties of a node
 * pool.
 *
 * @generated from message google.container.v1alpha1.SetNodePoolManagementRequest
 */
export class SetNodePoolManagementRequest extends Message<SetNodePoolManagementRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster to update.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * The name of the node pool to update.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string node_pool_id = 4;
   */
  nodePoolId = "";

  /**
   * NodeManagement configuration for the node pool.
   *
   * @generated from field: google.container.v1alpha1.NodeManagement management = 5;
   */
  management?: NodeManagement;

  /**
   * The name (project, location, cluster, node pool id) of the node pool to set
   * management properties. Specified in the format
   * 'projects/*\/locations/*\/clusters/*\/nodePools/*'.
   *
   * @generated from field: string name = 7;
   */
  name = "";

  constructor(data?: PartialMessage<SetNodePoolManagementRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.SetNodePoolManagementRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "node_pool_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "management", kind: "message", T: NodeManagement },
    { no: 7, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetNodePoolManagementRequest {
    return new SetNodePoolManagementRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetNodePoolManagementRequest {
    return new SetNodePoolManagementRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetNodePoolManagementRequest {
    return new SetNodePoolManagementRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetNodePoolManagementRequest | PlainMessage<SetNodePoolManagementRequest> | undefined, b: SetNodePoolManagementRequest | PlainMessage<SetNodePoolManagementRequest> | undefined): boolean {
    return proto3.util.equals(SetNodePoolManagementRequest, a, b);
  }
}

/**
 * SetNodePoolSizeRequest sets the size a node
 * pool.
 *
 * @generated from message google.container.v1alpha1.SetNodePoolSizeRequest
 */
export class SetNodePoolSizeRequest extends Message<SetNodePoolSizeRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster to update.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * The name of the node pool to update.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string node_pool_id = 4;
   */
  nodePoolId = "";

  /**
   * The desired node count for the pool.
   *
   * @generated from field: int32 node_count = 5;
   */
  nodeCount = 0;

  /**
   * The name (project, location, cluster, node pool id) of the node pool to set
   * size.
   * Specified in the format 'projects/*\/locations/*\/clusters/*\/nodePools/*'.
   *
   * @generated from field: string name = 7;
   */
  name = "";

  constructor(data?: PartialMessage<SetNodePoolSizeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.SetNodePoolSizeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "node_pool_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "node_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 7, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetNodePoolSizeRequest {
    return new SetNodePoolSizeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetNodePoolSizeRequest {
    return new SetNodePoolSizeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetNodePoolSizeRequest {
    return new SetNodePoolSizeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetNodePoolSizeRequest | PlainMessage<SetNodePoolSizeRequest> | undefined, b: SetNodePoolSizeRequest | PlainMessage<SetNodePoolSizeRequest> | undefined): boolean {
    return proto3.util.equals(SetNodePoolSizeRequest, a, b);
  }
}

/**
 * RollbackNodePoolUpgradeRequest rollbacks the previously Aborted or Failed
 * NodePool upgrade. This will be an no-op if the last upgrade successfully
 * completed.
 *
 * @generated from message google.container.v1alpha1.RollbackNodePoolUpgradeRequest
 */
export class RollbackNodePoolUpgradeRequest extends Message<RollbackNodePoolUpgradeRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster to rollback.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * The name of the node pool to rollback.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string node_pool_id = 4;
   */
  nodePoolId = "";

  /**
   * The name (project, location, cluster, node pool id) of the node poll to
   * rollback upgrade.
   * Specified in the format 'projects/*\/locations/*\/clusters/*\/nodePools/*'.
   *
   * @generated from field: string name = 6;
   */
  name = "";

  constructor(data?: PartialMessage<RollbackNodePoolUpgradeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.RollbackNodePoolUpgradeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "node_pool_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RollbackNodePoolUpgradeRequest {
    return new RollbackNodePoolUpgradeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RollbackNodePoolUpgradeRequest {
    return new RollbackNodePoolUpgradeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RollbackNodePoolUpgradeRequest {
    return new RollbackNodePoolUpgradeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RollbackNodePoolUpgradeRequest | PlainMessage<RollbackNodePoolUpgradeRequest> | undefined, b: RollbackNodePoolUpgradeRequest | PlainMessage<RollbackNodePoolUpgradeRequest> | undefined): boolean {
    return proto3.util.equals(RollbackNodePoolUpgradeRequest, a, b);
  }
}

/**
 * ListNodePoolsResponse is the result of ListNodePoolsRequest.
 *
 * @generated from message google.container.v1alpha1.ListNodePoolsResponse
 */
export class ListNodePoolsResponse extends Message<ListNodePoolsResponse> {
  /**
   * A list of node pools for a cluster.
   *
   * @generated from field: repeated google.container.v1alpha1.NodePool node_pools = 1;
   */
  nodePools: NodePool[] = [];

  constructor(data?: PartialMessage<ListNodePoolsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.ListNodePoolsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "node_pools", kind: "message", T: NodePool, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListNodePoolsResponse {
    return new ListNodePoolsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListNodePoolsResponse {
    return new ListNodePoolsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListNodePoolsResponse {
    return new ListNodePoolsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListNodePoolsResponse | PlainMessage<ListNodePoolsResponse> | undefined, b: ListNodePoolsResponse | PlainMessage<ListNodePoolsResponse> | undefined): boolean {
    return proto3.util.equals(ListNodePoolsResponse, a, b);
  }
}

/**
 * NodePoolAutoscaling contains information required by cluster autoscaler to
 * adjust the size of the node pool to the current cluster usage.
 *
 * @generated from message google.container.v1alpha1.NodePoolAutoscaling
 */
export class NodePoolAutoscaling extends Message<NodePoolAutoscaling> {
  /**
   * Is autoscaling enabled for this node pool.
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * Minimum number of nodes in the NodePool. Must be >= 1 and <=
   * max_node_count.
   *
   * @generated from field: int32 min_node_count = 2;
   */
  minNodeCount = 0;

  /**
   * Maximum number of nodes in the NodePool. Must be >= min_node_count. There
   * has to enough quota to scale up the cluster.
   *
   * @generated from field: int32 max_node_count = 3;
   */
  maxNodeCount = 0;

  constructor(data?: PartialMessage<NodePoolAutoscaling>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.NodePoolAutoscaling";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "min_node_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "max_node_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NodePoolAutoscaling {
    return new NodePoolAutoscaling().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NodePoolAutoscaling {
    return new NodePoolAutoscaling().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NodePoolAutoscaling {
    return new NodePoolAutoscaling().fromJsonString(jsonString, options);
  }

  static equals(a: NodePoolAutoscaling | PlainMessage<NodePoolAutoscaling> | undefined, b: NodePoolAutoscaling | PlainMessage<NodePoolAutoscaling> | undefined): boolean {
    return proto3.util.equals(NodePoolAutoscaling, a, b);
  }
}

/**
 * SetLabelsRequest sets the Google Cloud Platform labels on a Google Container
 * Engine cluster, which will in turn set them for Google Compute Engine
 * resources used by that cluster
 *
 * @generated from message google.container.v1alpha1.SetLabelsRequest
 */
export class SetLabelsRequest extends Message<SetLabelsRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://developers.google.com/console/help/new/#projectnumber).
   * This field is deprecated, use name instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * The labels to set for that cluster.
   *
   * @generated from field: map<string, string> resource_labels = 4;
   */
  resourceLabels: { [key: string]: string } = {};

  /**
   * The fingerprint of the previous set of labels for this resource,
   * used to detect conflicts. The fingerprint is initially generated by
   * Container Engine and changes after every request to modify or update
   * labels. You must always provide an up-to-date fingerprint hash when
   * updating or changing labels. Make a <code>get()</code> request to the
   * resource to get the latest fingerprint.
   *
   * @generated from field: string label_fingerprint = 5;
   */
  labelFingerprint = "";

  /**
   * The name (project, location, cluster id) of the cluster to set labels.
   * Specified in the format 'projects/*\/locations/*\/clusters/*'.
   *
   * @generated from field: string name = 7;
   */
  name = "";

  constructor(data?: PartialMessage<SetLabelsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.SetLabelsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "resource_labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 5, name: "label_fingerprint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetLabelsRequest {
    return new SetLabelsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetLabelsRequest {
    return new SetLabelsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetLabelsRequest {
    return new SetLabelsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetLabelsRequest | PlainMessage<SetLabelsRequest> | undefined, b: SetLabelsRequest | PlainMessage<SetLabelsRequest> | undefined): boolean {
    return proto3.util.equals(SetLabelsRequest, a, b);
  }
}

/**
 * SetLegacyAbacRequest enables or disables the ABAC authorization mechanism for
 * a cluster.
 *
 * @generated from message google.container.v1alpha1.SetLegacyAbacRequest
 */
export class SetLegacyAbacRequest extends Message<SetLegacyAbacRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   * This field is deprecated, use name instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster to update.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * Whether ABAC authorization will be enabled in the cluster.
   *
   * @generated from field: bool enabled = 4;
   */
  enabled = false;

  /**
   * The name (project, location, cluster id) of the cluster to set legacy abac.
   * Specified in the format 'projects/*\/locations/*\/clusters/*'.
   *
   * @generated from field: string name = 6;
   */
  name = "";

  constructor(data?: PartialMessage<SetLegacyAbacRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.SetLegacyAbacRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetLegacyAbacRequest {
    return new SetLegacyAbacRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetLegacyAbacRequest {
    return new SetLegacyAbacRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetLegacyAbacRequest {
    return new SetLegacyAbacRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetLegacyAbacRequest | PlainMessage<SetLegacyAbacRequest> | undefined, b: SetLegacyAbacRequest | PlainMessage<SetLegacyAbacRequest> | undefined): boolean {
    return proto3.util.equals(SetLegacyAbacRequest, a, b);
  }
}

/**
 * StartIPRotationRequest creates a new IP for the cluster and then performs
 * a node upgrade on each node pool to point to the new IP.
 *
 * @generated from message google.container.v1alpha1.StartIPRotationRequest
 */
export class StartIPRotationRequest extends Message<StartIPRotationRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://developers.google.com/console/help/new/#projectnumber).
   * This field is deprecated, use name instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * The name (project, location, cluster id) of the cluster to start IP rotation.
   * Specified in the format 'projects/*\/locations/*\/clusters/*'.
   *
   * @generated from field: string name = 6;
   */
  name = "";

  constructor(data?: PartialMessage<StartIPRotationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.StartIPRotationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StartIPRotationRequest {
    return new StartIPRotationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StartIPRotationRequest {
    return new StartIPRotationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StartIPRotationRequest {
    return new StartIPRotationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StartIPRotationRequest | PlainMessage<StartIPRotationRequest> | undefined, b: StartIPRotationRequest | PlainMessage<StartIPRotationRequest> | undefined): boolean {
    return proto3.util.equals(StartIPRotationRequest, a, b);
  }
}

/**
 * CompleteIPRotationRequest moves the cluster master back into single-IP mode.
 *
 * @generated from message google.container.v1alpha1.CompleteIPRotationRequest
 */
export class CompleteIPRotationRequest extends Message<CompleteIPRotationRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://developers.google.com/console/help/new/#projectnumber).
   * This field is deprecated, use name instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * The name (project, location, cluster id) of the cluster to complete IP rotation.
   * Specified in the format 'projects/*\/locations/*\/clusters/*'.
   *
   * @generated from field: string name = 7;
   */
  name = "";

  constructor(data?: PartialMessage<CompleteIPRotationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.CompleteIPRotationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CompleteIPRotationRequest {
    return new CompleteIPRotationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CompleteIPRotationRequest {
    return new CompleteIPRotationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CompleteIPRotationRequest {
    return new CompleteIPRotationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CompleteIPRotationRequest | PlainMessage<CompleteIPRotationRequest> | undefined, b: CompleteIPRotationRequest | PlainMessage<CompleteIPRotationRequest> | undefined): boolean {
    return proto3.util.equals(CompleteIPRotationRequest, a, b);
  }
}

/**
 * AcceleratorConfig represents a Hardware Accelerator request.
 *
 * @generated from message google.container.v1alpha1.AcceleratorConfig
 */
export class AcceleratorConfig extends Message<AcceleratorConfig> {
  /**
   * The number of the accelerator cards exposed to an instance.
   *
   * @generated from field: int64 accelerator_count = 1;
   */
  acceleratorCount = protoInt64.zero;

  /**
   * The accelerator type resource name. List of supported accelerators
   * [here](/compute/docs/gpus/#Introduction)
   *
   * @generated from field: string accelerator_type = 2;
   */
  acceleratorType = "";

  constructor(data?: PartialMessage<AcceleratorConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.AcceleratorConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "accelerator_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "accelerator_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AcceleratorConfig {
    return new AcceleratorConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AcceleratorConfig {
    return new AcceleratorConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AcceleratorConfig {
    return new AcceleratorConfig().fromJsonString(jsonString, options);
  }

  static equals(a: AcceleratorConfig | PlainMessage<AcceleratorConfig> | undefined, b: AcceleratorConfig | PlainMessage<AcceleratorConfig> | undefined): boolean {
    return proto3.util.equals(AcceleratorConfig, a, b);
  }
}

/**
 * SetNetworkPolicyRequest enables/disables network policy for a cluster.
 *
 * @generated from message google.container.v1alpha1.SetNetworkPolicyRequest
 */
export class SetNetworkPolicyRequest extends Message<SetNetworkPolicyRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://developers.google.com/console/help/new/#projectnumber).
   * This field is deprecated, use name instead.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster.
   * This field is deprecated, use name instead.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * Configuration options for the NetworkPolicy feature.
   *
   * @generated from field: google.container.v1alpha1.NetworkPolicy network_policy = 4;
   */
  networkPolicy?: NetworkPolicy;

  /**
   * The name (project, location, cluster id) of the cluster to set networking
   * policy.
   * Specified in the format 'projects/*\/locations/*\/clusters/*'.
   *
   * @generated from field: string name = 6;
   */
  name = "";

  constructor(data?: PartialMessage<SetNetworkPolicyRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.SetNetworkPolicyRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "network_policy", kind: "message", T: NetworkPolicy },
    { no: 6, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetNetworkPolicyRequest {
    return new SetNetworkPolicyRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetNetworkPolicyRequest {
    return new SetNetworkPolicyRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetNetworkPolicyRequest {
    return new SetNetworkPolicyRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetNetworkPolicyRequest | PlainMessage<SetNetworkPolicyRequest> | undefined, b: SetNetworkPolicyRequest | PlainMessage<SetNetworkPolicyRequest> | undefined): boolean {
    return proto3.util.equals(SetNetworkPolicyRequest, a, b);
  }
}

/**
 * SetMaintenancePolicyRequest sets the maintenance policy for a cluster.
 *
 * @generated from message google.container.v1alpha1.SetMaintenancePolicyRequest
 */
export class SetMaintenancePolicyRequest extends Message<SetMaintenancePolicyRequest> {
  /**
   * The Google Developers Console [project ID or project
   * number](https://support.google.com/cloud/answer/6158840).
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The name of the Google Compute Engine
   * [zone](/compute/docs/zones#available) in which the cluster
   * resides.
   *
   * @generated from field: string zone = 2;
   */
  zone = "";

  /**
   * The name of the cluster to update.
   *
   * @generated from field: string cluster_id = 3;
   */
  clusterId = "";

  /**
   * The maintenance policy to be set for the cluster. An empty field
   * clears the existing maintenance policy.
   *
   * @generated from field: google.container.v1alpha1.MaintenancePolicy maintenance_policy = 4;
   */
  maintenancePolicy?: MaintenancePolicy;

  /**
   * The name (project, location, cluster id) of the cluster to set maintenance
   * policy.
   * Specified in the format 'projects/*\/locations/*\/clusters/*'.
   *
   * @generated from field: string name = 5;
   */
  name = "";

  constructor(data?: PartialMessage<SetMaintenancePolicyRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.container.v1alpha1.SetMaintenancePolicyRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "zone", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "maintenance_policy", kind: "message", T: MaintenancePolicy },
    { no: 5, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SetMaintenancePolicyRequest {
    return new SetMaintenancePolicyRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SetMaintenancePolicyRequest {
    return new SetMaintenancePolicyRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SetMaintenancePolicyRequest {
    return new SetMaintenancePolicyRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SetMaintenancePolicyRequest | PlainMessage<SetMaintenancePolicyRequest> | undefined, b: SetMaintenancePolicyRequest | PlainMessage<SetMaintenancePolicyRequest> | undefined): boolean {
    return proto3.util.equals(SetMaintenancePolicyRequest, a, b);
  }
}

