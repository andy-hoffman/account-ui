// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/cloud/language/v1beta1/language_service.proto (package google.cloud.language.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * Represents the text encoding that the caller uses to process the output.
 * Providing an `EncodingType` is recommended because the API provides the
 * beginning offsets for various outputs, such as tokens and mentions, and
 * languages that natively use different text encodings may access offsets
 * differently.
 *
 * @generated from enum google.cloud.language.v1beta1.EncodingType
 */
export enum EncodingType {
  /**
   * If `EncodingType` is not specified, encoding-dependent information (such as
   * `begin_offset`) will be set at `-1`.
   *
   * @generated from enum value: NONE = 0;
   */
  NONE = 0,

  /**
   * Encoding-dependent information (such as `begin_offset`) is calculated based
   * on the UTF-8 encoding of the input. C++ and Go are examples of languages
   * that use this encoding natively.
   *
   * @generated from enum value: UTF8 = 1;
   */
  UTF8 = 1,

  /**
   * Encoding-dependent information (such as `begin_offset`) is calculated based
   * on the UTF-16 encoding of the input. Java and Javascript are examples of
   * languages that use this encoding natively.
   *
   * @generated from enum value: UTF16 = 2;
   */
  UTF16 = 2,

  /**
   * Encoding-dependent information (such as `begin_offset`) is calculated based
   * on the UTF-32 encoding of the input. Python is an example of a language
   * that uses this encoding natively.
   *
   * @generated from enum value: UTF32 = 3;
   */
  UTF32 = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(EncodingType)
proto3.util.setEnumType(EncodingType, "google.cloud.language.v1beta1.EncodingType", [
  { no: 0, name: "NONE" },
  { no: 1, name: "UTF8" },
  { no: 2, name: "UTF16" },
  { no: 3, name: "UTF32" },
]);

/**
 * ################################################################ #
 *
 * Represents the input to API methods.
 *
 * @generated from message google.cloud.language.v1beta1.Document
 */
export class Document extends Message<Document> {
  /**
   * Required. If the type is not set or is `TYPE_UNSPECIFIED`,
   * returns an `INVALID_ARGUMENT` error.
   *
   * @generated from field: google.cloud.language.v1beta1.Document.Type type = 1;
   */
  type = Document_Type.TYPE_UNSPECIFIED;

  /**
   * The source of the document: a string containing the content or a
   * Google Cloud Storage URI.
   *
   * @generated from oneof google.cloud.language.v1beta1.Document.source
   */
  source: {
    /**
     * The content of the input in string format.
     *
     * @generated from field: string content = 2;
     */
    value: string;
    case: "content";
  } | {
    /**
     * The Google Cloud Storage URI where the file content is located.
     * This URI must be of the form: gs://bucket_name/object_name. For more
     * details, see https://cloud.google.com/storage/docs/reference-uris.
     * NOTE: Cloud Storage object versioning is not supported.
     *
     * @generated from field: string gcs_content_uri = 3;
     */
    value: string;
    case: "gcsContentUri";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The language of the document (if not specified, the language is
   * automatically detected). Both ISO and BCP-47 language codes are
   * accepted.<br>
   * [Language Support](https://cloud.google.com/natural-language/docs/languages)
   * lists currently supported languages for each API method.
   * If the language (either specified by the caller or automatically detected)
   * is not supported by the called API method, an `INVALID_ARGUMENT` error
   * is returned.
   *
   * @generated from field: string language = 4;
   */
  language = "";

  constructor(data?: PartialMessage<Document>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.language.v1beta1.Document";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(Document_Type) },
    { no: 2, name: "content", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "source" },
    { no: 3, name: "gcs_content_uri", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "source" },
    { no: 4, name: "language", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Document {
    return new Document().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Document {
    return new Document().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Document {
    return new Document().fromJsonString(jsonString, options);
  }

  static equals(a: Document | PlainMessage<Document> | undefined, b: Document | PlainMessage<Document> | undefined): boolean {
    return proto3.util.equals(Document, a, b);
  }
}

/**
 * The document types enum.
 *
 * @generated from enum google.cloud.language.v1beta1.Document.Type
 */
export enum Document_Type {
  /**
   * The content type is not specified.
   *
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * Plain text
   *
   * @generated from enum value: PLAIN_TEXT = 1;
   */
  PLAIN_TEXT = 1,

  /**
   * HTML
   *
   * @generated from enum value: HTML = 2;
   */
  HTML = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(Document_Type)
proto3.util.setEnumType(Document_Type, "google.cloud.language.v1beta1.Document.Type", [
  { no: 0, name: "TYPE_UNSPECIFIED" },
  { no: 1, name: "PLAIN_TEXT" },
  { no: 2, name: "HTML" },
]);

/**
 * Represents a sentence in the input document.
 *
 * @generated from message google.cloud.language.v1beta1.Sentence
 */
export class Sentence extends Message<Sentence> {
  /**
   * The sentence text.
   *
   * @generated from field: google.cloud.language.v1beta1.TextSpan text = 1;
   */
  text?: TextSpan;

  /**
   * For calls to [AnalyzeSentiment][] or if
   * [AnnotateTextRequest.Features.extract_document_sentiment][google.cloud.language.v1beta1.AnnotateTextRequest.Features.extract_document_sentiment] is set to
   * true, this field will contain the sentiment for the sentence.
   *
   * @generated from field: google.cloud.language.v1beta1.Sentiment sentiment = 2;
   */
  sentiment?: Sentiment;

  constructor(data?: PartialMessage<Sentence>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.language.v1beta1.Sentence";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "text", kind: "message", T: TextSpan },
    { no: 2, name: "sentiment", kind: "message", T: Sentiment },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Sentence {
    return new Sentence().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Sentence {
    return new Sentence().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Sentence {
    return new Sentence().fromJsonString(jsonString, options);
  }

  static equals(a: Sentence | PlainMessage<Sentence> | undefined, b: Sentence | PlainMessage<Sentence> | undefined): boolean {
    return proto3.util.equals(Sentence, a, b);
  }
}

/**
 * Represents a phrase in the text that is a known entity, such as
 * a person, an organization, or location. The API associates information, such
 * as salience and mentions, with entities.
 *
 * @generated from message google.cloud.language.v1beta1.Entity
 */
export class Entity extends Message<Entity> {
  /**
   * The representative name for the entity.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The entity type.
   *
   * @generated from field: google.cloud.language.v1beta1.Entity.Type type = 2;
   */
  type = Entity_Type.UNKNOWN;

  /**
   * Metadata associated with the entity.
   *
   * Currently, Wikipedia URLs and Knowledge Graph MIDs are provided, if
   * available. The associated keys are "wikipedia_url" and "mid", respectively.
   *
   * @generated from field: map<string, string> metadata = 3;
   */
  metadata: { [key: string]: string } = {};

  /**
   * The salience score associated with the entity in the [0, 1.0] range.
   *
   * The salience score for an entity provides information about the
   * importance or centrality of that entity to the entire document text.
   * Scores closer to 0 are less salient, while scores closer to 1.0 are highly
   * salient.
   *
   * @generated from field: float salience = 4;
   */
  salience = 0;

  /**
   * The mentions of this entity in the input document. The API currently
   * supports proper noun mentions.
   *
   * @generated from field: repeated google.cloud.language.v1beta1.EntityMention mentions = 5;
   */
  mentions: EntityMention[] = [];

  constructor(data?: PartialMessage<Entity>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.language.v1beta1.Entity";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(Entity_Type) },
    { no: 3, name: "metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 4, name: "salience", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 5, name: "mentions", kind: "message", T: EntityMention, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Entity {
    return new Entity().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Entity {
    return new Entity().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Entity {
    return new Entity().fromJsonString(jsonString, options);
  }

  static equals(a: Entity | PlainMessage<Entity> | undefined, b: Entity | PlainMessage<Entity> | undefined): boolean {
    return proto3.util.equals(Entity, a, b);
  }
}

/**
 * The type of the entity.
 *
 * @generated from enum google.cloud.language.v1beta1.Entity.Type
 */
export enum Entity_Type {
  /**
   * Unknown
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Person
   *
   * @generated from enum value: PERSON = 1;
   */
  PERSON = 1,

  /**
   * Location
   *
   * @generated from enum value: LOCATION = 2;
   */
  LOCATION = 2,

  /**
   * Organization
   *
   * @generated from enum value: ORGANIZATION = 3;
   */
  ORGANIZATION = 3,

  /**
   * Event
   *
   * @generated from enum value: EVENT = 4;
   */
  EVENT = 4,

  /**
   * Work of art
   *
   * @generated from enum value: WORK_OF_ART = 5;
   */
  WORK_OF_ART = 5,

  /**
   * Consumer goods
   *
   * @generated from enum value: CONSUMER_GOOD = 6;
   */
  CONSUMER_GOOD = 6,

  /**
   * Other types
   *
   * @generated from enum value: OTHER = 7;
   */
  OTHER = 7,
}
// Retrieve enum metadata with: proto3.getEnumType(Entity_Type)
proto3.util.setEnumType(Entity_Type, "google.cloud.language.v1beta1.Entity.Type", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "PERSON" },
  { no: 2, name: "LOCATION" },
  { no: 3, name: "ORGANIZATION" },
  { no: 4, name: "EVENT" },
  { no: 5, name: "WORK_OF_ART" },
  { no: 6, name: "CONSUMER_GOOD" },
  { no: 7, name: "OTHER" },
]);

/**
 * Represents the smallest syntactic building block of the text.
 *
 * @generated from message google.cloud.language.v1beta1.Token
 */
export class Token extends Message<Token> {
  /**
   * The token text.
   *
   * @generated from field: google.cloud.language.v1beta1.TextSpan text = 1;
   */
  text?: TextSpan;

  /**
   * Parts of speech tag for this token.
   *
   * @generated from field: google.cloud.language.v1beta1.PartOfSpeech part_of_speech = 2;
   */
  partOfSpeech?: PartOfSpeech;

  /**
   * Dependency tree parse for this token.
   *
   * @generated from field: google.cloud.language.v1beta1.DependencyEdge dependency_edge = 3;
   */
  dependencyEdge?: DependencyEdge;

  /**
   * [Lemma](https://en.wikipedia.org/wiki/Lemma_%28morphology%29) of the token.
   *
   * @generated from field: string lemma = 4;
   */
  lemma = "";

  constructor(data?: PartialMessage<Token>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.language.v1beta1.Token";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "text", kind: "message", T: TextSpan },
    { no: 2, name: "part_of_speech", kind: "message", T: PartOfSpeech },
    { no: 3, name: "dependency_edge", kind: "message", T: DependencyEdge },
    { no: 4, name: "lemma", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Token {
    return new Token().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Token {
    return new Token().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Token {
    return new Token().fromJsonString(jsonString, options);
  }

  static equals(a: Token | PlainMessage<Token> | undefined, b: Token | PlainMessage<Token> | undefined): boolean {
    return proto3.util.equals(Token, a, b);
  }
}

/**
 * Represents the feeling associated with the entire text or entities in
 * the text.
 *
 * @generated from message google.cloud.language.v1beta1.Sentiment
 */
export class Sentiment extends Message<Sentiment> {
  /**
   * DEPRECATED FIELD - This field is being deprecated in
   * favor of score. Please refer to our documentation at
   * https://cloud.google.com/natural-language/docs for more information.
   *
   * @generated from field: float polarity = 1;
   */
  polarity = 0;

  /**
   * A non-negative number in the [0, +inf) range, which represents
   * the absolute magnitude of sentiment regardless of score (positive or
   * negative).
   *
   * @generated from field: float magnitude = 2;
   */
  magnitude = 0;

  /**
   * Sentiment score between -1.0 (negative sentiment) and 1.0
   * (positive sentiment).
   *
   * @generated from field: float score = 3;
   */
  score = 0;

  constructor(data?: PartialMessage<Sentiment>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.language.v1beta1.Sentiment";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "polarity", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "magnitude", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "score", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Sentiment {
    return new Sentiment().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Sentiment {
    return new Sentiment().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Sentiment {
    return new Sentiment().fromJsonString(jsonString, options);
  }

  static equals(a: Sentiment | PlainMessage<Sentiment> | undefined, b: Sentiment | PlainMessage<Sentiment> | undefined): boolean {
    return proto3.util.equals(Sentiment, a, b);
  }
}

/**
 * Represents part of speech information for a token.
 *
 * @generated from message google.cloud.language.v1beta1.PartOfSpeech
 */
export class PartOfSpeech extends Message<PartOfSpeech> {
  /**
   * The part of speech tag.
   *
   * @generated from field: google.cloud.language.v1beta1.PartOfSpeech.Tag tag = 1;
   */
  tag = PartOfSpeech_Tag.UNKNOWN;

  /**
   * The grammatical aspect.
   *
   * @generated from field: google.cloud.language.v1beta1.PartOfSpeech.Aspect aspect = 2;
   */
  aspect = PartOfSpeech_Aspect.ASPECT_UNKNOWN;

  /**
   * The grammatical case.
   *
   * @generated from field: google.cloud.language.v1beta1.PartOfSpeech.Case case = 3;
   */
  case = PartOfSpeech_Case.CASE_UNKNOWN;

  /**
   * The grammatical form.
   *
   * @generated from field: google.cloud.language.v1beta1.PartOfSpeech.Form form = 4;
   */
  form = PartOfSpeech_Form.FORM_UNKNOWN;

  /**
   * The grammatical gender.
   *
   * @generated from field: google.cloud.language.v1beta1.PartOfSpeech.Gender gender = 5;
   */
  gender = PartOfSpeech_Gender.GENDER_UNKNOWN;

  /**
   * The grammatical mood.
   *
   * @generated from field: google.cloud.language.v1beta1.PartOfSpeech.Mood mood = 6;
   */
  mood = PartOfSpeech_Mood.MOOD_UNKNOWN;

  /**
   * The grammatical number.
   *
   * @generated from field: google.cloud.language.v1beta1.PartOfSpeech.Number number = 7;
   */
  number = PartOfSpeech_Number.NUMBER_UNKNOWN;

  /**
   * The grammatical person.
   *
   * @generated from field: google.cloud.language.v1beta1.PartOfSpeech.Person person = 8;
   */
  person = PartOfSpeech_Person.PERSON_UNKNOWN;

  /**
   * The grammatical properness.
   *
   * @generated from field: google.cloud.language.v1beta1.PartOfSpeech.Proper proper = 9;
   */
  proper = PartOfSpeech_Proper.PROPER_UNKNOWN;

  /**
   * The grammatical reciprocity.
   *
   * @generated from field: google.cloud.language.v1beta1.PartOfSpeech.Reciprocity reciprocity = 10;
   */
  reciprocity = PartOfSpeech_Reciprocity.RECIPROCITY_UNKNOWN;

  /**
   * The grammatical tense.
   *
   * @generated from field: google.cloud.language.v1beta1.PartOfSpeech.Tense tense = 11;
   */
  tense = PartOfSpeech_Tense.TENSE_UNKNOWN;

  /**
   * The grammatical voice.
   *
   * @generated from field: google.cloud.language.v1beta1.PartOfSpeech.Voice voice = 12;
   */
  voice = PartOfSpeech_Voice.VOICE_UNKNOWN;

  constructor(data?: PartialMessage<PartOfSpeech>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.language.v1beta1.PartOfSpeech";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tag", kind: "enum", T: proto3.getEnumType(PartOfSpeech_Tag) },
    { no: 2, name: "aspect", kind: "enum", T: proto3.getEnumType(PartOfSpeech_Aspect) },
    { no: 3, name: "case", kind: "enum", T: proto3.getEnumType(PartOfSpeech_Case) },
    { no: 4, name: "form", kind: "enum", T: proto3.getEnumType(PartOfSpeech_Form) },
    { no: 5, name: "gender", kind: "enum", T: proto3.getEnumType(PartOfSpeech_Gender) },
    { no: 6, name: "mood", kind: "enum", T: proto3.getEnumType(PartOfSpeech_Mood) },
    { no: 7, name: "number", kind: "enum", T: proto3.getEnumType(PartOfSpeech_Number) },
    { no: 8, name: "person", kind: "enum", T: proto3.getEnumType(PartOfSpeech_Person) },
    { no: 9, name: "proper", kind: "enum", T: proto3.getEnumType(PartOfSpeech_Proper) },
    { no: 10, name: "reciprocity", kind: "enum", T: proto3.getEnumType(PartOfSpeech_Reciprocity) },
    { no: 11, name: "tense", kind: "enum", T: proto3.getEnumType(PartOfSpeech_Tense) },
    { no: 12, name: "voice", kind: "enum", T: proto3.getEnumType(PartOfSpeech_Voice) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PartOfSpeech {
    return new PartOfSpeech().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PartOfSpeech {
    return new PartOfSpeech().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PartOfSpeech {
    return new PartOfSpeech().fromJsonString(jsonString, options);
  }

  static equals(a: PartOfSpeech | PlainMessage<PartOfSpeech> | undefined, b: PartOfSpeech | PlainMessage<PartOfSpeech> | undefined): boolean {
    return proto3.util.equals(PartOfSpeech, a, b);
  }
}

/**
 * The part of speech tags enum.
 *
 * @generated from enum google.cloud.language.v1beta1.PartOfSpeech.Tag
 */
export enum PartOfSpeech_Tag {
  /**
   * Unknown
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Adjective
   *
   * @generated from enum value: ADJ = 1;
   */
  ADJ = 1,

  /**
   * Adposition (preposition and postposition)
   *
   * @generated from enum value: ADP = 2;
   */
  ADP = 2,

  /**
   * Adverb
   *
   * @generated from enum value: ADV = 3;
   */
  ADV = 3,

  /**
   * Conjunction
   *
   * @generated from enum value: CONJ = 4;
   */
  CONJ = 4,

  /**
   * Determiner
   *
   * @generated from enum value: DET = 5;
   */
  DET = 5,

  /**
   * Noun (common and proper)
   *
   * @generated from enum value: NOUN = 6;
   */
  NOUN = 6,

  /**
   * Cardinal number
   *
   * @generated from enum value: NUM = 7;
   */
  NUM = 7,

  /**
   * Pronoun
   *
   * @generated from enum value: PRON = 8;
   */
  PRON = 8,

  /**
   * Particle or other function word
   *
   * @generated from enum value: PRT = 9;
   */
  PRT = 9,

  /**
   * Punctuation
   *
   * @generated from enum value: PUNCT = 10;
   */
  PUNCT = 10,

  /**
   * Verb (all tenses and modes)
   *
   * @generated from enum value: VERB = 11;
   */
  VERB = 11,

  /**
   * Other: foreign words, typos, abbreviations
   *
   * @generated from enum value: X = 12;
   */
  X = 12,

  /**
   * Affix
   *
   * @generated from enum value: AFFIX = 13;
   */
  AFFIX = 13,
}
// Retrieve enum metadata with: proto3.getEnumType(PartOfSpeech_Tag)
proto3.util.setEnumType(PartOfSpeech_Tag, "google.cloud.language.v1beta1.PartOfSpeech.Tag", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "ADJ" },
  { no: 2, name: "ADP" },
  { no: 3, name: "ADV" },
  { no: 4, name: "CONJ" },
  { no: 5, name: "DET" },
  { no: 6, name: "NOUN" },
  { no: 7, name: "NUM" },
  { no: 8, name: "PRON" },
  { no: 9, name: "PRT" },
  { no: 10, name: "PUNCT" },
  { no: 11, name: "VERB" },
  { no: 12, name: "X" },
  { no: 13, name: "AFFIX" },
]);

/**
 * The characteristic of a verb that expresses time flow during an event.
 *
 * @generated from enum google.cloud.language.v1beta1.PartOfSpeech.Aspect
 */
export enum PartOfSpeech_Aspect {
  /**
   * Aspect is not applicable in the analyzed language or is not predicted.
   *
   * @generated from enum value: ASPECT_UNKNOWN = 0;
   */
  ASPECT_UNKNOWN = 0,

  /**
   * Perfective
   *
   * @generated from enum value: PERFECTIVE = 1;
   */
  PERFECTIVE = 1,

  /**
   * Imperfective
   *
   * @generated from enum value: IMPERFECTIVE = 2;
   */
  IMPERFECTIVE = 2,

  /**
   * Progressive
   *
   * @generated from enum value: PROGRESSIVE = 3;
   */
  PROGRESSIVE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(PartOfSpeech_Aspect)
proto3.util.setEnumType(PartOfSpeech_Aspect, "google.cloud.language.v1beta1.PartOfSpeech.Aspect", [
  { no: 0, name: "ASPECT_UNKNOWN" },
  { no: 1, name: "PERFECTIVE" },
  { no: 2, name: "IMPERFECTIVE" },
  { no: 3, name: "PROGRESSIVE" },
]);

/**
 * The grammatical function performed by a noun or pronoun in a phrase,
 * clause, or sentence. In some languages, other parts of speech, such as
 * adjective and determiner, take case inflection in agreement with the noun.
 *
 * @generated from enum google.cloud.language.v1beta1.PartOfSpeech.Case
 */
export enum PartOfSpeech_Case {
  /**
   * Case is not applicable in the analyzed language or is not predicted.
   *
   * @generated from enum value: CASE_UNKNOWN = 0;
   */
  CASE_UNKNOWN = 0,

  /**
   * Accusative
   *
   * @generated from enum value: ACCUSATIVE = 1;
   */
  ACCUSATIVE = 1,

  /**
   * Adverbial
   *
   * @generated from enum value: ADVERBIAL = 2;
   */
  ADVERBIAL = 2,

  /**
   * Complementive
   *
   * @generated from enum value: COMPLEMENTIVE = 3;
   */
  COMPLEMENTIVE = 3,

  /**
   * Dative
   *
   * @generated from enum value: DATIVE = 4;
   */
  DATIVE = 4,

  /**
   * Genitive
   *
   * @generated from enum value: GENITIVE = 5;
   */
  GENITIVE = 5,

  /**
   * Instrumental
   *
   * @generated from enum value: INSTRUMENTAL = 6;
   */
  INSTRUMENTAL = 6,

  /**
   * Locative
   *
   * @generated from enum value: LOCATIVE = 7;
   */
  LOCATIVE = 7,

  /**
   * Nominative
   *
   * @generated from enum value: NOMINATIVE = 8;
   */
  NOMINATIVE = 8,

  /**
   * Oblique
   *
   * @generated from enum value: OBLIQUE = 9;
   */
  OBLIQUE = 9,

  /**
   * Partitive
   *
   * @generated from enum value: PARTITIVE = 10;
   */
  PARTITIVE = 10,

  /**
   * Prepositional
   *
   * @generated from enum value: PREPOSITIONAL = 11;
   */
  PREPOSITIONAL = 11,

  /**
   * Reflexive
   *
   * @generated from enum value: REFLEXIVE_CASE = 12;
   */
  REFLEXIVE_CASE = 12,

  /**
   * Relative
   *
   * @generated from enum value: RELATIVE_CASE = 13;
   */
  RELATIVE_CASE = 13,

  /**
   * Vocative
   *
   * @generated from enum value: VOCATIVE = 14;
   */
  VOCATIVE = 14,
}
// Retrieve enum metadata with: proto3.getEnumType(PartOfSpeech_Case)
proto3.util.setEnumType(PartOfSpeech_Case, "google.cloud.language.v1beta1.PartOfSpeech.Case", [
  { no: 0, name: "CASE_UNKNOWN" },
  { no: 1, name: "ACCUSATIVE" },
  { no: 2, name: "ADVERBIAL" },
  { no: 3, name: "COMPLEMENTIVE" },
  { no: 4, name: "DATIVE" },
  { no: 5, name: "GENITIVE" },
  { no: 6, name: "INSTRUMENTAL" },
  { no: 7, name: "LOCATIVE" },
  { no: 8, name: "NOMINATIVE" },
  { no: 9, name: "OBLIQUE" },
  { no: 10, name: "PARTITIVE" },
  { no: 11, name: "PREPOSITIONAL" },
  { no: 12, name: "REFLEXIVE_CASE" },
  { no: 13, name: "RELATIVE_CASE" },
  { no: 14, name: "VOCATIVE" },
]);

/**
 * Depending on the language, Form can be categorizing different forms of
 * verbs, adjectives, adverbs, etc. For example, categorizing inflected
 * endings of verbs and adjectives or distinguishing between short and long
 * forms of adjectives and participles
 *
 * @generated from enum google.cloud.language.v1beta1.PartOfSpeech.Form
 */
export enum PartOfSpeech_Form {
  /**
   * Form is not applicable in the analyzed language or is not predicted.
   *
   * @generated from enum value: FORM_UNKNOWN = 0;
   */
  FORM_UNKNOWN = 0,

  /**
   * Adnomial
   *
   * @generated from enum value: ADNOMIAL = 1;
   */
  ADNOMIAL = 1,

  /**
   * Auxiliary
   *
   * @generated from enum value: AUXILIARY = 2;
   */
  AUXILIARY = 2,

  /**
   * Complementizer
   *
   * @generated from enum value: COMPLEMENTIZER = 3;
   */
  COMPLEMENTIZER = 3,

  /**
   * Final ending
   *
   * @generated from enum value: FINAL_ENDING = 4;
   */
  FINAL_ENDING = 4,

  /**
   * Gerund
   *
   * @generated from enum value: GERUND = 5;
   */
  GERUND = 5,

  /**
   * Realis
   *
   * @generated from enum value: REALIS = 6;
   */
  REALIS = 6,

  /**
   * Irrealis
   *
   * @generated from enum value: IRREALIS = 7;
   */
  IRREALIS = 7,

  /**
   * Short form
   *
   * @generated from enum value: SHORT = 8;
   */
  SHORT = 8,

  /**
   * Long form
   *
   * @generated from enum value: LONG = 9;
   */
  LONG = 9,

  /**
   * Order form
   *
   * @generated from enum value: ORDER = 10;
   */
  ORDER = 10,

  /**
   * Specific form
   *
   * @generated from enum value: SPECIFIC = 11;
   */
  SPECIFIC = 11,
}
// Retrieve enum metadata with: proto3.getEnumType(PartOfSpeech_Form)
proto3.util.setEnumType(PartOfSpeech_Form, "google.cloud.language.v1beta1.PartOfSpeech.Form", [
  { no: 0, name: "FORM_UNKNOWN" },
  { no: 1, name: "ADNOMIAL" },
  { no: 2, name: "AUXILIARY" },
  { no: 3, name: "COMPLEMENTIZER" },
  { no: 4, name: "FINAL_ENDING" },
  { no: 5, name: "GERUND" },
  { no: 6, name: "REALIS" },
  { no: 7, name: "IRREALIS" },
  { no: 8, name: "SHORT" },
  { no: 9, name: "LONG" },
  { no: 10, name: "ORDER" },
  { no: 11, name: "SPECIFIC" },
]);

/**
 * Gender classes of nouns reflected in the behaviour of associated words.
 *
 * @generated from enum google.cloud.language.v1beta1.PartOfSpeech.Gender
 */
export enum PartOfSpeech_Gender {
  /**
   * Gender is not applicable in the analyzed language or is not predicted.
   *
   * @generated from enum value: GENDER_UNKNOWN = 0;
   */
  GENDER_UNKNOWN = 0,

  /**
   * Feminine
   *
   * @generated from enum value: FEMININE = 1;
   */
  FEMININE = 1,

  /**
   * Masculine
   *
   * @generated from enum value: MASCULINE = 2;
   */
  MASCULINE = 2,

  /**
   * Neuter
   *
   * @generated from enum value: NEUTER = 3;
   */
  NEUTER = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(PartOfSpeech_Gender)
proto3.util.setEnumType(PartOfSpeech_Gender, "google.cloud.language.v1beta1.PartOfSpeech.Gender", [
  { no: 0, name: "GENDER_UNKNOWN" },
  { no: 1, name: "FEMININE" },
  { no: 2, name: "MASCULINE" },
  { no: 3, name: "NEUTER" },
]);

/**
 * The grammatical feature of verbs, used for showing modality and attitude.
 *
 * @generated from enum google.cloud.language.v1beta1.PartOfSpeech.Mood
 */
export enum PartOfSpeech_Mood {
  /**
   * Mood is not applicable in the analyzed language or is not predicted.
   *
   * @generated from enum value: MOOD_UNKNOWN = 0;
   */
  MOOD_UNKNOWN = 0,

  /**
   * Conditional
   *
   * @generated from enum value: CONDITIONAL_MOOD = 1;
   */
  CONDITIONAL_MOOD = 1,

  /**
   * Imperative
   *
   * @generated from enum value: IMPERATIVE = 2;
   */
  IMPERATIVE = 2,

  /**
   * Indicative
   *
   * @generated from enum value: INDICATIVE = 3;
   */
  INDICATIVE = 3,

  /**
   * Interrogative
   *
   * @generated from enum value: INTERROGATIVE = 4;
   */
  INTERROGATIVE = 4,

  /**
   * Jussive
   *
   * @generated from enum value: JUSSIVE = 5;
   */
  JUSSIVE = 5,

  /**
   * Subjunctive
   *
   * @generated from enum value: SUBJUNCTIVE = 6;
   */
  SUBJUNCTIVE = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(PartOfSpeech_Mood)
proto3.util.setEnumType(PartOfSpeech_Mood, "google.cloud.language.v1beta1.PartOfSpeech.Mood", [
  { no: 0, name: "MOOD_UNKNOWN" },
  { no: 1, name: "CONDITIONAL_MOOD" },
  { no: 2, name: "IMPERATIVE" },
  { no: 3, name: "INDICATIVE" },
  { no: 4, name: "INTERROGATIVE" },
  { no: 5, name: "JUSSIVE" },
  { no: 6, name: "SUBJUNCTIVE" },
]);

/**
 * Count distinctions.
 *
 * @generated from enum google.cloud.language.v1beta1.PartOfSpeech.Number
 */
export enum PartOfSpeech_Number {
  /**
   * Number is not applicable in the analyzed language or is not predicted.
   *
   * @generated from enum value: NUMBER_UNKNOWN = 0;
   */
  NUMBER_UNKNOWN = 0,

  /**
   * Singular
   *
   * @generated from enum value: SINGULAR = 1;
   */
  SINGULAR = 1,

  /**
   * Plural
   *
   * @generated from enum value: PLURAL = 2;
   */
  PLURAL = 2,

  /**
   * Dual
   *
   * @generated from enum value: DUAL = 3;
   */
  DUAL = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(PartOfSpeech_Number)
proto3.util.setEnumType(PartOfSpeech_Number, "google.cloud.language.v1beta1.PartOfSpeech.Number", [
  { no: 0, name: "NUMBER_UNKNOWN" },
  { no: 1, name: "SINGULAR" },
  { no: 2, name: "PLURAL" },
  { no: 3, name: "DUAL" },
]);

/**
 * The distinction between the speaker, second person, third person, etc.
 *
 * @generated from enum google.cloud.language.v1beta1.PartOfSpeech.Person
 */
export enum PartOfSpeech_Person {
  /**
   * Person is not applicable in the analyzed language or is not predicted.
   *
   * @generated from enum value: PERSON_UNKNOWN = 0;
   */
  PERSON_UNKNOWN = 0,

  /**
   * First
   *
   * @generated from enum value: FIRST = 1;
   */
  FIRST = 1,

  /**
   * Second
   *
   * @generated from enum value: SECOND = 2;
   */
  SECOND = 2,

  /**
   * Third
   *
   * @generated from enum value: THIRD = 3;
   */
  THIRD = 3,

  /**
   * Reflexive
   *
   * @generated from enum value: REFLEXIVE_PERSON = 4;
   */
  REFLEXIVE_PERSON = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(PartOfSpeech_Person)
proto3.util.setEnumType(PartOfSpeech_Person, "google.cloud.language.v1beta1.PartOfSpeech.Person", [
  { no: 0, name: "PERSON_UNKNOWN" },
  { no: 1, name: "FIRST" },
  { no: 2, name: "SECOND" },
  { no: 3, name: "THIRD" },
  { no: 4, name: "REFLEXIVE_PERSON" },
]);

/**
 * This category shows if the token is part of a proper name.
 *
 * @generated from enum google.cloud.language.v1beta1.PartOfSpeech.Proper
 */
export enum PartOfSpeech_Proper {
  /**
   * Proper is not applicable in the analyzed language or is not predicted.
   *
   * @generated from enum value: PROPER_UNKNOWN = 0;
   */
  PROPER_UNKNOWN = 0,

  /**
   * Proper
   *
   * @generated from enum value: PROPER = 1;
   */
  PROPER = 1,

  /**
   * Not proper
   *
   * @generated from enum value: NOT_PROPER = 2;
   */
  NOT_PROPER = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(PartOfSpeech_Proper)
proto3.util.setEnumType(PartOfSpeech_Proper, "google.cloud.language.v1beta1.PartOfSpeech.Proper", [
  { no: 0, name: "PROPER_UNKNOWN" },
  { no: 1, name: "PROPER" },
  { no: 2, name: "NOT_PROPER" },
]);

/**
 * Reciprocal features of a pronoun.
 *
 * @generated from enum google.cloud.language.v1beta1.PartOfSpeech.Reciprocity
 */
export enum PartOfSpeech_Reciprocity {
  /**
   * Reciprocity is not applicable in the analyzed language or is not
   * predicted.
   *
   * @generated from enum value: RECIPROCITY_UNKNOWN = 0;
   */
  RECIPROCITY_UNKNOWN = 0,

  /**
   * Reciprocal
   *
   * @generated from enum value: RECIPROCAL = 1;
   */
  RECIPROCAL = 1,

  /**
   * Non-reciprocal
   *
   * @generated from enum value: NON_RECIPROCAL = 2;
   */
  NON_RECIPROCAL = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(PartOfSpeech_Reciprocity)
proto3.util.setEnumType(PartOfSpeech_Reciprocity, "google.cloud.language.v1beta1.PartOfSpeech.Reciprocity", [
  { no: 0, name: "RECIPROCITY_UNKNOWN" },
  { no: 1, name: "RECIPROCAL" },
  { no: 2, name: "NON_RECIPROCAL" },
]);

/**
 * Time reference.
 *
 * @generated from enum google.cloud.language.v1beta1.PartOfSpeech.Tense
 */
export enum PartOfSpeech_Tense {
  /**
   * Tense is not applicable in the analyzed language or is not predicted.
   *
   * @generated from enum value: TENSE_UNKNOWN = 0;
   */
  TENSE_UNKNOWN = 0,

  /**
   * Conditional
   *
   * @generated from enum value: CONDITIONAL_TENSE = 1;
   */
  CONDITIONAL_TENSE = 1,

  /**
   * Future
   *
   * @generated from enum value: FUTURE = 2;
   */
  FUTURE = 2,

  /**
   * Past
   *
   * @generated from enum value: PAST = 3;
   */
  PAST = 3,

  /**
   * Present
   *
   * @generated from enum value: PRESENT = 4;
   */
  PRESENT = 4,

  /**
   * Imperfect
   *
   * @generated from enum value: IMPERFECT = 5;
   */
  IMPERFECT = 5,

  /**
   * Pluperfect
   *
   * @generated from enum value: PLUPERFECT = 6;
   */
  PLUPERFECT = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(PartOfSpeech_Tense)
proto3.util.setEnumType(PartOfSpeech_Tense, "google.cloud.language.v1beta1.PartOfSpeech.Tense", [
  { no: 0, name: "TENSE_UNKNOWN" },
  { no: 1, name: "CONDITIONAL_TENSE" },
  { no: 2, name: "FUTURE" },
  { no: 3, name: "PAST" },
  { no: 4, name: "PRESENT" },
  { no: 5, name: "IMPERFECT" },
  { no: 6, name: "PLUPERFECT" },
]);

/**
 * The relationship between the action that a verb expresses and the
 * participants identified by its arguments.
 *
 * @generated from enum google.cloud.language.v1beta1.PartOfSpeech.Voice
 */
export enum PartOfSpeech_Voice {
  /**
   * Voice is not applicable in the analyzed language or is not predicted.
   *
   * @generated from enum value: VOICE_UNKNOWN = 0;
   */
  VOICE_UNKNOWN = 0,

  /**
   * Active
   *
   * @generated from enum value: ACTIVE = 1;
   */
  ACTIVE = 1,

  /**
   * Causative
   *
   * @generated from enum value: CAUSATIVE = 2;
   */
  CAUSATIVE = 2,

  /**
   * Passive
   *
   * @generated from enum value: PASSIVE = 3;
   */
  PASSIVE = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(PartOfSpeech_Voice)
proto3.util.setEnumType(PartOfSpeech_Voice, "google.cloud.language.v1beta1.PartOfSpeech.Voice", [
  { no: 0, name: "VOICE_UNKNOWN" },
  { no: 1, name: "ACTIVE" },
  { no: 2, name: "CAUSATIVE" },
  { no: 3, name: "PASSIVE" },
]);

/**
 * Represents dependency parse tree information for a token.
 *
 * @generated from message google.cloud.language.v1beta1.DependencyEdge
 */
export class DependencyEdge extends Message<DependencyEdge> {
  /**
   * Represents the head of this token in the dependency tree.
   * This is the index of the token which has an arc going to this token.
   * The index is the position of the token in the array of tokens returned
   * by the API method. If this token is a root token, then the
   * `head_token_index` is its own index.
   *
   * @generated from field: int32 head_token_index = 1;
   */
  headTokenIndex = 0;

  /**
   * The parse label for the token.
   *
   * @generated from field: google.cloud.language.v1beta1.DependencyEdge.Label label = 2;
   */
  label = DependencyEdge_Label.UNKNOWN;

  constructor(data?: PartialMessage<DependencyEdge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.language.v1beta1.DependencyEdge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "head_token_index", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "label", kind: "enum", T: proto3.getEnumType(DependencyEdge_Label) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DependencyEdge {
    return new DependencyEdge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DependencyEdge {
    return new DependencyEdge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DependencyEdge {
    return new DependencyEdge().fromJsonString(jsonString, options);
  }

  static equals(a: DependencyEdge | PlainMessage<DependencyEdge> | undefined, b: DependencyEdge | PlainMessage<DependencyEdge> | undefined): boolean {
    return proto3.util.equals(DependencyEdge, a, b);
  }
}

/**
 * The parse label enum for the token.
 *
 * @generated from enum google.cloud.language.v1beta1.DependencyEdge.Label
 */
export enum DependencyEdge_Label {
  /**
   * Unknown
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Abbreviation modifier
   *
   * @generated from enum value: ABBREV = 1;
   */
  ABBREV = 1,

  /**
   * Adjectival complement
   *
   * @generated from enum value: ACOMP = 2;
   */
  ACOMP = 2,

  /**
   * Adverbial clause modifier
   *
   * @generated from enum value: ADVCL = 3;
   */
  ADVCL = 3,

  /**
   * Adverbial modifier
   *
   * @generated from enum value: ADVMOD = 4;
   */
  ADVMOD = 4,

  /**
   * Adjectival modifier of an NP
   *
   * @generated from enum value: AMOD = 5;
   */
  AMOD = 5,

  /**
   * Appositional modifier of an NP
   *
   * @generated from enum value: APPOS = 6;
   */
  APPOS = 6,

  /**
   * Attribute dependent of a copular verb
   *
   * @generated from enum value: ATTR = 7;
   */
  ATTR = 7,

  /**
   * Auxiliary (non-main) verb
   *
   * @generated from enum value: AUX = 8;
   */
  AUX = 8,

  /**
   * Passive auxiliary
   *
   * @generated from enum value: AUXPASS = 9;
   */
  AUXPASS = 9,

  /**
   * Coordinating conjunction
   *
   * @generated from enum value: CC = 10;
   */
  CC = 10,

  /**
   * Clausal complement of a verb or adjective
   *
   * @generated from enum value: CCOMP = 11;
   */
  CCOMP = 11,

  /**
   * Conjunct
   *
   * @generated from enum value: CONJ = 12;
   */
  CONJ = 12,

  /**
   * Clausal subject
   *
   * @generated from enum value: CSUBJ = 13;
   */
  CSUBJ = 13,

  /**
   * Clausal passive subject
   *
   * @generated from enum value: CSUBJPASS = 14;
   */
  CSUBJPASS = 14,

  /**
   * Dependency (unable to determine)
   *
   * @generated from enum value: DEP = 15;
   */
  DEP = 15,

  /**
   * Determiner
   *
   * @generated from enum value: DET = 16;
   */
  DET = 16,

  /**
   * Discourse
   *
   * @generated from enum value: DISCOURSE = 17;
   */
  DISCOURSE = 17,

  /**
   * Direct object
   *
   * @generated from enum value: DOBJ = 18;
   */
  DOBJ = 18,

  /**
   * Expletive
   *
   * @generated from enum value: EXPL = 19;
   */
  EXPL = 19,

  /**
   * Goes with (part of a word in a text not well edited)
   *
   * @generated from enum value: GOESWITH = 20;
   */
  GOESWITH = 20,

  /**
   * Indirect object
   *
   * @generated from enum value: IOBJ = 21;
   */
  IOBJ = 21,

  /**
   * Marker (word introducing a subordinate clause)
   *
   * @generated from enum value: MARK = 22;
   */
  MARK = 22,

  /**
   * Multi-word expression
   *
   * @generated from enum value: MWE = 23;
   */
  MWE = 23,

  /**
   * Multi-word verbal expression
   *
   * @generated from enum value: MWV = 24;
   */
  MWV = 24,

  /**
   * Negation modifier
   *
   * @generated from enum value: NEG = 25;
   */
  NEG = 25,

  /**
   * Noun compound modifier
   *
   * @generated from enum value: NN = 26;
   */
  NN = 26,

  /**
   * Noun phrase used as an adverbial modifier
   *
   * @generated from enum value: NPADVMOD = 27;
   */
  NPADVMOD = 27,

  /**
   * Nominal subject
   *
   * @generated from enum value: NSUBJ = 28;
   */
  NSUBJ = 28,

  /**
   * Passive nominal subject
   *
   * @generated from enum value: NSUBJPASS = 29;
   */
  NSUBJPASS = 29,

  /**
   * Numeric modifier of a noun
   *
   * @generated from enum value: NUM = 30;
   */
  NUM = 30,

  /**
   * Element of compound number
   *
   * @generated from enum value: NUMBER = 31;
   */
  NUMBER = 31,

  /**
   * Punctuation mark
   *
   * @generated from enum value: P = 32;
   */
  P = 32,

  /**
   * Parataxis relation
   *
   * @generated from enum value: PARATAXIS = 33;
   */
  PARATAXIS = 33,

  /**
   * Participial modifier
   *
   * @generated from enum value: PARTMOD = 34;
   */
  PARTMOD = 34,

  /**
   * The complement of a preposition is a clause
   *
   * @generated from enum value: PCOMP = 35;
   */
  PCOMP = 35,

  /**
   * Object of a preposition
   *
   * @generated from enum value: POBJ = 36;
   */
  POBJ = 36,

  /**
   * Possession modifier
   *
   * @generated from enum value: POSS = 37;
   */
  POSS = 37,

  /**
   * Postverbal negative particle
   *
   * @generated from enum value: POSTNEG = 38;
   */
  POSTNEG = 38,

  /**
   * Predicate complement
   *
   * @generated from enum value: PRECOMP = 39;
   */
  PRECOMP = 39,

  /**
   * Preconjunt
   *
   * @generated from enum value: PRECONJ = 40;
   */
  PRECONJ = 40,

  /**
   * Predeterminer
   *
   * @generated from enum value: PREDET = 41;
   */
  PREDET = 41,

  /**
   * Prefix
   *
   * @generated from enum value: PREF = 42;
   */
  PREF = 42,

  /**
   * Prepositional modifier
   *
   * @generated from enum value: PREP = 43;
   */
  PREP = 43,

  /**
   * The relationship between a verb and verbal morpheme
   *
   * @generated from enum value: PRONL = 44;
   */
  PRONL = 44,

  /**
   * Particle
   *
   * @generated from enum value: PRT = 45;
   */
  PRT = 45,

  /**
   * Associative or possessive marker
   *
   * @generated from enum value: PS = 46;
   */
  PS = 46,

  /**
   * Quantifier phrase modifier
   *
   * @generated from enum value: QUANTMOD = 47;
   */
  QUANTMOD = 47,

  /**
   * Relative clause modifier
   *
   * @generated from enum value: RCMOD = 48;
   */
  RCMOD = 48,

  /**
   * Complementizer in relative clause
   *
   * @generated from enum value: RCMODREL = 49;
   */
  RCMODREL = 49,

  /**
   * Ellipsis without a preceding predicate
   *
   * @generated from enum value: RDROP = 50;
   */
  RDROP = 50,

  /**
   * Referent
   *
   * @generated from enum value: REF = 51;
   */
  REF = 51,

  /**
   * Remnant
   *
   * @generated from enum value: REMNANT = 52;
   */
  REMNANT = 52,

  /**
   * Reparandum
   *
   * @generated from enum value: REPARANDUM = 53;
   */
  REPARANDUM = 53,

  /**
   * Root
   *
   * @generated from enum value: ROOT = 54;
   */
  ROOT = 54,

  /**
   * Suffix specifying a unit of number
   *
   * @generated from enum value: SNUM = 55;
   */
  SNUM = 55,

  /**
   * Suffix
   *
   * @generated from enum value: SUFF = 56;
   */
  SUFF = 56,

  /**
   * Temporal modifier
   *
   * @generated from enum value: TMOD = 57;
   */
  TMOD = 57,

  /**
   * Topic marker
   *
   * @generated from enum value: TOPIC = 58;
   */
  TOPIC = 58,

  /**
   * Clause headed by an infinite form of the verb that modifies a noun
   *
   * @generated from enum value: VMOD = 59;
   */
  VMOD = 59,

  /**
   * Vocative
   *
   * @generated from enum value: VOCATIVE = 60;
   */
  VOCATIVE = 60,

  /**
   * Open clausal complement
   *
   * @generated from enum value: XCOMP = 61;
   */
  XCOMP = 61,

  /**
   * Name suffix
   *
   * @generated from enum value: SUFFIX = 62;
   */
  SUFFIX = 62,

  /**
   * Name title
   *
   * @generated from enum value: TITLE = 63;
   */
  TITLE = 63,

  /**
   * Adverbial phrase modifier
   *
   * @generated from enum value: ADVPHMOD = 64;
   */
  ADVPHMOD = 64,

  /**
   * Causative auxiliary
   *
   * @generated from enum value: AUXCAUS = 65;
   */
  AUXCAUS = 65,

  /**
   * Helper auxiliary
   *
   * @generated from enum value: AUXVV = 66;
   */
  AUXVV = 66,

  /**
   * Rentaishi (Prenominal modifier)
   *
   * @generated from enum value: DTMOD = 67;
   */
  DTMOD = 67,

  /**
   * Foreign words
   *
   * @generated from enum value: FOREIGN = 68;
   */
  FOREIGN = 68,

  /**
   * Keyword
   *
   * @generated from enum value: KW = 69;
   */
  KW = 69,

  /**
   * List for chains of comparable items
   *
   * @generated from enum value: LIST = 70;
   */
  LIST = 70,

  /**
   * Nominalized clause
   *
   * @generated from enum value: NOMC = 71;
   */
  NOMC = 71,

  /**
   * Nominalized clausal subject
   *
   * @generated from enum value: NOMCSUBJ = 72;
   */
  NOMCSUBJ = 72,

  /**
   * Nominalized clausal passive
   *
   * @generated from enum value: NOMCSUBJPASS = 73;
   */
  NOMCSUBJPASS = 73,

  /**
   * Compound of numeric modifier
   *
   * @generated from enum value: NUMC = 74;
   */
  NUMC = 74,

  /**
   * Copula
   *
   * @generated from enum value: COP = 75;
   */
  COP = 75,

  /**
   * Dislocated relation (for fronted/topicalized elements)
   *
   * @generated from enum value: DISLOCATED = 76;
   */
  DISLOCATED = 76,
}
// Retrieve enum metadata with: proto3.getEnumType(DependencyEdge_Label)
proto3.util.setEnumType(DependencyEdge_Label, "google.cloud.language.v1beta1.DependencyEdge.Label", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "ABBREV" },
  { no: 2, name: "ACOMP" },
  { no: 3, name: "ADVCL" },
  { no: 4, name: "ADVMOD" },
  { no: 5, name: "AMOD" },
  { no: 6, name: "APPOS" },
  { no: 7, name: "ATTR" },
  { no: 8, name: "AUX" },
  { no: 9, name: "AUXPASS" },
  { no: 10, name: "CC" },
  { no: 11, name: "CCOMP" },
  { no: 12, name: "CONJ" },
  { no: 13, name: "CSUBJ" },
  { no: 14, name: "CSUBJPASS" },
  { no: 15, name: "DEP" },
  { no: 16, name: "DET" },
  { no: 17, name: "DISCOURSE" },
  { no: 18, name: "DOBJ" },
  { no: 19, name: "EXPL" },
  { no: 20, name: "GOESWITH" },
  { no: 21, name: "IOBJ" },
  { no: 22, name: "MARK" },
  { no: 23, name: "MWE" },
  { no: 24, name: "MWV" },
  { no: 25, name: "NEG" },
  { no: 26, name: "NN" },
  { no: 27, name: "NPADVMOD" },
  { no: 28, name: "NSUBJ" },
  { no: 29, name: "NSUBJPASS" },
  { no: 30, name: "NUM" },
  { no: 31, name: "NUMBER" },
  { no: 32, name: "P" },
  { no: 33, name: "PARATAXIS" },
  { no: 34, name: "PARTMOD" },
  { no: 35, name: "PCOMP" },
  { no: 36, name: "POBJ" },
  { no: 37, name: "POSS" },
  { no: 38, name: "POSTNEG" },
  { no: 39, name: "PRECOMP" },
  { no: 40, name: "PRECONJ" },
  { no: 41, name: "PREDET" },
  { no: 42, name: "PREF" },
  { no: 43, name: "PREP" },
  { no: 44, name: "PRONL" },
  { no: 45, name: "PRT" },
  { no: 46, name: "PS" },
  { no: 47, name: "QUANTMOD" },
  { no: 48, name: "RCMOD" },
  { no: 49, name: "RCMODREL" },
  { no: 50, name: "RDROP" },
  { no: 51, name: "REF" },
  { no: 52, name: "REMNANT" },
  { no: 53, name: "REPARANDUM" },
  { no: 54, name: "ROOT" },
  { no: 55, name: "SNUM" },
  { no: 56, name: "SUFF" },
  { no: 57, name: "TMOD" },
  { no: 58, name: "TOPIC" },
  { no: 59, name: "VMOD" },
  { no: 60, name: "VOCATIVE" },
  { no: 61, name: "XCOMP" },
  { no: 62, name: "SUFFIX" },
  { no: 63, name: "TITLE" },
  { no: 64, name: "ADVPHMOD" },
  { no: 65, name: "AUXCAUS" },
  { no: 66, name: "AUXVV" },
  { no: 67, name: "DTMOD" },
  { no: 68, name: "FOREIGN" },
  { no: 69, name: "KW" },
  { no: 70, name: "LIST" },
  { no: 71, name: "NOMC" },
  { no: 72, name: "NOMCSUBJ" },
  { no: 73, name: "NOMCSUBJPASS" },
  { no: 74, name: "NUMC" },
  { no: 75, name: "COP" },
  { no: 76, name: "DISLOCATED" },
]);

/**
 * Represents a mention for an entity in the text. Currently, proper noun
 * mentions are supported.
 *
 * @generated from message google.cloud.language.v1beta1.EntityMention
 */
export class EntityMention extends Message<EntityMention> {
  /**
   * The mention text.
   *
   * @generated from field: google.cloud.language.v1beta1.TextSpan text = 1;
   */
  text?: TextSpan;

  /**
   * The type of the entity mention.
   *
   * @generated from field: google.cloud.language.v1beta1.EntityMention.Type type = 2;
   */
  type = EntityMention_Type.TYPE_UNKNOWN;

  constructor(data?: PartialMessage<EntityMention>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.language.v1beta1.EntityMention";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "text", kind: "message", T: TextSpan },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(EntityMention_Type) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EntityMention {
    return new EntityMention().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EntityMention {
    return new EntityMention().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EntityMention {
    return new EntityMention().fromJsonString(jsonString, options);
  }

  static equals(a: EntityMention | PlainMessage<EntityMention> | undefined, b: EntityMention | PlainMessage<EntityMention> | undefined): boolean {
    return proto3.util.equals(EntityMention, a, b);
  }
}

/**
 * The supported types of mentions.
 *
 * @generated from enum google.cloud.language.v1beta1.EntityMention.Type
 */
export enum EntityMention_Type {
  /**
   * Unknown
   *
   * @generated from enum value: TYPE_UNKNOWN = 0;
   */
  TYPE_UNKNOWN = 0,

  /**
   * Proper name
   *
   * @generated from enum value: PROPER = 1;
   */
  PROPER = 1,

  /**
   * Common noun (or noun compound)
   *
   * @generated from enum value: COMMON = 2;
   */
  COMMON = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(EntityMention_Type)
proto3.util.setEnumType(EntityMention_Type, "google.cloud.language.v1beta1.EntityMention.Type", [
  { no: 0, name: "TYPE_UNKNOWN" },
  { no: 1, name: "PROPER" },
  { no: 2, name: "COMMON" },
]);

/**
 * Represents an output piece of text.
 *
 * @generated from message google.cloud.language.v1beta1.TextSpan
 */
export class TextSpan extends Message<TextSpan> {
  /**
   * The content of the output text.
   *
   * @generated from field: string content = 1;
   */
  content = "";

  /**
   * The API calculates the beginning offset of the content in the original
   * document according to the [EncodingType][google.cloud.language.v1beta1.EncodingType] specified in the API request.
   *
   * @generated from field: int32 begin_offset = 2;
   */
  beginOffset = 0;

  constructor(data?: PartialMessage<TextSpan>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.language.v1beta1.TextSpan";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "content", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "begin_offset", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextSpan {
    return new TextSpan().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextSpan {
    return new TextSpan().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextSpan {
    return new TextSpan().fromJsonString(jsonString, options);
  }

  static equals(a: TextSpan | PlainMessage<TextSpan> | undefined, b: TextSpan | PlainMessage<TextSpan> | undefined): boolean {
    return proto3.util.equals(TextSpan, a, b);
  }
}

/**
 * The sentiment analysis request message.
 *
 * @generated from message google.cloud.language.v1beta1.AnalyzeSentimentRequest
 */
export class AnalyzeSentimentRequest extends Message<AnalyzeSentimentRequest> {
  /**
   * Input document.
   *
   * @generated from field: google.cloud.language.v1beta1.Document document = 1;
   */
  document?: Document;

  /**
   * The encoding type used by the API to calculate sentence offsets for the
   * sentence sentiment.
   *
   * @generated from field: google.cloud.language.v1beta1.EncodingType encoding_type = 2;
   */
  encodingType = EncodingType.NONE;

  constructor(data?: PartialMessage<AnalyzeSentimentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.language.v1beta1.AnalyzeSentimentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document", kind: "message", T: Document },
    { no: 2, name: "encoding_type", kind: "enum", T: proto3.getEnumType(EncodingType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnalyzeSentimentRequest {
    return new AnalyzeSentimentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnalyzeSentimentRequest {
    return new AnalyzeSentimentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnalyzeSentimentRequest {
    return new AnalyzeSentimentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AnalyzeSentimentRequest | PlainMessage<AnalyzeSentimentRequest> | undefined, b: AnalyzeSentimentRequest | PlainMessage<AnalyzeSentimentRequest> | undefined): boolean {
    return proto3.util.equals(AnalyzeSentimentRequest, a, b);
  }
}

/**
 * The sentiment analysis response message.
 *
 * @generated from message google.cloud.language.v1beta1.AnalyzeSentimentResponse
 */
export class AnalyzeSentimentResponse extends Message<AnalyzeSentimentResponse> {
  /**
   * The overall sentiment of the input document.
   *
   * @generated from field: google.cloud.language.v1beta1.Sentiment document_sentiment = 1;
   */
  documentSentiment?: Sentiment;

  /**
   * The language of the text, which will be the same as the language specified
   * in the request or, if not specified, the automatically-detected language.
   * See [Document.language][google.cloud.language.v1beta1.Document.language] field for more details.
   *
   * @generated from field: string language = 2;
   */
  language = "";

  /**
   * The sentiment for all the sentences in the document.
   *
   * @generated from field: repeated google.cloud.language.v1beta1.Sentence sentences = 3;
   */
  sentences: Sentence[] = [];

  constructor(data?: PartialMessage<AnalyzeSentimentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.language.v1beta1.AnalyzeSentimentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document_sentiment", kind: "message", T: Sentiment },
    { no: 2, name: "language", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "sentences", kind: "message", T: Sentence, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnalyzeSentimentResponse {
    return new AnalyzeSentimentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnalyzeSentimentResponse {
    return new AnalyzeSentimentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnalyzeSentimentResponse {
    return new AnalyzeSentimentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AnalyzeSentimentResponse | PlainMessage<AnalyzeSentimentResponse> | undefined, b: AnalyzeSentimentResponse | PlainMessage<AnalyzeSentimentResponse> | undefined): boolean {
    return proto3.util.equals(AnalyzeSentimentResponse, a, b);
  }
}

/**
 * The entity analysis request message.
 *
 * @generated from message google.cloud.language.v1beta1.AnalyzeEntitiesRequest
 */
export class AnalyzeEntitiesRequest extends Message<AnalyzeEntitiesRequest> {
  /**
   * Input document.
   *
   * @generated from field: google.cloud.language.v1beta1.Document document = 1;
   */
  document?: Document;

  /**
   * The encoding type used by the API to calculate offsets.
   *
   * @generated from field: google.cloud.language.v1beta1.EncodingType encoding_type = 2;
   */
  encodingType = EncodingType.NONE;

  constructor(data?: PartialMessage<AnalyzeEntitiesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.language.v1beta1.AnalyzeEntitiesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document", kind: "message", T: Document },
    { no: 2, name: "encoding_type", kind: "enum", T: proto3.getEnumType(EncodingType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnalyzeEntitiesRequest {
    return new AnalyzeEntitiesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnalyzeEntitiesRequest {
    return new AnalyzeEntitiesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnalyzeEntitiesRequest {
    return new AnalyzeEntitiesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AnalyzeEntitiesRequest | PlainMessage<AnalyzeEntitiesRequest> | undefined, b: AnalyzeEntitiesRequest | PlainMessage<AnalyzeEntitiesRequest> | undefined): boolean {
    return proto3.util.equals(AnalyzeEntitiesRequest, a, b);
  }
}

/**
 * The entity analysis response message.
 *
 * @generated from message google.cloud.language.v1beta1.AnalyzeEntitiesResponse
 */
export class AnalyzeEntitiesResponse extends Message<AnalyzeEntitiesResponse> {
  /**
   * The recognized entities in the input document.
   *
   * @generated from field: repeated google.cloud.language.v1beta1.Entity entities = 1;
   */
  entities: Entity[] = [];

  /**
   * The language of the text, which will be the same as the language specified
   * in the request or, if not specified, the automatically-detected language.
   * See [Document.language][google.cloud.language.v1beta1.Document.language] field for more details.
   *
   * @generated from field: string language = 2;
   */
  language = "";

  constructor(data?: PartialMessage<AnalyzeEntitiesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.language.v1beta1.AnalyzeEntitiesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entities", kind: "message", T: Entity, repeated: true },
    { no: 2, name: "language", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnalyzeEntitiesResponse {
    return new AnalyzeEntitiesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnalyzeEntitiesResponse {
    return new AnalyzeEntitiesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnalyzeEntitiesResponse {
    return new AnalyzeEntitiesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AnalyzeEntitiesResponse | PlainMessage<AnalyzeEntitiesResponse> | undefined, b: AnalyzeEntitiesResponse | PlainMessage<AnalyzeEntitiesResponse> | undefined): boolean {
    return proto3.util.equals(AnalyzeEntitiesResponse, a, b);
  }
}

/**
 * The syntax analysis request message.
 *
 * @generated from message google.cloud.language.v1beta1.AnalyzeSyntaxRequest
 */
export class AnalyzeSyntaxRequest extends Message<AnalyzeSyntaxRequest> {
  /**
   * Input document.
   *
   * @generated from field: google.cloud.language.v1beta1.Document document = 1;
   */
  document?: Document;

  /**
   * The encoding type used by the API to calculate offsets.
   *
   * @generated from field: google.cloud.language.v1beta1.EncodingType encoding_type = 2;
   */
  encodingType = EncodingType.NONE;

  constructor(data?: PartialMessage<AnalyzeSyntaxRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.language.v1beta1.AnalyzeSyntaxRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document", kind: "message", T: Document },
    { no: 2, name: "encoding_type", kind: "enum", T: proto3.getEnumType(EncodingType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnalyzeSyntaxRequest {
    return new AnalyzeSyntaxRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnalyzeSyntaxRequest {
    return new AnalyzeSyntaxRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnalyzeSyntaxRequest {
    return new AnalyzeSyntaxRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AnalyzeSyntaxRequest | PlainMessage<AnalyzeSyntaxRequest> | undefined, b: AnalyzeSyntaxRequest | PlainMessage<AnalyzeSyntaxRequest> | undefined): boolean {
    return proto3.util.equals(AnalyzeSyntaxRequest, a, b);
  }
}

/**
 * The syntax analysis response message.
 *
 * @generated from message google.cloud.language.v1beta1.AnalyzeSyntaxResponse
 */
export class AnalyzeSyntaxResponse extends Message<AnalyzeSyntaxResponse> {
  /**
   * Sentences in the input document.
   *
   * @generated from field: repeated google.cloud.language.v1beta1.Sentence sentences = 1;
   */
  sentences: Sentence[] = [];

  /**
   * Tokens, along with their syntactic information, in the input document.
   *
   * @generated from field: repeated google.cloud.language.v1beta1.Token tokens = 2;
   */
  tokens: Token[] = [];

  /**
   * The language of the text, which will be the same as the language specified
   * in the request or, if not specified, the automatically-detected language.
   * See [Document.language][google.cloud.language.v1beta1.Document.language] field for more details.
   *
   * @generated from field: string language = 3;
   */
  language = "";

  constructor(data?: PartialMessage<AnalyzeSyntaxResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.language.v1beta1.AnalyzeSyntaxResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sentences", kind: "message", T: Sentence, repeated: true },
    { no: 2, name: "tokens", kind: "message", T: Token, repeated: true },
    { no: 3, name: "language", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnalyzeSyntaxResponse {
    return new AnalyzeSyntaxResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnalyzeSyntaxResponse {
    return new AnalyzeSyntaxResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnalyzeSyntaxResponse {
    return new AnalyzeSyntaxResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AnalyzeSyntaxResponse | PlainMessage<AnalyzeSyntaxResponse> | undefined, b: AnalyzeSyntaxResponse | PlainMessage<AnalyzeSyntaxResponse> | undefined): boolean {
    return proto3.util.equals(AnalyzeSyntaxResponse, a, b);
  }
}

/**
 * The request message for the text annotation API, which can perform multiple
 * analysis types (sentiment, entities, and syntax) in one call.
 *
 * @generated from message google.cloud.language.v1beta1.AnnotateTextRequest
 */
export class AnnotateTextRequest extends Message<AnnotateTextRequest> {
  /**
   * Input document.
   *
   * @generated from field: google.cloud.language.v1beta1.Document document = 1;
   */
  document?: Document;

  /**
   * The enabled features.
   *
   * @generated from field: google.cloud.language.v1beta1.AnnotateTextRequest.Features features = 2;
   */
  features?: AnnotateTextRequest_Features;

  /**
   * The encoding type used by the API to calculate offsets.
   *
   * @generated from field: google.cloud.language.v1beta1.EncodingType encoding_type = 3;
   */
  encodingType = EncodingType.NONE;

  constructor(data?: PartialMessage<AnnotateTextRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.language.v1beta1.AnnotateTextRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document", kind: "message", T: Document },
    { no: 2, name: "features", kind: "message", T: AnnotateTextRequest_Features },
    { no: 3, name: "encoding_type", kind: "enum", T: proto3.getEnumType(EncodingType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnnotateTextRequest {
    return new AnnotateTextRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnnotateTextRequest {
    return new AnnotateTextRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnnotateTextRequest {
    return new AnnotateTextRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AnnotateTextRequest | PlainMessage<AnnotateTextRequest> | undefined, b: AnnotateTextRequest | PlainMessage<AnnotateTextRequest> | undefined): boolean {
    return proto3.util.equals(AnnotateTextRequest, a, b);
  }
}

/**
 * All available features for sentiment, syntax, and semantic analysis.
 * Setting each one to true will enable that specific analysis for the input.
 *
 * @generated from message google.cloud.language.v1beta1.AnnotateTextRequest.Features
 */
export class AnnotateTextRequest_Features extends Message<AnnotateTextRequest_Features> {
  /**
   * Extract syntax information.
   *
   * @generated from field: bool extract_syntax = 1;
   */
  extractSyntax = false;

  /**
   * Extract entities.
   *
   * @generated from field: bool extract_entities = 2;
   */
  extractEntities = false;

  /**
   * Extract document-level sentiment.
   *
   * @generated from field: bool extract_document_sentiment = 3;
   */
  extractDocumentSentiment = false;

  constructor(data?: PartialMessage<AnnotateTextRequest_Features>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.language.v1beta1.AnnotateTextRequest.Features";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "extract_syntax", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "extract_entities", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "extract_document_sentiment", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnnotateTextRequest_Features {
    return new AnnotateTextRequest_Features().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnnotateTextRequest_Features {
    return new AnnotateTextRequest_Features().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnnotateTextRequest_Features {
    return new AnnotateTextRequest_Features().fromJsonString(jsonString, options);
  }

  static equals(a: AnnotateTextRequest_Features | PlainMessage<AnnotateTextRequest_Features> | undefined, b: AnnotateTextRequest_Features | PlainMessage<AnnotateTextRequest_Features> | undefined): boolean {
    return proto3.util.equals(AnnotateTextRequest_Features, a, b);
  }
}

/**
 * The text annotations response message.
 *
 * @generated from message google.cloud.language.v1beta1.AnnotateTextResponse
 */
export class AnnotateTextResponse extends Message<AnnotateTextResponse> {
  /**
   * Sentences in the input document. Populated if the user enables
   * [AnnotateTextRequest.Features.extract_syntax][google.cloud.language.v1beta1.AnnotateTextRequest.Features.extract_syntax].
   *
   * @generated from field: repeated google.cloud.language.v1beta1.Sentence sentences = 1;
   */
  sentences: Sentence[] = [];

  /**
   * Tokens, along with their syntactic information, in the input document.
   * Populated if the user enables
   * [AnnotateTextRequest.Features.extract_syntax][google.cloud.language.v1beta1.AnnotateTextRequest.Features.extract_syntax].
   *
   * @generated from field: repeated google.cloud.language.v1beta1.Token tokens = 2;
   */
  tokens: Token[] = [];

  /**
   * Entities, along with their semantic information, in the input document.
   * Populated if the user enables
   * [AnnotateTextRequest.Features.extract_entities][google.cloud.language.v1beta1.AnnotateTextRequest.Features.extract_entities].
   *
   * @generated from field: repeated google.cloud.language.v1beta1.Entity entities = 3;
   */
  entities: Entity[] = [];

  /**
   * The overall sentiment for the document. Populated if the user enables
   * [AnnotateTextRequest.Features.extract_document_sentiment][google.cloud.language.v1beta1.AnnotateTextRequest.Features.extract_document_sentiment].
   *
   * @generated from field: google.cloud.language.v1beta1.Sentiment document_sentiment = 4;
   */
  documentSentiment?: Sentiment;

  /**
   * The language of the text, which will be the same as the language specified
   * in the request or, if not specified, the automatically-detected language.
   * See [Document.language][google.cloud.language.v1beta1.Document.language] field for more details.
   *
   * @generated from field: string language = 5;
   */
  language = "";

  constructor(data?: PartialMessage<AnnotateTextResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.language.v1beta1.AnnotateTextResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sentences", kind: "message", T: Sentence, repeated: true },
    { no: 2, name: "tokens", kind: "message", T: Token, repeated: true },
    { no: 3, name: "entities", kind: "message", T: Entity, repeated: true },
    { no: 4, name: "document_sentiment", kind: "message", T: Sentiment },
    { no: 5, name: "language", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnnotateTextResponse {
    return new AnnotateTextResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnnotateTextResponse {
    return new AnnotateTextResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnnotateTextResponse {
    return new AnnotateTextResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AnnotateTextResponse | PlainMessage<AnnotateTextResponse> | undefined, b: AnnotateTextResponse | PlainMessage<AnnotateTextResponse> | undefined): boolean {
    return proto3.util.equals(AnnotateTextResponse, a, b);
  }
}

