// Copyright 2016 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/cloud/vision/v1/text_annotation.proto (package google.cloud.vision.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { BoundingPoly } from "./geometry_pb.js";

/**
 * TextAnnotation contains a structured representation of OCR extracted text.
 * The hierarchy of an OCR extracted text structure is like this:
 *     TextAnnotation -> Page -> Block -> Paragraph -> Word -> Symbol
 * Each structural component, starting from Page, may further have their own
 * properties. Properties describe detected languages, breaks etc.. Please
 * refer to the [google.cloud.vision.v1.TextAnnotation.TextProperty][google.cloud.vision.v1.TextAnnotation.TextProperty] message
 * definition below for more detail.
 *
 * @generated from message google.cloud.vision.v1.TextAnnotation
 */
export class TextAnnotation extends Message<TextAnnotation> {
  /**
   * List of pages detected by OCR.
   *
   * @generated from field: repeated google.cloud.vision.v1.Page pages = 1;
   */
  pages: Page[] = [];

  /**
   * UTF-8 text detected on the pages.
   *
   * @generated from field: string text = 2;
   */
  text = "";

  constructor(data?: PartialMessage<TextAnnotation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.vision.v1.TextAnnotation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "pages", kind: "message", T: Page, repeated: true },
    { no: 2, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextAnnotation {
    return new TextAnnotation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextAnnotation {
    return new TextAnnotation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextAnnotation {
    return new TextAnnotation().fromJsonString(jsonString, options);
  }

  static equals(a: TextAnnotation | PlainMessage<TextAnnotation> | undefined, b: TextAnnotation | PlainMessage<TextAnnotation> | undefined): boolean {
    return proto3.util.equals(TextAnnotation, a, b);
  }
}

/**
 * Detected language for a structural component.
 *
 * @generated from message google.cloud.vision.v1.TextAnnotation.DetectedLanguage
 */
export class TextAnnotation_DetectedLanguage extends Message<TextAnnotation_DetectedLanguage> {
  /**
   * The BCP-47 language code, such as "en-US" or "sr-Latn". For more
   * information, see
   * http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
   *
   * @generated from field: string language_code = 1;
   */
  languageCode = "";

  /**
   * Confidence of detected language. Range [0, 1].
   *
   * @generated from field: float confidence = 2;
   */
  confidence = 0;

  constructor(data?: PartialMessage<TextAnnotation_DetectedLanguage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.vision.v1.TextAnnotation.DetectedLanguage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "language_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "confidence", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextAnnotation_DetectedLanguage {
    return new TextAnnotation_DetectedLanguage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextAnnotation_DetectedLanguage {
    return new TextAnnotation_DetectedLanguage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextAnnotation_DetectedLanguage {
    return new TextAnnotation_DetectedLanguage().fromJsonString(jsonString, options);
  }

  static equals(a: TextAnnotation_DetectedLanguage | PlainMessage<TextAnnotation_DetectedLanguage> | undefined, b: TextAnnotation_DetectedLanguage | PlainMessage<TextAnnotation_DetectedLanguage> | undefined): boolean {
    return proto3.util.equals(TextAnnotation_DetectedLanguage, a, b);
  }
}

/**
 * Detected start or end of a structural component.
 *
 * @generated from message google.cloud.vision.v1.TextAnnotation.DetectedBreak
 */
export class TextAnnotation_DetectedBreak extends Message<TextAnnotation_DetectedBreak> {
  /**
   * @generated from field: google.cloud.vision.v1.TextAnnotation.DetectedBreak.BreakType type = 1;
   */
  type = TextAnnotation_DetectedBreak_BreakType.UNKNOWN;

  /**
   * True if break prepends the element.
   *
   * @generated from field: bool is_prefix = 2;
   */
  isPrefix = false;

  constructor(data?: PartialMessage<TextAnnotation_DetectedBreak>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.vision.v1.TextAnnotation.DetectedBreak";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(TextAnnotation_DetectedBreak_BreakType) },
    { no: 2, name: "is_prefix", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextAnnotation_DetectedBreak {
    return new TextAnnotation_DetectedBreak().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextAnnotation_DetectedBreak {
    return new TextAnnotation_DetectedBreak().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextAnnotation_DetectedBreak {
    return new TextAnnotation_DetectedBreak().fromJsonString(jsonString, options);
  }

  static equals(a: TextAnnotation_DetectedBreak | PlainMessage<TextAnnotation_DetectedBreak> | undefined, b: TextAnnotation_DetectedBreak | PlainMessage<TextAnnotation_DetectedBreak> | undefined): boolean {
    return proto3.util.equals(TextAnnotation_DetectedBreak, a, b);
  }
}

/**
 * Enum to denote the type of break found. New line, space etc.
 *
 * @generated from enum google.cloud.vision.v1.TextAnnotation.DetectedBreak.BreakType
 */
export enum TextAnnotation_DetectedBreak_BreakType {
  /**
   * Unknown break label type.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Regular space.
   *
   * @generated from enum value: SPACE = 1;
   */
  SPACE = 1,

  /**
   * Sure space (very wide).
   *
   * @generated from enum value: SURE_SPACE = 2;
   */
  SURE_SPACE = 2,

  /**
   * Line-wrapping break.
   *
   * @generated from enum value: EOL_SURE_SPACE = 3;
   */
  EOL_SURE_SPACE = 3,

  /**
   * End-line hyphen that is not present in text; does
   *
   * @generated from enum value: HYPHEN = 4;
   */
  HYPHEN = 4,

  /**
   * not co-occur with SPACE, LEADER_SPACE, or
   * LINE_BREAK.
   * Line break that ends a paragraph.
   *
   * @generated from enum value: LINE_BREAK = 5;
   */
  LINE_BREAK = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(TextAnnotation_DetectedBreak_BreakType)
proto3.util.setEnumType(TextAnnotation_DetectedBreak_BreakType, "google.cloud.vision.v1.TextAnnotation.DetectedBreak.BreakType", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "SPACE" },
  { no: 2, name: "SURE_SPACE" },
  { no: 3, name: "EOL_SURE_SPACE" },
  { no: 4, name: "HYPHEN" },
  { no: 5, name: "LINE_BREAK" },
]);

/**
 * Additional information detected on the structural component.
 *
 * @generated from message google.cloud.vision.v1.TextAnnotation.TextProperty
 */
export class TextAnnotation_TextProperty extends Message<TextAnnotation_TextProperty> {
  /**
   * A list of detected languages together with confidence.
   *
   * @generated from field: repeated google.cloud.vision.v1.TextAnnotation.DetectedLanguage detected_languages = 1;
   */
  detectedLanguages: TextAnnotation_DetectedLanguage[] = [];

  /**
   * Detected start or end of a text segment.
   *
   * @generated from field: google.cloud.vision.v1.TextAnnotation.DetectedBreak detected_break = 2;
   */
  detectedBreak?: TextAnnotation_DetectedBreak;

  constructor(data?: PartialMessage<TextAnnotation_TextProperty>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.vision.v1.TextAnnotation.TextProperty";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "detected_languages", kind: "message", T: TextAnnotation_DetectedLanguage, repeated: true },
    { no: 2, name: "detected_break", kind: "message", T: TextAnnotation_DetectedBreak },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TextAnnotation_TextProperty {
    return new TextAnnotation_TextProperty().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TextAnnotation_TextProperty {
    return new TextAnnotation_TextProperty().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TextAnnotation_TextProperty {
    return new TextAnnotation_TextProperty().fromJsonString(jsonString, options);
  }

  static equals(a: TextAnnotation_TextProperty | PlainMessage<TextAnnotation_TextProperty> | undefined, b: TextAnnotation_TextProperty | PlainMessage<TextAnnotation_TextProperty> | undefined): boolean {
    return proto3.util.equals(TextAnnotation_TextProperty, a, b);
  }
}

/**
 * Detected page from OCR.
 *
 * @generated from message google.cloud.vision.v1.Page
 */
export class Page extends Message<Page> {
  /**
   * Additional information detected on the page.
   *
   * @generated from field: google.cloud.vision.v1.TextAnnotation.TextProperty property = 1;
   */
  property?: TextAnnotation_TextProperty;

  /**
   * Page width in pixels.
   *
   * @generated from field: int32 width = 2;
   */
  width = 0;

  /**
   * Page height in pixels.
   *
   * @generated from field: int32 height = 3;
   */
  height = 0;

  /**
   * List of blocks of text, images etc on this page.
   *
   * @generated from field: repeated google.cloud.vision.v1.Block blocks = 4;
   */
  blocks: Block[] = [];

  constructor(data?: PartialMessage<Page>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.vision.v1.Page";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "property", kind: "message", T: TextAnnotation_TextProperty },
    { no: 2, name: "width", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "height", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "blocks", kind: "message", T: Block, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Page {
    return new Page().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Page {
    return new Page().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Page {
    return new Page().fromJsonString(jsonString, options);
  }

  static equals(a: Page | PlainMessage<Page> | undefined, b: Page | PlainMessage<Page> | undefined): boolean {
    return proto3.util.equals(Page, a, b);
  }
}

/**
 * Logical element on the page.
 *
 * @generated from message google.cloud.vision.v1.Block
 */
export class Block extends Message<Block> {
  /**
   * Additional information detected for the block.
   *
   * @generated from field: google.cloud.vision.v1.TextAnnotation.TextProperty property = 1;
   */
  property?: TextAnnotation_TextProperty;

  /**
   * The bounding box for the block.
   * The vertices are in the order of top-left, top-right, bottom-right,
   * bottom-left. When a rotation of the bounding box is detected the rotation
   * is represented as around the top-left corner as defined when the text is
   * read in the 'natural' orientation.
   * For example:
   *   * when the text is horizontal it might look like:
   *      0----1
   *      |    |
   *      3----2
   *   * when it's rotated 180 degrees around the top-left corner it becomes:
   *      2----3
   *      |    |
   *      1----0
   *   and the vertice order will still be (0, 1, 2, 3).
   *
   * @generated from field: google.cloud.vision.v1.BoundingPoly bounding_box = 2;
   */
  boundingBox?: BoundingPoly;

  /**
   * List of paragraphs in this block (if this blocks is of type text).
   *
   * @generated from field: repeated google.cloud.vision.v1.Paragraph paragraphs = 3;
   */
  paragraphs: Paragraph[] = [];

  /**
   * Detected block type (text, image etc) for this block.
   *
   * @generated from field: google.cloud.vision.v1.Block.BlockType block_type = 4;
   */
  blockType = Block_BlockType.UNKNOWN;

  constructor(data?: PartialMessage<Block>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.vision.v1.Block";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "property", kind: "message", T: TextAnnotation_TextProperty },
    { no: 2, name: "bounding_box", kind: "message", T: BoundingPoly },
    { no: 3, name: "paragraphs", kind: "message", T: Paragraph, repeated: true },
    { no: 4, name: "block_type", kind: "enum", T: proto3.getEnumType(Block_BlockType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Block {
    return new Block().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Block {
    return new Block().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Block {
    return new Block().fromJsonString(jsonString, options);
  }

  static equals(a: Block | PlainMessage<Block> | undefined, b: Block | PlainMessage<Block> | undefined): boolean {
    return proto3.util.equals(Block, a, b);
  }
}

/**
 * Type of a block (text, image etc) as identified by OCR.
 *
 * @generated from enum google.cloud.vision.v1.Block.BlockType
 */
export enum Block_BlockType {
  /**
   * Unknown block type.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Regular text block.
   *
   * @generated from enum value: TEXT = 1;
   */
  TEXT = 1,

  /**
   * Table block.
   *
   * @generated from enum value: TABLE = 2;
   */
  TABLE = 2,

  /**
   * Image block.
   *
   * @generated from enum value: PICTURE = 3;
   */
  PICTURE = 3,

  /**
   * Horizontal/vertical line box.
   *
   * @generated from enum value: RULER = 4;
   */
  RULER = 4,

  /**
   * Barcode block.
   *
   * @generated from enum value: BARCODE = 5;
   */
  BARCODE = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(Block_BlockType)
proto3.util.setEnumType(Block_BlockType, "google.cloud.vision.v1.Block.BlockType", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "TEXT" },
  { no: 2, name: "TABLE" },
  { no: 3, name: "PICTURE" },
  { no: 4, name: "RULER" },
  { no: 5, name: "BARCODE" },
]);

/**
 * Structural unit of text representing a number of words in certain order.
 *
 * @generated from message google.cloud.vision.v1.Paragraph
 */
export class Paragraph extends Message<Paragraph> {
  /**
   * Additional information detected for the paragraph.
   *
   * @generated from field: google.cloud.vision.v1.TextAnnotation.TextProperty property = 1;
   */
  property?: TextAnnotation_TextProperty;

  /**
   * The bounding box for the paragraph.
   * The vertices are in the order of top-left, top-right, bottom-right,
   * bottom-left. When a rotation of the bounding box is detected the rotation
   * is represented as around the top-left corner as defined when the text is
   * read in the 'natural' orientation.
   * For example:
   *   * when the text is horizontal it might look like:
   *      0----1
   *      |    |
   *      3----2
   *   * when it's rotated 180 degrees around the top-left corner it becomes:
   *      2----3
   *      |    |
   *      1----0
   *   and the vertice order will still be (0, 1, 2, 3).
   *
   * @generated from field: google.cloud.vision.v1.BoundingPoly bounding_box = 2;
   */
  boundingBox?: BoundingPoly;

  /**
   * List of words in this paragraph.
   *
   * @generated from field: repeated google.cloud.vision.v1.Word words = 3;
   */
  words: Word[] = [];

  constructor(data?: PartialMessage<Paragraph>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.vision.v1.Paragraph";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "property", kind: "message", T: TextAnnotation_TextProperty },
    { no: 2, name: "bounding_box", kind: "message", T: BoundingPoly },
    { no: 3, name: "words", kind: "message", T: Word, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Paragraph {
    return new Paragraph().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Paragraph {
    return new Paragraph().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Paragraph {
    return new Paragraph().fromJsonString(jsonString, options);
  }

  static equals(a: Paragraph | PlainMessage<Paragraph> | undefined, b: Paragraph | PlainMessage<Paragraph> | undefined): boolean {
    return proto3.util.equals(Paragraph, a, b);
  }
}

/**
 * A word representation.
 *
 * @generated from message google.cloud.vision.v1.Word
 */
export class Word extends Message<Word> {
  /**
   * Additional information detected for the word.
   *
   * @generated from field: google.cloud.vision.v1.TextAnnotation.TextProperty property = 1;
   */
  property?: TextAnnotation_TextProperty;

  /**
   * The bounding box for the word.
   * The vertices are in the order of top-left, top-right, bottom-right,
   * bottom-left. When a rotation of the bounding box is detected the rotation
   * is represented as around the top-left corner as defined when the text is
   * read in the 'natural' orientation.
   * For example:
   *   * when the text is horizontal it might look like:
   *      0----1
   *      |    |
   *      3----2
   *   * when it's rotated 180 degrees around the top-left corner it becomes:
   *      2----3
   *      |    |
   *      1----0
   *   and the vertice order will still be (0, 1, 2, 3).
   *
   * @generated from field: google.cloud.vision.v1.BoundingPoly bounding_box = 2;
   */
  boundingBox?: BoundingPoly;

  /**
   * List of symbols in the word.
   * The order of the symbols follows the natural reading order.
   *
   * @generated from field: repeated google.cloud.vision.v1.Symbol symbols = 3;
   */
  symbols: Symbol[] = [];

  constructor(data?: PartialMessage<Word>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.vision.v1.Word";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "property", kind: "message", T: TextAnnotation_TextProperty },
    { no: 2, name: "bounding_box", kind: "message", T: BoundingPoly },
    { no: 3, name: "symbols", kind: "message", T: Symbol, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Word {
    return new Word().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Word {
    return new Word().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Word {
    return new Word().fromJsonString(jsonString, options);
  }

  static equals(a: Word | PlainMessage<Word> | undefined, b: Word | PlainMessage<Word> | undefined): boolean {
    return proto3.util.equals(Word, a, b);
  }
}

/**
 * A single symbol representation.
 *
 * @generated from message google.cloud.vision.v1.Symbol
 */
export class Symbol extends Message<Symbol> {
  /**
   * Additional information detected for the symbol.
   *
   * @generated from field: google.cloud.vision.v1.TextAnnotation.TextProperty property = 1;
   */
  property?: TextAnnotation_TextProperty;

  /**
   * The bounding box for the symbol.
   * The vertices are in the order of top-left, top-right, bottom-right,
   * bottom-left. When a rotation of the bounding box is detected the rotation
   * is represented as around the top-left corner as defined when the text is
   * read in the 'natural' orientation.
   * For example:
   *   * when the text is horizontal it might look like:
   *      0----1
   *      |    |
   *      3----2
   *   * when it's rotated 180 degrees around the top-left corner it becomes:
   *      2----3
   *      |    |
   *      1----0
   *   and the vertice order will still be (0, 1, 2, 3).
   *
   * @generated from field: google.cloud.vision.v1.BoundingPoly bounding_box = 2;
   */
  boundingBox?: BoundingPoly;

  /**
   * The actual UTF-8 representation of the symbol.
   *
   * @generated from field: string text = 3;
   */
  text = "";

  constructor(data?: PartialMessage<Symbol>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.vision.v1.Symbol";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "property", kind: "message", T: TextAnnotation_TextProperty },
    { no: 2, name: "bounding_box", kind: "message", T: BoundingPoly },
    { no: 3, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Symbol {
    return new Symbol().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Symbol {
    return new Symbol().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Symbol {
    return new Symbol().fromJsonString(jsonString, options);
  }

  static equals(a: Symbol | PlainMessage<Symbol> | undefined, b: Symbol | PlainMessage<Symbol> | undefined): boolean {
    return proto3.util.equals(Symbol, a, b);
  }
}

