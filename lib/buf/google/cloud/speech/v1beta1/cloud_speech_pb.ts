// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/cloud/speech/v1beta1/cloud_speech.proto (package google.cloud.speech.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { Status } from "../../../rpc/status_pb.js";

/**
 * The top-level message sent by the client for the `SyncRecognize` method.
 *
 * @generated from message google.cloud.speech.v1beta1.SyncRecognizeRequest
 */
export class SyncRecognizeRequest extends Message<SyncRecognizeRequest> {
  /**
   * *Required* Provides information to the recognizer that specifies how to
   * process the request.
   *
   * @generated from field: google.cloud.speech.v1beta1.RecognitionConfig config = 1;
   */
  config?: RecognitionConfig;

  /**
   * *Required* The audio data to be recognized.
   *
   * @generated from field: google.cloud.speech.v1beta1.RecognitionAudio audio = 2;
   */
  audio?: RecognitionAudio;

  constructor(data?: PartialMessage<SyncRecognizeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.speech.v1beta1.SyncRecognizeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config", kind: "message", T: RecognitionConfig },
    { no: 2, name: "audio", kind: "message", T: RecognitionAudio },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncRecognizeRequest {
    return new SyncRecognizeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncRecognizeRequest {
    return new SyncRecognizeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncRecognizeRequest {
    return new SyncRecognizeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SyncRecognizeRequest | PlainMessage<SyncRecognizeRequest> | undefined, b: SyncRecognizeRequest | PlainMessage<SyncRecognizeRequest> | undefined): boolean {
    return proto3.util.equals(SyncRecognizeRequest, a, b);
  }
}

/**
 * The top-level message sent by the client for the `AsyncRecognize` method.
 *
 * @generated from message google.cloud.speech.v1beta1.AsyncRecognizeRequest
 */
export class AsyncRecognizeRequest extends Message<AsyncRecognizeRequest> {
  /**
   * *Required* Provides information to the recognizer that specifies how to
   * process the request.
   *
   * @generated from field: google.cloud.speech.v1beta1.RecognitionConfig config = 1;
   */
  config?: RecognitionConfig;

  /**
   * *Required* The audio data to be recognized.
   *
   * @generated from field: google.cloud.speech.v1beta1.RecognitionAudio audio = 2;
   */
  audio?: RecognitionAudio;

  constructor(data?: PartialMessage<AsyncRecognizeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.speech.v1beta1.AsyncRecognizeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config", kind: "message", T: RecognitionConfig },
    { no: 2, name: "audio", kind: "message", T: RecognitionAudio },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AsyncRecognizeRequest {
    return new AsyncRecognizeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AsyncRecognizeRequest {
    return new AsyncRecognizeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AsyncRecognizeRequest {
    return new AsyncRecognizeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AsyncRecognizeRequest | PlainMessage<AsyncRecognizeRequest> | undefined, b: AsyncRecognizeRequest | PlainMessage<AsyncRecognizeRequest> | undefined): boolean {
    return proto3.util.equals(AsyncRecognizeRequest, a, b);
  }
}

/**
 * The top-level message sent by the client for the `StreamingRecognize` method.
 * Multiple `StreamingRecognizeRequest` messages are sent. The first message
 * must contain a `streaming_config` message and must not contain `audio` data.
 * All subsequent messages must contain `audio` data and must not contain a
 * `streaming_config` message.
 *
 * @generated from message google.cloud.speech.v1beta1.StreamingRecognizeRequest
 */
export class StreamingRecognizeRequest extends Message<StreamingRecognizeRequest> {
  /**
   * The streaming request, which is either a streaming config or audio content.
   *
   * @generated from oneof google.cloud.speech.v1beta1.StreamingRecognizeRequest.streaming_request
   */
  streamingRequest: {
    /**
     * Provides information to the recognizer that specifies how to process the
     * request. The first `StreamingRecognizeRequest` message must contain a
     * `streaming_config`  message.
     *
     * @generated from field: google.cloud.speech.v1beta1.StreamingRecognitionConfig streaming_config = 1;
     */
    value: StreamingRecognitionConfig;
    case: "streamingConfig";
  } | {
    /**
     * The audio data to be recognized. Sequential chunks of audio data are sent
     * in sequential `StreamingRecognizeRequest` messages. The first
     * `StreamingRecognizeRequest` message must not contain `audio_content` data
     * and all subsequent `StreamingRecognizeRequest` messages must contain
     * `audio_content` data. The audio bytes must be encoded as specified in
     * `RecognitionConfig`. Note: as with all bytes fields, protobuffers use a
     * pure binary representation (not base64). See
     * [audio limits](https://cloud.google.com/speech/limits#content).
     *
     * @generated from field: bytes audio_content = 2;
     */
    value: Uint8Array;
    case: "audioContent";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StreamingRecognizeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.speech.v1beta1.StreamingRecognizeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "streaming_config", kind: "message", T: StreamingRecognitionConfig, oneof: "streaming_request" },
    { no: 2, name: "audio_content", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "streaming_request" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamingRecognizeRequest {
    return new StreamingRecognizeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamingRecognizeRequest {
    return new StreamingRecognizeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamingRecognizeRequest {
    return new StreamingRecognizeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamingRecognizeRequest | PlainMessage<StreamingRecognizeRequest> | undefined, b: StreamingRecognizeRequest | PlainMessage<StreamingRecognizeRequest> | undefined): boolean {
    return proto3.util.equals(StreamingRecognizeRequest, a, b);
  }
}

/**
 * Provides information to the recognizer that specifies how to process the
 * request.
 *
 * @generated from message google.cloud.speech.v1beta1.StreamingRecognitionConfig
 */
export class StreamingRecognitionConfig extends Message<StreamingRecognitionConfig> {
  /**
   * *Required* Provides information to the recognizer that specifies how to
   * process the request.
   *
   * @generated from field: google.cloud.speech.v1beta1.RecognitionConfig config = 1;
   */
  config?: RecognitionConfig;

  /**
   * *Optional* If `false` or omitted, the recognizer will perform continuous
   * recognition (continuing to wait for and process audio even if the user
   * pauses speaking) until the client closes the input stream (gRPC API) or
   * until the maximum time limit has been reached. May return multiple
   * `StreamingRecognitionResult`s with the `is_final` flag set to `true`.
   *
   * If `true`, the recognizer will detect a single spoken utterance. When it
   * detects that the user has paused or stopped speaking, it will return an
   * `END_OF_UTTERANCE` event and cease recognition. It will return no more than
   * one `StreamingRecognitionResult` with the `is_final` flag set to `true`.
   *
   * @generated from field: bool single_utterance = 2;
   */
  singleUtterance = false;

  /**
   * *Optional* If `true`, interim results (tentative hypotheses) may be
   * returned as they become available (these interim results are indicated with
   * the `is_final=false` flag).
   * If `false` or omitted, only `is_final=true` result(s) are returned.
   *
   * @generated from field: bool interim_results = 3;
   */
  interimResults = false;

  constructor(data?: PartialMessage<StreamingRecognitionConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.speech.v1beta1.StreamingRecognitionConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config", kind: "message", T: RecognitionConfig },
    { no: 2, name: "single_utterance", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "interim_results", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamingRecognitionConfig {
    return new StreamingRecognitionConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamingRecognitionConfig {
    return new StreamingRecognitionConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamingRecognitionConfig {
    return new StreamingRecognitionConfig().fromJsonString(jsonString, options);
  }

  static equals(a: StreamingRecognitionConfig | PlainMessage<StreamingRecognitionConfig> | undefined, b: StreamingRecognitionConfig | PlainMessage<StreamingRecognitionConfig> | undefined): boolean {
    return proto3.util.equals(StreamingRecognitionConfig, a, b);
  }
}

/**
 * Provides information to the recognizer that specifies how to process the
 * request.
 *
 * @generated from message google.cloud.speech.v1beta1.RecognitionConfig
 */
export class RecognitionConfig extends Message<RecognitionConfig> {
  /**
   * *Required* Encoding of audio data sent in all `RecognitionAudio` messages.
   *
   * @generated from field: google.cloud.speech.v1beta1.RecognitionConfig.AudioEncoding encoding = 1;
   */
  encoding = RecognitionConfig_AudioEncoding.ENCODING_UNSPECIFIED;

  /**
   * *Required* Sample rate in Hertz of the audio data sent in all
   * `RecognitionAudio` messages. Valid values are: 8000-48000.
   * 16000 is optimal. For best results, set the sampling rate of the audio
   * source to 16000 Hz. If that's not possible, use the native sample rate of
   * the audio source (instead of re-sampling).
   *
   * @generated from field: int32 sample_rate = 2;
   */
  sampleRate = 0;

  /**
   * *Optional* The language of the supplied audio as a BCP-47 language tag.
   * Example: "en-GB"  https://www.rfc-editor.org/rfc/bcp/bcp47.txt
   * If omitted, defaults to "en-US". See
   * [Language Support](https://cloud.google.com/speech/docs/languages)
   * for a list of the currently supported language codes.
   *
   * @generated from field: string language_code = 3;
   */
  languageCode = "";

  /**
   * *Optional* Maximum number of recognition hypotheses to be returned.
   * Specifically, the maximum number of `SpeechRecognitionAlternative` messages
   * within each `SpeechRecognitionResult`.
   * The server may return fewer than `max_alternatives`.
   * Valid values are `0`-`30`. A value of `0` or `1` will return a maximum of
   * one. If omitted, will return a maximum of one.
   *
   * @generated from field: int32 max_alternatives = 4;
   */
  maxAlternatives = 0;

  /**
   * *Optional* If set to `true`, the server will attempt to filter out
   * profanities, replacing all but the initial character in each filtered word
   * with asterisks, e.g. "f***". If set to `false` or omitted, profanities
   * won't be filtered out.
   *
   * @generated from field: bool profanity_filter = 5;
   */
  profanityFilter = false;

  /**
   * *Optional* A means to provide context to assist the speech recognition.
   *
   * @generated from field: google.cloud.speech.v1beta1.SpeechContext speech_context = 6;
   */
  speechContext?: SpeechContext;

  constructor(data?: PartialMessage<RecognitionConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.speech.v1beta1.RecognitionConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "encoding", kind: "enum", T: proto3.getEnumType(RecognitionConfig_AudioEncoding) },
    { no: 2, name: "sample_rate", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "language_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "max_alternatives", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "profanity_filter", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "speech_context", kind: "message", T: SpeechContext },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecognitionConfig {
    return new RecognitionConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecognitionConfig {
    return new RecognitionConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecognitionConfig {
    return new RecognitionConfig().fromJsonString(jsonString, options);
  }

  static equals(a: RecognitionConfig | PlainMessage<RecognitionConfig> | undefined, b: RecognitionConfig | PlainMessage<RecognitionConfig> | undefined): boolean {
    return proto3.util.equals(RecognitionConfig, a, b);
  }
}

/**
 * Audio encoding of the data sent in the audio message. All encodings support
 * only 1 channel (mono) audio. Only `FLAC` includes a header that describes
 * the bytes of audio that follow the header. The other encodings are raw
 * audio bytes with no header.
 *
 * For best results, the audio source should be captured and transmitted using
 * a lossless encoding (`FLAC` or `LINEAR16`). Recognition accuracy may be
 * reduced if lossy codecs (such as AMR, AMR_WB and MULAW) are used to capture
 * or transmit the audio, particularly if background noise is present.
 *
 * @generated from enum google.cloud.speech.v1beta1.RecognitionConfig.AudioEncoding
 */
export enum RecognitionConfig_AudioEncoding {
  /**
   * Not specified. Will return result [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT].
   *
   * @generated from enum value: ENCODING_UNSPECIFIED = 0;
   */
  ENCODING_UNSPECIFIED = 0,

  /**
   * Uncompressed 16-bit signed little-endian samples (Linear PCM).
   * This is the only encoding that may be used by `AsyncRecognize`.
   *
   * @generated from enum value: LINEAR16 = 1;
   */
  LINEAR16 = 1,

  /**
   * This is the recommended encoding for `SyncRecognize` and
   * `StreamingRecognize` because it uses lossless compression; therefore
   * recognition accuracy is not compromised by a lossy codec.
   *
   * The stream FLAC (Free Lossless Audio Codec) encoding is specified at:
   * http://flac.sourceforge.net/documentation.html.
   * 16-bit and 24-bit samples are supported.
   * Not all fields in STREAMINFO are supported.
   *
   * @generated from enum value: FLAC = 2;
   */
  FLAC = 2,

  /**
   * 8-bit samples that compand 14-bit audio samples using G.711 PCMU/mu-law.
   *
   * @generated from enum value: MULAW = 3;
   */
  MULAW = 3,

  /**
   * Adaptive Multi-Rate Narrowband codec. `sample_rate` must be 8000 Hz.
   *
   * @generated from enum value: AMR = 4;
   */
  AMR = 4,

  /**
   * Adaptive Multi-Rate Wideband codec. `sample_rate` must be 16000 Hz.
   *
   * @generated from enum value: AMR_WB = 5;
   */
  AMR_WB = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(RecognitionConfig_AudioEncoding)
proto3.util.setEnumType(RecognitionConfig_AudioEncoding, "google.cloud.speech.v1beta1.RecognitionConfig.AudioEncoding", [
  { no: 0, name: "ENCODING_UNSPECIFIED" },
  { no: 1, name: "LINEAR16" },
  { no: 2, name: "FLAC" },
  { no: 3, name: "MULAW" },
  { no: 4, name: "AMR" },
  { no: 5, name: "AMR_WB" },
]);

/**
 * Provides "hints" to the speech recognizer to favor specific words and phrases
 * in the results.
 *
 * @generated from message google.cloud.speech.v1beta1.SpeechContext
 */
export class SpeechContext extends Message<SpeechContext> {
  /**
   * *Optional* A list of strings containing words and phrases "hints" so that
   * the speech recognition is more likely to recognize them. This can be used
   * to improve the accuracy for specific words and phrases, for example, if
   * specific commands are typically spoken by the user. This can also be used
   * to add additional words to the vocabulary of the recognizer. See
   * [usage limits](https://cloud.google.com/speech/limits#content).
   *
   * @generated from field: repeated string phrases = 1;
   */
  phrases: string[] = [];

  constructor(data?: PartialMessage<SpeechContext>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.speech.v1beta1.SpeechContext";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "phrases", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpeechContext {
    return new SpeechContext().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpeechContext {
    return new SpeechContext().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpeechContext {
    return new SpeechContext().fromJsonString(jsonString, options);
  }

  static equals(a: SpeechContext | PlainMessage<SpeechContext> | undefined, b: SpeechContext | PlainMessage<SpeechContext> | undefined): boolean {
    return proto3.util.equals(SpeechContext, a, b);
  }
}

/**
 * Contains audio data in the encoding specified in the `RecognitionConfig`.
 * Either `content` or `uri` must be supplied. Supplying both or neither
 * returns [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT]. See
 * [audio limits](https://cloud.google.com/speech/limits#content).
 *
 * @generated from message google.cloud.speech.v1beta1.RecognitionAudio
 */
export class RecognitionAudio extends Message<RecognitionAudio> {
  /**
   * The audio source, which is either inline content or a GCS uri.
   *
   * @generated from oneof google.cloud.speech.v1beta1.RecognitionAudio.audio_source
   */
  audioSource: {
    /**
     * The audio data bytes encoded as specified in
     * `RecognitionConfig`. Note: as with all bytes fields, protobuffers use a
     * pure binary representation, whereas JSON representations use base64.
     *
     * @generated from field: bytes content = 1;
     */
    value: Uint8Array;
    case: "content";
  } | {
    /**
     * URI that points to a file that contains audio data bytes as specified in
     * `RecognitionConfig`. Currently, only Google Cloud Storage URIs are
     * supported, which must be specified in the following format:
     * `gs://bucket_name/object_name` (other URI formats return
     * [google.rpc.Code.INVALID_ARGUMENT][google.rpc.Code.INVALID_ARGUMENT]). For more information, see
     * [Request URIs](https://cloud.google.com/storage/docs/reference-uris).
     *
     * @generated from field: string uri = 2;
     */
    value: string;
    case: "uri";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<RecognitionAudio>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.speech.v1beta1.RecognitionAudio";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "content", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "audio_source" },
    { no: 2, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "audio_source" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecognitionAudio {
    return new RecognitionAudio().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecognitionAudio {
    return new RecognitionAudio().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecognitionAudio {
    return new RecognitionAudio().fromJsonString(jsonString, options);
  }

  static equals(a: RecognitionAudio | PlainMessage<RecognitionAudio> | undefined, b: RecognitionAudio | PlainMessage<RecognitionAudio> | undefined): boolean {
    return proto3.util.equals(RecognitionAudio, a, b);
  }
}

/**
 * The only message returned to the client by `SyncRecognize`. method. It
 * contains the result as zero or more sequential `SpeechRecognitionResult`
 * messages.
 *
 * @generated from message google.cloud.speech.v1beta1.SyncRecognizeResponse
 */
export class SyncRecognizeResponse extends Message<SyncRecognizeResponse> {
  /**
   * *Output-only* Sequential list of transcription results corresponding to
   * sequential portions of audio.
   *
   * @generated from field: repeated google.cloud.speech.v1beta1.SpeechRecognitionResult results = 2;
   */
  results: SpeechRecognitionResult[] = [];

  constructor(data?: PartialMessage<SyncRecognizeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.speech.v1beta1.SyncRecognizeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "results", kind: "message", T: SpeechRecognitionResult, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SyncRecognizeResponse {
    return new SyncRecognizeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SyncRecognizeResponse {
    return new SyncRecognizeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SyncRecognizeResponse {
    return new SyncRecognizeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SyncRecognizeResponse | PlainMessage<SyncRecognizeResponse> | undefined, b: SyncRecognizeResponse | PlainMessage<SyncRecognizeResponse> | undefined): boolean {
    return proto3.util.equals(SyncRecognizeResponse, a, b);
  }
}

/**
 * The only message returned to the client by `AsyncRecognize`. It contains the
 * result as zero or more sequential `SpeechRecognitionResult` messages. It is
 * included in the `result.response` field of the `Operation` returned by the
 * `GetOperation` call of the `google::longrunning::Operations` service.
 *
 * @generated from message google.cloud.speech.v1beta1.AsyncRecognizeResponse
 */
export class AsyncRecognizeResponse extends Message<AsyncRecognizeResponse> {
  /**
   * *Output-only* Sequential list of transcription results corresponding to
   * sequential portions of audio.
   *
   * @generated from field: repeated google.cloud.speech.v1beta1.SpeechRecognitionResult results = 2;
   */
  results: SpeechRecognitionResult[] = [];

  constructor(data?: PartialMessage<AsyncRecognizeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.speech.v1beta1.AsyncRecognizeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "results", kind: "message", T: SpeechRecognitionResult, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AsyncRecognizeResponse {
    return new AsyncRecognizeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AsyncRecognizeResponse {
    return new AsyncRecognizeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AsyncRecognizeResponse {
    return new AsyncRecognizeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AsyncRecognizeResponse | PlainMessage<AsyncRecognizeResponse> | undefined, b: AsyncRecognizeResponse | PlainMessage<AsyncRecognizeResponse> | undefined): boolean {
    return proto3.util.equals(AsyncRecognizeResponse, a, b);
  }
}

/**
 * Describes the progress of a long-running `AsyncRecognize` call. It is
 * included in the `metadata` field of the `Operation` returned by the
 * `GetOperation` call of the `google::longrunning::Operations` service.
 *
 * @generated from message google.cloud.speech.v1beta1.AsyncRecognizeMetadata
 */
export class AsyncRecognizeMetadata extends Message<AsyncRecognizeMetadata> {
  /**
   * Approximate percentage of audio processed thus far. Guaranteed to be 100
   * when the audio is fully processed and the results are available.
   *
   * @generated from field: int32 progress_percent = 1;
   */
  progressPercent = 0;

  /**
   * Time when the request was received.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 2;
   */
  startTime?: Timestamp;

  /**
   * Time of the most recent processing update.
   *
   * @generated from field: google.protobuf.Timestamp last_update_time = 3;
   */
  lastUpdateTime?: Timestamp;

  constructor(data?: PartialMessage<AsyncRecognizeMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.speech.v1beta1.AsyncRecognizeMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "progress_percent", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "start_time", kind: "message", T: Timestamp },
    { no: 3, name: "last_update_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AsyncRecognizeMetadata {
    return new AsyncRecognizeMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AsyncRecognizeMetadata {
    return new AsyncRecognizeMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AsyncRecognizeMetadata {
    return new AsyncRecognizeMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: AsyncRecognizeMetadata | PlainMessage<AsyncRecognizeMetadata> | undefined, b: AsyncRecognizeMetadata | PlainMessage<AsyncRecognizeMetadata> | undefined): boolean {
    return proto3.util.equals(AsyncRecognizeMetadata, a, b);
  }
}

/**
 * `StreamingRecognizeResponse` is the only message returned to the client by
 * `StreamingRecognize`. A series of one or more `StreamingRecognizeResponse`
 * messages are streamed back to the client.
 *
 * Here's an example of a series of ten `StreamingRecognizeResponse`s that might
 * be returned while processing audio:
 *
 * 1. endpointer_type: START_OF_SPEECH
 *
 * 2. results { alternatives { transcript: "tube" } stability: 0.01 }
 *    result_index: 0
 *
 * 3. results { alternatives { transcript: "to be a" } stability: 0.01 }
 *    result_index: 0
 *
 * 4. results { alternatives { transcript: "to be" } stability: 0.9 }
 *    results { alternatives { transcript: " or not to be" } stability: 0.01 }
 *    result_index: 0
 *
 * 5. results { alternatives { transcript: "to be or not to be"
 *                             confidence: 0.92 }
 *              alternatives { transcript: "to bee or not to bee" }
 *              is_final: true }
 *    result_index: 0
 *
 * 6. results { alternatives { transcript: " that's" } stability: 0.01 }
 *    result_index: 1
 *
 * 7. results { alternatives { transcript: " that is" } stability: 0.9 }
 *    results { alternatives { transcript: " the question" } stability: 0.01 }
 *    result_index: 1
 *
 * 8. endpointer_type: END_OF_SPEECH
 *
 * 9. results { alternatives { transcript: " that is the question"
 *                             confidence: 0.98 }
 *              alternatives { transcript: " that was the question" }
 *              is_final: true }
 *    result_index: 1
 *
 * 10. endpointer_type: END_OF_AUDIO
 *
 * Notes:
 *
 * - Only two of the above responses #5 and #9 contain final results, they are
 *   indicated by `is_final: true`. Concatenating these together generates the
 *   full transcript: "to be or not to be that is the question".
 *
 * - The others contain interim `results`. #4 and #7 contain two interim
 *   `results`, the first portion has a high stability and is less likely to
 *   change, the second portion has a low stability and is very likely to
 *   change. A UI designer might choose to show only high stability `results`.
 *
 * - The specific `stability` and `confidence` values shown above are only for
 *   illustrative purposes. Actual values may vary.
 *
 * - The `result_index` indicates the portion of audio that has had final
 *   results returned, and is no longer being processed. For example, the
 *   `results` in #6 and later correspond to the portion of audio after
 *   "to be or not to be".
 *
 * @generated from message google.cloud.speech.v1beta1.StreamingRecognizeResponse
 */
export class StreamingRecognizeResponse extends Message<StreamingRecognizeResponse> {
  /**
   * *Output-only* If set, returns a [google.rpc.Status][google.rpc.Status] message that
   * specifies the error for the operation.
   *
   * @generated from field: google.rpc.Status error = 1;
   */
  error?: Status;

  /**
   * *Output-only* This repeated list contains zero or more results that
   * correspond to consecutive portions of the audio currently being processed.
   * It contains zero or one `is_final=true` result (the newly settled portion),
   * followed by zero or more `is_final=false` results.
   *
   * @generated from field: repeated google.cloud.speech.v1beta1.StreamingRecognitionResult results = 2;
   */
  results: StreamingRecognitionResult[] = [];

  /**
   * *Output-only* Indicates the lowest index in the `results` array that has
   * changed. The repeated `StreamingRecognitionResult` results overwrite past
   * results at this index and higher.
   *
   * @generated from field: int32 result_index = 3;
   */
  resultIndex = 0;

  /**
   * *Output-only* Indicates the type of endpointer event.
   *
   * @generated from field: google.cloud.speech.v1beta1.StreamingRecognizeResponse.EndpointerType endpointer_type = 4;
   */
  endpointerType = StreamingRecognizeResponse_EndpointerType.ENDPOINTER_EVENT_UNSPECIFIED;

  constructor(data?: PartialMessage<StreamingRecognizeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.speech.v1beta1.StreamingRecognizeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "error", kind: "message", T: Status },
    { no: 2, name: "results", kind: "message", T: StreamingRecognitionResult, repeated: true },
    { no: 3, name: "result_index", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "endpointer_type", kind: "enum", T: proto3.getEnumType(StreamingRecognizeResponse_EndpointerType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamingRecognizeResponse {
    return new StreamingRecognizeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamingRecognizeResponse {
    return new StreamingRecognizeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamingRecognizeResponse {
    return new StreamingRecognizeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StreamingRecognizeResponse | PlainMessage<StreamingRecognizeResponse> | undefined, b: StreamingRecognizeResponse | PlainMessage<StreamingRecognizeResponse> | undefined): boolean {
    return proto3.util.equals(StreamingRecognizeResponse, a, b);
  }
}

/**
 * Indicates the type of endpointer event.
 *
 * @generated from enum google.cloud.speech.v1beta1.StreamingRecognizeResponse.EndpointerType
 */
export enum StreamingRecognizeResponse_EndpointerType {
  /**
   * No endpointer event specified.
   *
   * @generated from enum value: ENDPOINTER_EVENT_UNSPECIFIED = 0;
   */
  ENDPOINTER_EVENT_UNSPECIFIED = 0,

  /**
   * Speech has been detected in the audio stream, and the service is
   * beginning to process it.
   *
   * @generated from enum value: START_OF_SPEECH = 1;
   */
  START_OF_SPEECH = 1,

  /**
   * Speech has ceased to be detected in the audio stream. (For example, the
   * user may have paused after speaking.) If `single_utterance` is `false`,
   * the service will continue to process audio, and if subsequent speech is
   * detected, will send another START_OF_SPEECH event.
   *
   * @generated from enum value: END_OF_SPEECH = 2;
   */
  END_OF_SPEECH = 2,

  /**
   * This event is sent after the client has half-closed the input stream gRPC
   * connection and the server has received all of the audio. (The server may
   * still be processing the audio and may subsequently return additional
   * results.)
   *
   * @generated from enum value: END_OF_AUDIO = 3;
   */
  END_OF_AUDIO = 3,

  /**
   * This event is only sent when `single_utterance` is `true`. It indicates
   * that the server has detected the end of the user's speech utterance and
   * expects no additional speech. Therefore, the server will not process
   * additional audio (although it may subsequently return additional
   * results). The client should stop sending additional audio data,
   * half-close the gRPC connection, and wait for any additional results
   * until the server closes the gRPC connection.
   *
   * @generated from enum value: END_OF_UTTERANCE = 4;
   */
  END_OF_UTTERANCE = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(StreamingRecognizeResponse_EndpointerType)
proto3.util.setEnumType(StreamingRecognizeResponse_EndpointerType, "google.cloud.speech.v1beta1.StreamingRecognizeResponse.EndpointerType", [
  { no: 0, name: "ENDPOINTER_EVENT_UNSPECIFIED" },
  { no: 1, name: "START_OF_SPEECH" },
  { no: 2, name: "END_OF_SPEECH" },
  { no: 3, name: "END_OF_AUDIO" },
  { no: 4, name: "END_OF_UTTERANCE" },
]);

/**
 * A streaming speech recognition result corresponding to a portion of the audio
 * that is currently being processed.
 *
 * @generated from message google.cloud.speech.v1beta1.StreamingRecognitionResult
 */
export class StreamingRecognitionResult extends Message<StreamingRecognitionResult> {
  /**
   * *Output-only* May contain one or more recognition hypotheses (up to the
   * maximum specified in `max_alternatives`).
   *
   * @generated from field: repeated google.cloud.speech.v1beta1.SpeechRecognitionAlternative alternatives = 1;
   */
  alternatives: SpeechRecognitionAlternative[] = [];

  /**
   * *Output-only* If `false`, this `StreamingRecognitionResult` represents an
   * interim result that may change. If `true`, this is the final time the
   * speech service will return this particular `StreamingRecognitionResult`,
   * the recognizer will not return any further hypotheses for this portion of
   * the transcript and corresponding audio.
   *
   * @generated from field: bool is_final = 2;
   */
  isFinal = false;

  /**
   * *Output-only* An estimate of the likelihood that the recognizer will not
   * change its guess about this interim result. Values range from 0.0
   * (completely unstable) to 1.0 (completely stable).
   * This field is only provided for interim results (`is_final=false`).
   * The default of 0.0 is a sentinel value indicating `stability` was not set.
   *
   * @generated from field: float stability = 3;
   */
  stability = 0;

  constructor(data?: PartialMessage<StreamingRecognitionResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.speech.v1beta1.StreamingRecognitionResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "alternatives", kind: "message", T: SpeechRecognitionAlternative, repeated: true },
    { no: 2, name: "is_final", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "stability", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamingRecognitionResult {
    return new StreamingRecognitionResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamingRecognitionResult {
    return new StreamingRecognitionResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamingRecognitionResult {
    return new StreamingRecognitionResult().fromJsonString(jsonString, options);
  }

  static equals(a: StreamingRecognitionResult | PlainMessage<StreamingRecognitionResult> | undefined, b: StreamingRecognitionResult | PlainMessage<StreamingRecognitionResult> | undefined): boolean {
    return proto3.util.equals(StreamingRecognitionResult, a, b);
  }
}

/**
 * A speech recognition result corresponding to a portion of the audio.
 *
 * @generated from message google.cloud.speech.v1beta1.SpeechRecognitionResult
 */
export class SpeechRecognitionResult extends Message<SpeechRecognitionResult> {
  /**
   * *Output-only* May contain one or more recognition hypotheses (up to the
   * maximum specified in `max_alternatives`).
   *
   * @generated from field: repeated google.cloud.speech.v1beta1.SpeechRecognitionAlternative alternatives = 1;
   */
  alternatives: SpeechRecognitionAlternative[] = [];

  constructor(data?: PartialMessage<SpeechRecognitionResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.speech.v1beta1.SpeechRecognitionResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "alternatives", kind: "message", T: SpeechRecognitionAlternative, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpeechRecognitionResult {
    return new SpeechRecognitionResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpeechRecognitionResult {
    return new SpeechRecognitionResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpeechRecognitionResult {
    return new SpeechRecognitionResult().fromJsonString(jsonString, options);
  }

  static equals(a: SpeechRecognitionResult | PlainMessage<SpeechRecognitionResult> | undefined, b: SpeechRecognitionResult | PlainMessage<SpeechRecognitionResult> | undefined): boolean {
    return proto3.util.equals(SpeechRecognitionResult, a, b);
  }
}

/**
 * Alternative hypotheses (a.k.a. n-best list).
 *
 * @generated from message google.cloud.speech.v1beta1.SpeechRecognitionAlternative
 */
export class SpeechRecognitionAlternative extends Message<SpeechRecognitionAlternative> {
  /**
   * *Output-only* Transcript text representing the words that the user spoke.
   *
   * @generated from field: string transcript = 1;
   */
  transcript = "";

  /**
   * *Output-only* The confidence estimate between 0.0 and 1.0. A higher number
   * indicates an estimated greater likelihood that the recognized words are
   * correct. This field is typically provided only for the top hypothesis, and
   * only for `is_final=true` results. Clients should not rely on the
   * `confidence` field as it is not guaranteed to be accurate, or even set, in
   * any of the results.
   * The default of 0.0 is a sentinel value indicating `confidence` was not set.
   *
   * @generated from field: float confidence = 2;
   */
  confidence = 0;

  constructor(data?: PartialMessage<SpeechRecognitionAlternative>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.speech.v1beta1.SpeechRecognitionAlternative";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transcript", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "confidence", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpeechRecognitionAlternative {
    return new SpeechRecognitionAlternative().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpeechRecognitionAlternative {
    return new SpeechRecognitionAlternative().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpeechRecognitionAlternative {
    return new SpeechRecognitionAlternative().fromJsonString(jsonString, options);
  }

  static equals(a: SpeechRecognitionAlternative | PlainMessage<SpeechRecognitionAlternative> | undefined, b: SpeechRecognitionAlternative | PlainMessage<SpeechRecognitionAlternative> | undefined): boolean {
    return proto3.util.equals(SpeechRecognitionAlternative, a, b);
  }
}

