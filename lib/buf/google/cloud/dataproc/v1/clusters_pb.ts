// Copyright 2016 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/cloud/dataproc/v1/clusters.proto (package google.cloud.dataproc.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, FieldMask, Message, proto3, Timestamp } from "@bufbuild/protobuf";

/**
 * Describes the identifying information, config, and status of
 * a cluster of Google Compute Engine instances.
 *
 * @generated from message google.cloud.dataproc.v1.Cluster
 */
export class Cluster extends Message<Cluster> {
  /**
   * [Required] The Google Cloud Platform project ID that the cluster belongs to.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * [Required] The cluster name. Cluster names within a project must be
   * unique. Names of deleted clusters can be reused.
   *
   * @generated from field: string cluster_name = 2;
   */
  clusterName = "";

  /**
   * [Required] The cluster config. Note that Cloud Dataproc may set
   * default values, and values may change when clusters are updated.
   *
   * @generated from field: google.cloud.dataproc.v1.ClusterConfig config = 3;
   */
  config?: ClusterConfig;

  /**
   * [Output-only] Cluster status.
   *
   * @generated from field: google.cloud.dataproc.v1.ClusterStatus status = 4;
   */
  status?: ClusterStatus;

  /**
   * [Output-only] The previous cluster status.
   *
   * @generated from field: repeated google.cloud.dataproc.v1.ClusterStatus status_history = 7;
   */
  statusHistory: ClusterStatus[] = [];

  /**
   * [Output-only] A cluster UUID (Unique Universal Identifier). Cloud Dataproc
   * generates this value when it creates the cluster.
   *
   * @generated from field: string cluster_uuid = 6;
   */
  clusterUuid = "";

  constructor(data?: PartialMessage<Cluster>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.dataproc.v1.Cluster";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cluster_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "config", kind: "message", T: ClusterConfig },
    { no: 4, name: "status", kind: "message", T: ClusterStatus },
    { no: 7, name: "status_history", kind: "message", T: ClusterStatus, repeated: true },
    { no: 6, name: "cluster_uuid", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Cluster {
    return new Cluster().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Cluster {
    return new Cluster().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Cluster {
    return new Cluster().fromJsonString(jsonString, options);
  }

  static equals(a: Cluster | PlainMessage<Cluster> | undefined, b: Cluster | PlainMessage<Cluster> | undefined): boolean {
    return proto3.util.equals(Cluster, a, b);
  }
}

/**
 * The cluster config.
 *
 * @generated from message google.cloud.dataproc.v1.ClusterConfig
 */
export class ClusterConfig extends Message<ClusterConfig> {
  /**
   * [Optional] A Google Cloud Storage staging bucket used for sharing generated
   * SSH keys and config. If you do not specify a staging bucket, Cloud
   * Dataproc will determine an appropriate Cloud Storage location (US,
   * ASIA, or EU) for your cluster's staging bucket according to the Google
   * Compute Engine zone where your cluster is deployed, and then it will create
   * and manage this project-level, per-location bucket for you.
   *
   * @generated from field: string config_bucket = 1;
   */
  configBucket = "";

  /**
   * [Required] The shared Google Compute Engine config settings for
   * all instances in a cluster.
   *
   * @generated from field: google.cloud.dataproc.v1.GceClusterConfig gce_cluster_config = 8;
   */
  gceClusterConfig?: GceClusterConfig;

  /**
   * [Optional] The Google Compute Engine config settings for
   * the master instance in a cluster.
   *
   * @generated from field: google.cloud.dataproc.v1.InstanceGroupConfig master_config = 9;
   */
  masterConfig?: InstanceGroupConfig;

  /**
   * [Optional] The Google Compute Engine config settings for
   * worker instances in a cluster.
   *
   * @generated from field: google.cloud.dataproc.v1.InstanceGroupConfig worker_config = 10;
   */
  workerConfig?: InstanceGroupConfig;

  /**
   * [Optional] The Google Compute Engine config settings for
   * additional worker instances in a cluster.
   *
   * @generated from field: google.cloud.dataproc.v1.InstanceGroupConfig secondary_worker_config = 12;
   */
  secondaryWorkerConfig?: InstanceGroupConfig;

  /**
   * [Optional] The config settings for software inside the cluster.
   *
   * @generated from field: google.cloud.dataproc.v1.SoftwareConfig software_config = 13;
   */
  softwareConfig?: SoftwareConfig;

  /**
   * [Optional] Commands to execute on each node after config is
   * completed. By default, executables are run on master and all worker nodes.
   * You can test a node's <code>role</code> metadata to run an executable on
   * a master or worker node, as shown below using `curl` (you can also use `wget`):
   *
   *     ROLE=$(curl -H Metadata-Flavor:Google http://metadata/computeMetadata/v1/instance/attributes/dataproc-role)
   *     if [[ "${ROLE}" == 'Master' ]]; then
   *       ... master specific actions ...
   *     else
   *       ... worker specific actions ...
   *     fi
   *
   * @generated from field: repeated google.cloud.dataproc.v1.NodeInitializationAction initialization_actions = 11;
   */
  initializationActions: NodeInitializationAction[] = [];

  constructor(data?: PartialMessage<ClusterConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.dataproc.v1.ClusterConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config_bucket", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "gce_cluster_config", kind: "message", T: GceClusterConfig },
    { no: 9, name: "master_config", kind: "message", T: InstanceGroupConfig },
    { no: 10, name: "worker_config", kind: "message", T: InstanceGroupConfig },
    { no: 12, name: "secondary_worker_config", kind: "message", T: InstanceGroupConfig },
    { no: 13, name: "software_config", kind: "message", T: SoftwareConfig },
    { no: 11, name: "initialization_actions", kind: "message", T: NodeInitializationAction, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterConfig {
    return new ClusterConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterConfig {
    return new ClusterConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterConfig {
    return new ClusterConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterConfig | PlainMessage<ClusterConfig> | undefined, b: ClusterConfig | PlainMessage<ClusterConfig> | undefined): boolean {
    return proto3.util.equals(ClusterConfig, a, b);
  }
}

/**
 * Common config settings for resources of Google Compute Engine cluster
 * instances, applicable to all instances in the cluster.
 *
 * @generated from message google.cloud.dataproc.v1.GceClusterConfig
 */
export class GceClusterConfig extends Message<GceClusterConfig> {
  /**
   * [Required] The zone where the Google Compute Engine cluster will be located.
   * Example: `https://www.googleapis.com/compute/v1/projects/[project_id]/zones/[zone]`.
   *
   * @generated from field: string zone_uri = 1;
   */
  zoneUri = "";

  /**
   * [Optional] The Google Compute Engine network to be used for machine
   * communications. Cannot be specified with subnetwork_uri. If neither
   * `network_uri` nor `subnetwork_uri` is specified, the "default" network of
   * the project is used, if it exists. Cannot be a "Custom Subnet Network" (see
   * [Using Subnetworks](/compute/docs/subnetworks) for more information).
   * Example: `https://www.googleapis.com/compute/v1/projects/[project_id]/regions/global/default`.
   *
   * @generated from field: string network_uri = 2;
   */
  networkUri = "";

  /**
   * [Optional] The Google Compute Engine subnetwork to be used for machine
   * communications. Cannot be specified with network_uri.
   * Example: `https://www.googleapis.com/compute/v1/projects/[project_id]/regions/us-east1/sub0`.
   *
   * @generated from field: string subnetwork_uri = 6;
   */
  subnetworkUri = "";

  /**
   * [Optional] If true, all instances in the cluster will only have internal IP
   * addresses. By default, clusters are not restricted to internal IP addresses,
   * and will have ephemeral external IP addresses assigned to each instance.
   * This `internal_ip_only` restriction can only be enabled for subnetwork
   * enabled networks, and all off-cluster dependencies must be configured to be
   * accessible without external IP addresses.
   *
   * @generated from field: bool internal_ip_only = 7;
   */
  internalIpOnly = false;

  /**
   * [Optional] The URIs of service account scopes to be included in Google
   * Compute Engine instances. The following base set of scopes is always
   * included:
   *
   * * https://www.googleapis.com/auth/cloud.useraccounts.readonly
   * * https://www.googleapis.com/auth/devstorage.read_write
   * * https://www.googleapis.com/auth/logging.write
   *
   * If no scopes are specified, the following defaults are also provided:
   *
   * * https://www.googleapis.com/auth/bigquery
   * * https://www.googleapis.com/auth/bigtable.admin.table
   * * https://www.googleapis.com/auth/bigtable.data
   * * https://www.googleapis.com/auth/devstorage.full_control
   *
   * @generated from field: repeated string service_account_scopes = 3;
   */
  serviceAccountScopes: string[] = [];

  /**
   * The Google Compute Engine tags to add to all instances (see
   * [Labeling instances](/compute/docs/label-or-tag-resources#labeling_instances)).
   *
   * @generated from field: repeated string tags = 4;
   */
  tags: string[] = [];

  /**
   * The Google Compute Engine metadata entries to add to all instances (see
   * [Project and instance metadata](https://cloud.google.com/compute/docs/storing-retrieving-metadata#project_and_instance_metadata)).
   *
   * @generated from field: map<string, string> metadata = 5;
   */
  metadata: { [key: string]: string } = {};

  constructor(data?: PartialMessage<GceClusterConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.dataproc.v1.GceClusterConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "zone_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "network_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "subnetwork_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "internal_ip_only", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "service_account_scopes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "tags", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GceClusterConfig {
    return new GceClusterConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GceClusterConfig {
    return new GceClusterConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GceClusterConfig {
    return new GceClusterConfig().fromJsonString(jsonString, options);
  }

  static equals(a: GceClusterConfig | PlainMessage<GceClusterConfig> | undefined, b: GceClusterConfig | PlainMessage<GceClusterConfig> | undefined): boolean {
    return proto3.util.equals(GceClusterConfig, a, b);
  }
}

/**
 * [Optional] The config settings for Google Compute Engine resources in
 * an instance group, such as a master or worker group.
 *
 * @generated from message google.cloud.dataproc.v1.InstanceGroupConfig
 */
export class InstanceGroupConfig extends Message<InstanceGroupConfig> {
  /**
   * [Required] The number of VM instances in the instance group.
   * For master instance groups, must be set to 1.
   *
   * @generated from field: int32 num_instances = 1;
   */
  numInstances = 0;

  /**
   * [Optional] The list of instance names. Cloud Dataproc derives the names from
   * `cluster_name`, `num_instances`, and the instance group if not set by user
   * (recommended practice is to let Cloud Dataproc derive the name).
   *
   * @generated from field: repeated string instance_names = 2;
   */
  instanceNames: string[] = [];

  /**
   * [Output-only] The Google Compute Engine image resource used for cluster
   * instances. Inferred from `SoftwareConfig.image_version`.
   *
   * @generated from field: string image_uri = 3;
   */
  imageUri = "";

  /**
   * [Required] The Google Compute Engine machine type used for cluster instances.
   * Example: `https://www.googleapis.com/compute/v1/projects/[project_id]/zones/us-east1-a/machineTypes/n1-standard-2`.
   *
   * @generated from field: string machine_type_uri = 4;
   */
  machineTypeUri = "";

  /**
   * [Optional] Disk option config settings.
   *
   * @generated from field: google.cloud.dataproc.v1.DiskConfig disk_config = 5;
   */
  diskConfig?: DiskConfig;

  /**
   * [Optional] Specifies that this instance group contains preemptible instances.
   *
   * @generated from field: bool is_preemptible = 6;
   */
  isPreemptible = false;

  /**
   * [Output-only] The config for Google Compute Engine Instance Group
   * Manager that manages this group.
   * This is only used for preemptible instance groups.
   *
   * @generated from field: google.cloud.dataproc.v1.ManagedGroupConfig managed_group_config = 7;
   */
  managedGroupConfig?: ManagedGroupConfig;

  constructor(data?: PartialMessage<InstanceGroupConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.dataproc.v1.InstanceGroupConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "num_instances", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "instance_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "image_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "machine_type_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "disk_config", kind: "message", T: DiskConfig },
    { no: 6, name: "is_preemptible", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "managed_group_config", kind: "message", T: ManagedGroupConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InstanceGroupConfig {
    return new InstanceGroupConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InstanceGroupConfig {
    return new InstanceGroupConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InstanceGroupConfig {
    return new InstanceGroupConfig().fromJsonString(jsonString, options);
  }

  static equals(a: InstanceGroupConfig | PlainMessage<InstanceGroupConfig> | undefined, b: InstanceGroupConfig | PlainMessage<InstanceGroupConfig> | undefined): boolean {
    return proto3.util.equals(InstanceGroupConfig, a, b);
  }
}

/**
 * Specifies the resources used to actively manage an instance group.
 *
 * @generated from message google.cloud.dataproc.v1.ManagedGroupConfig
 */
export class ManagedGroupConfig extends Message<ManagedGroupConfig> {
  /**
   * [Output-only] The name of the Instance Template used for the Managed
   * Instance Group.
   *
   * @generated from field: string instance_template_name = 1;
   */
  instanceTemplateName = "";

  /**
   * [Output-only] The name of the Instance Group Manager for this group.
   *
   * @generated from field: string instance_group_manager_name = 2;
   */
  instanceGroupManagerName = "";

  constructor(data?: PartialMessage<ManagedGroupConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.dataproc.v1.ManagedGroupConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_template_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "instance_group_manager_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ManagedGroupConfig {
    return new ManagedGroupConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ManagedGroupConfig {
    return new ManagedGroupConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ManagedGroupConfig {
    return new ManagedGroupConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ManagedGroupConfig | PlainMessage<ManagedGroupConfig> | undefined, b: ManagedGroupConfig | PlainMessage<ManagedGroupConfig> | undefined): boolean {
    return proto3.util.equals(ManagedGroupConfig, a, b);
  }
}

/**
 * Specifies the config of disk options for a group of VM instances.
 *
 * @generated from message google.cloud.dataproc.v1.DiskConfig
 */
export class DiskConfig extends Message<DiskConfig> {
  /**
   * [Optional] Size in GB of the boot disk (default is 500GB).
   *
   * @generated from field: int32 boot_disk_size_gb = 1;
   */
  bootDiskSizeGb = 0;

  /**
   * [Optional] Number of attached SSDs, from 0 to 4 (default is 0).
   * If SSDs are not attached, the boot disk is used to store runtime logs and
   * [HDFS](https://hadoop.apache.org/docs/r1.2.1/hdfs_user_guide.html) data.
   * If one or more SSDs are attached, this runtime bulk
   * data is spread across them, and the boot disk contains only basic
   * config and installed binaries.
   *
   * @generated from field: int32 num_local_ssds = 2;
   */
  numLocalSsds = 0;

  constructor(data?: PartialMessage<DiskConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.dataproc.v1.DiskConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "boot_disk_size_gb", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "num_local_ssds", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiskConfig {
    return new DiskConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiskConfig {
    return new DiskConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiskConfig {
    return new DiskConfig().fromJsonString(jsonString, options);
  }

  static equals(a: DiskConfig | PlainMessage<DiskConfig> | undefined, b: DiskConfig | PlainMessage<DiskConfig> | undefined): boolean {
    return proto3.util.equals(DiskConfig, a, b);
  }
}

/**
 * Specifies an executable to run on a fully configured node and a
 * timeout period for executable completion.
 *
 * @generated from message google.cloud.dataproc.v1.NodeInitializationAction
 */
export class NodeInitializationAction extends Message<NodeInitializationAction> {
  /**
   * [Required] Google Cloud Storage URI of executable file.
   *
   * @generated from field: string executable_file = 1;
   */
  executableFile = "";

  /**
   * [Optional] Amount of time executable has to complete. Default is
   * 10 minutes. Cluster creation fails with an explanatory error message (the
   * name of the executable that caused the error and the exceeded timeout
   * period) if the executable is not completed at end of the timeout period.
   *
   * @generated from field: google.protobuf.Duration execution_timeout = 2;
   */
  executionTimeout?: Duration;

  constructor(data?: PartialMessage<NodeInitializationAction>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.dataproc.v1.NodeInitializationAction";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "executable_file", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "execution_timeout", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NodeInitializationAction {
    return new NodeInitializationAction().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NodeInitializationAction {
    return new NodeInitializationAction().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NodeInitializationAction {
    return new NodeInitializationAction().fromJsonString(jsonString, options);
  }

  static equals(a: NodeInitializationAction | PlainMessage<NodeInitializationAction> | undefined, b: NodeInitializationAction | PlainMessage<NodeInitializationAction> | undefined): boolean {
    return proto3.util.equals(NodeInitializationAction, a, b);
  }
}

/**
 * The status of a cluster and its instances.
 *
 * @generated from message google.cloud.dataproc.v1.ClusterStatus
 */
export class ClusterStatus extends Message<ClusterStatus> {
  /**
   * [Output-only] The cluster's state.
   *
   * @generated from field: google.cloud.dataproc.v1.ClusterStatus.State state = 1;
   */
  state = ClusterStatus_State.UNKNOWN;

  /**
   * [Output-only] Optional details of cluster's state.
   *
   * @generated from field: string detail = 2;
   */
  detail = "";

  /**
   * [Output-only] Time when this state was entered.
   *
   * @generated from field: google.protobuf.Timestamp state_start_time = 3;
   */
  stateStartTime?: Timestamp;

  constructor(data?: PartialMessage<ClusterStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.dataproc.v1.ClusterStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state", kind: "enum", T: proto3.getEnumType(ClusterStatus_State) },
    { no: 2, name: "detail", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "state_start_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ClusterStatus {
    return new ClusterStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ClusterStatus {
    return new ClusterStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ClusterStatus {
    return new ClusterStatus().fromJsonString(jsonString, options);
  }

  static equals(a: ClusterStatus | PlainMessage<ClusterStatus> | undefined, b: ClusterStatus | PlainMessage<ClusterStatus> | undefined): boolean {
    return proto3.util.equals(ClusterStatus, a, b);
  }
}

/**
 * The cluster state.
 *
 * @generated from enum google.cloud.dataproc.v1.ClusterStatus.State
 */
export enum ClusterStatus_State {
  /**
   * The cluster state is unknown.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * The cluster is being created and set up. It is not ready for use.
   *
   * @generated from enum value: CREATING = 1;
   */
  CREATING = 1,

  /**
   * The cluster is currently running and healthy. It is ready for use.
   *
   * @generated from enum value: RUNNING = 2;
   */
  RUNNING = 2,

  /**
   * The cluster encountered an error. It is not ready for use.
   *
   * @generated from enum value: ERROR = 3;
   */
  ERROR = 3,

  /**
   * The cluster is being deleted. It cannot be used.
   *
   * @generated from enum value: DELETING = 4;
   */
  DELETING = 4,

  /**
   * The cluster is being updated. It continues to accept and process jobs.
   *
   * @generated from enum value: UPDATING = 5;
   */
  UPDATING = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(ClusterStatus_State)
proto3.util.setEnumType(ClusterStatus_State, "google.cloud.dataproc.v1.ClusterStatus.State", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "CREATING" },
  { no: 2, name: "RUNNING" },
  { no: 3, name: "ERROR" },
  { no: 4, name: "DELETING" },
  { no: 5, name: "UPDATING" },
]);

/**
 * Specifies the selection and config of software inside the cluster.
 *
 * @generated from message google.cloud.dataproc.v1.SoftwareConfig
 */
export class SoftwareConfig extends Message<SoftwareConfig> {
  /**
   * [Optional] The version of software inside the cluster. It must match the
   * regular expression `[0-9]+\.[0-9]+`. If unspecified, it defaults to the
   * latest version (see [Cloud Dataproc Versioning](/dataproc/versioning)).
   *
   * @generated from field: string image_version = 1;
   */
  imageVersion = "";

  /**
   * [Optional] The properties to set on daemon config files.
   *
   * Property keys are specified in `prefix:property` format, such as
   * `core:fs.defaultFS`. The following are supported prefixes
   * and their mappings:
   *
   * * core:   `core-site.xml`
   * * hdfs:   `hdfs-site.xml`
   * * mapred: `mapred-site.xml`
   * * yarn:   `yarn-site.xml`
   * * hive:   `hive-site.xml`
   * * pig:    `pig.properties`
   * * spark:  `spark-defaults.conf`
   *
   * @generated from field: map<string, string> properties = 2;
   */
  properties: { [key: string]: string } = {};

  constructor(data?: PartialMessage<SoftwareConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.dataproc.v1.SoftwareConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "image_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "properties", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SoftwareConfig {
    return new SoftwareConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SoftwareConfig {
    return new SoftwareConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SoftwareConfig {
    return new SoftwareConfig().fromJsonString(jsonString, options);
  }

  static equals(a: SoftwareConfig | PlainMessage<SoftwareConfig> | undefined, b: SoftwareConfig | PlainMessage<SoftwareConfig> | undefined): boolean {
    return proto3.util.equals(SoftwareConfig, a, b);
  }
}

/**
 * A request to create a cluster.
 *
 * @generated from message google.cloud.dataproc.v1.CreateClusterRequest
 */
export class CreateClusterRequest extends Message<CreateClusterRequest> {
  /**
   * [Required] The ID of the Google Cloud Platform project that the cluster
   * belongs to.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * [Required] The Cloud Dataproc region in which to handle the request.
   *
   * @generated from field: string region = 3;
   */
  region = "";

  /**
   * [Required] The cluster to create.
   *
   * @generated from field: google.cloud.dataproc.v1.Cluster cluster = 2;
   */
  cluster?: Cluster;

  constructor(data?: PartialMessage<CreateClusterRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.dataproc.v1.CreateClusterRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cluster", kind: "message", T: Cluster },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateClusterRequest {
    return new CreateClusterRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateClusterRequest {
    return new CreateClusterRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateClusterRequest {
    return new CreateClusterRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateClusterRequest | PlainMessage<CreateClusterRequest> | undefined, b: CreateClusterRequest | PlainMessage<CreateClusterRequest> | undefined): boolean {
    return proto3.util.equals(CreateClusterRequest, a, b);
  }
}

/**
 * A request to update a cluster.
 *
 * @generated from message google.cloud.dataproc.v1.UpdateClusterRequest
 */
export class UpdateClusterRequest extends Message<UpdateClusterRequest> {
  /**
   * [Required] The ID of the Google Cloud Platform project the
   * cluster belongs to.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * [Required] The Cloud Dataproc region in which to handle the request.
   *
   * @generated from field: string region = 5;
   */
  region = "";

  /**
   * [Required] The cluster name.
   *
   * @generated from field: string cluster_name = 2;
   */
  clusterName = "";

  /**
   * [Required] The changes to the cluster.
   *
   * @generated from field: google.cloud.dataproc.v1.Cluster cluster = 3;
   */
  cluster?: Cluster;

  /**
   * [Required] Specifies the path, relative to <code>Cluster</code>, of
   * the field to update. For example, to change the number of workers
   * in a cluster to 5, the <code>update_mask</code> parameter would be
   * specified as <code>config.worker_config.num_instances</code>,
   * and the `PATCH` request body would specify the new value, as follows:
   *
   *     {
   *       "config":{
   *         "workerConfig":{
   *           "numInstances":"5"
   *         }
   *       }
   *     }
   * Similarly, to change the number of preemptible workers in a cluster to 5, the
   * <code>update_mask</code> parameter would be <code>config.secondary_worker_config.num_instances</code>,
   * and the `PATCH` request body would be set as follows:
   *
   *     {
   *       "config":{
   *         "secondaryWorkerConfig":{
   *           "numInstances":"5"
   *         }
   *       }
   *     }
   * <strong>Note:</strong> Currently, <code>config.worker_config.num_instances</code>
   * and <code>config.secondary_worker_config.num_instances</code> are the only
   * fields that can be updated.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 4;
   */
  updateMask?: FieldMask;

  constructor(data?: PartialMessage<UpdateClusterRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.dataproc.v1.UpdateClusterRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cluster_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "cluster", kind: "message", T: Cluster },
    { no: 4, name: "update_mask", kind: "message", T: FieldMask },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateClusterRequest {
    return new UpdateClusterRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateClusterRequest {
    return new UpdateClusterRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateClusterRequest {
    return new UpdateClusterRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateClusterRequest | PlainMessage<UpdateClusterRequest> | undefined, b: UpdateClusterRequest | PlainMessage<UpdateClusterRequest> | undefined): boolean {
    return proto3.util.equals(UpdateClusterRequest, a, b);
  }
}

/**
 * A request to delete a cluster.
 *
 * @generated from message google.cloud.dataproc.v1.DeleteClusterRequest
 */
export class DeleteClusterRequest extends Message<DeleteClusterRequest> {
  /**
   * [Required] The ID of the Google Cloud Platform project that the cluster
   * belongs to.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * [Required] The Cloud Dataproc region in which to handle the request.
   *
   * @generated from field: string region = 3;
   */
  region = "";

  /**
   * [Required] The cluster name.
   *
   * @generated from field: string cluster_name = 2;
   */
  clusterName = "";

  constructor(data?: PartialMessage<DeleteClusterRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.dataproc.v1.DeleteClusterRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cluster_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteClusterRequest {
    return new DeleteClusterRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteClusterRequest {
    return new DeleteClusterRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteClusterRequest {
    return new DeleteClusterRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteClusterRequest | PlainMessage<DeleteClusterRequest> | undefined, b: DeleteClusterRequest | PlainMessage<DeleteClusterRequest> | undefined): boolean {
    return proto3.util.equals(DeleteClusterRequest, a, b);
  }
}

/**
 * Request to get the resource representation for a cluster in a project.
 *
 * @generated from message google.cloud.dataproc.v1.GetClusterRequest
 */
export class GetClusterRequest extends Message<GetClusterRequest> {
  /**
   * [Required] The ID of the Google Cloud Platform project that the cluster
   * belongs to.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * [Required] The Cloud Dataproc region in which to handle the request.
   *
   * @generated from field: string region = 3;
   */
  region = "";

  /**
   * [Required] The cluster name.
   *
   * @generated from field: string cluster_name = 2;
   */
  clusterName = "";

  constructor(data?: PartialMessage<GetClusterRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.dataproc.v1.GetClusterRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cluster_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetClusterRequest {
    return new GetClusterRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetClusterRequest {
    return new GetClusterRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetClusterRequest {
    return new GetClusterRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetClusterRequest | PlainMessage<GetClusterRequest> | undefined, b: GetClusterRequest | PlainMessage<GetClusterRequest> | undefined): boolean {
    return proto3.util.equals(GetClusterRequest, a, b);
  }
}

/**
 * A request to list the clusters in a project.
 *
 * @generated from message google.cloud.dataproc.v1.ListClustersRequest
 */
export class ListClustersRequest extends Message<ListClustersRequest> {
  /**
   * [Required] The ID of the Google Cloud Platform project that the cluster
   * belongs to.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * [Required] The Cloud Dataproc region in which to handle the request.
   *
   * @generated from field: string region = 4;
   */
  region = "";

  /**
   * [Optional] The standard List page size.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * [Optional] The standard List page token.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListClustersRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.dataproc.v1.ListClustersRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListClustersRequest {
    return new ListClustersRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListClustersRequest {
    return new ListClustersRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListClustersRequest {
    return new ListClustersRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListClustersRequest | PlainMessage<ListClustersRequest> | undefined, b: ListClustersRequest | PlainMessage<ListClustersRequest> | undefined): boolean {
    return proto3.util.equals(ListClustersRequest, a, b);
  }
}

/**
 * The list of all clusters in a project.
 *
 * @generated from message google.cloud.dataproc.v1.ListClustersResponse
 */
export class ListClustersResponse extends Message<ListClustersResponse> {
  /**
   * [Output-only] The clusters in the project.
   *
   * @generated from field: repeated google.cloud.dataproc.v1.Cluster clusters = 1;
   */
  clusters: Cluster[] = [];

  /**
   * [Output-only] This token is included in the response if there are more
   * results to fetch. To fetch additional results, provide this value as the
   * `page_token` in a subsequent <code>ListClustersRequest</code>.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListClustersResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.dataproc.v1.ListClustersResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "clusters", kind: "message", T: Cluster, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListClustersResponse {
    return new ListClustersResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListClustersResponse {
    return new ListClustersResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListClustersResponse {
    return new ListClustersResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListClustersResponse | PlainMessage<ListClustersResponse> | undefined, b: ListClustersResponse | PlainMessage<ListClustersResponse> | undefined): boolean {
    return proto3.util.equals(ListClustersResponse, a, b);
  }
}

/**
 * A request to collect cluster diagnostic information.
 *
 * @generated from message google.cloud.dataproc.v1.DiagnoseClusterRequest
 */
export class DiagnoseClusterRequest extends Message<DiagnoseClusterRequest> {
  /**
   * [Required] The ID of the Google Cloud Platform project that the cluster
   * belongs to.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * [Required] The Cloud Dataproc region in which to handle the request.
   *
   * @generated from field: string region = 3;
   */
  region = "";

  /**
   * [Required] The cluster name.
   *
   * @generated from field: string cluster_name = 2;
   */
  clusterName = "";

  constructor(data?: PartialMessage<DiagnoseClusterRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.dataproc.v1.DiagnoseClusterRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "region", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "cluster_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiagnoseClusterRequest {
    return new DiagnoseClusterRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiagnoseClusterRequest {
    return new DiagnoseClusterRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiagnoseClusterRequest {
    return new DiagnoseClusterRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DiagnoseClusterRequest | PlainMessage<DiagnoseClusterRequest> | undefined, b: DiagnoseClusterRequest | PlainMessage<DiagnoseClusterRequest> | undefined): boolean {
    return proto3.util.equals(DiagnoseClusterRequest, a, b);
  }
}

/**
 * The location of diagnostic output.
 *
 * @generated from message google.cloud.dataproc.v1.DiagnoseClusterResults
 */
export class DiagnoseClusterResults extends Message<DiagnoseClusterResults> {
  /**
   * [Output-only] The Google Cloud Storage URI of the diagnostic output.
   * The output report is a plain text file with a summary of collected
   * diagnostics.
   *
   * @generated from field: string output_uri = 1;
   */
  outputUri = "";

  constructor(data?: PartialMessage<DiagnoseClusterResults>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.cloud.dataproc.v1.DiagnoseClusterResults";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "output_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiagnoseClusterResults {
    return new DiagnoseClusterResults().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiagnoseClusterResults {
    return new DiagnoseClusterResults().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiagnoseClusterResults {
    return new DiagnoseClusterResults().fromJsonString(jsonString, options);
  }

  static equals(a: DiagnoseClusterResults | PlainMessage<DiagnoseClusterResults> | undefined, b: DiagnoseClusterResults | PlainMessage<DiagnoseClusterResults> | undefined): boolean {
    return proto3.util.equals(DiagnoseClusterResults, a, b);
  }
}

