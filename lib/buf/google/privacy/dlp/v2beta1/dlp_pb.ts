// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/privacy/dlp/v2beta1/dlp.proto (package google.privacy.dlp.v2beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { BigQueryTable, CloudStoragePath, EntityId, FieldId, InfoType, RecordKey, StorageConfig } from "./storage_pb.js";
import { TimeOfDay } from "../../../type/timeofday_pb.js";
import { Date } from "../../../type/date_pb.js";

/**
 * Categorization of results based on how likely they are to represent a match,
 * based on the number of elements they contain which imply a match.
 *
 * @generated from enum google.privacy.dlp.v2beta1.Likelihood
 */
export enum Likelihood {
  /**
   * Default value; information with all likelihoods is included.
   *
   * @generated from enum value: LIKELIHOOD_UNSPECIFIED = 0;
   */
  LIKELIHOOD_UNSPECIFIED = 0,

  /**
   * Few matching elements.
   *
   * @generated from enum value: VERY_UNLIKELY = 1;
   */
  VERY_UNLIKELY = 1,

  /**
   * @generated from enum value: UNLIKELY = 2;
   */
  UNLIKELY = 2,

  /**
   * Some matching elements.
   *
   * @generated from enum value: POSSIBLE = 3;
   */
  POSSIBLE = 3,

  /**
   * @generated from enum value: LIKELY = 4;
   */
  LIKELY = 4,

  /**
   * Many matching elements.
   *
   * @generated from enum value: VERY_LIKELY = 5;
   */
  VERY_LIKELY = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(Likelihood)
proto3.util.setEnumType(Likelihood, "google.privacy.dlp.v2beta1.Likelihood", [
  { no: 0, name: "LIKELIHOOD_UNSPECIFIED" },
  { no: 1, name: "VERY_UNLIKELY" },
  { no: 2, name: "UNLIKELY" },
  { no: 3, name: "POSSIBLE" },
  { no: 4, name: "LIKELY" },
  { no: 5, name: "VERY_LIKELY" },
]);

/**
 * Operators available for comparing the value of fields.
 *
 * @generated from enum google.privacy.dlp.v2beta1.RelationalOperator
 */
export enum RelationalOperator {
  /**
   * @generated from enum value: RELATIONAL_OPERATOR_UNSPECIFIED = 0;
   */
  RELATIONAL_OPERATOR_UNSPECIFIED = 0,

  /**
   * Equal.
   *
   * @generated from enum value: EQUAL_TO = 1;
   */
  EQUAL_TO = 1,

  /**
   * Not equal to.
   *
   * @generated from enum value: NOT_EQUAL_TO = 2;
   */
  NOT_EQUAL_TO = 2,

  /**
   * Greater than.
   *
   * @generated from enum value: GREATER_THAN = 3;
   */
  GREATER_THAN = 3,

  /**
   * Less than.
   *
   * @generated from enum value: LESS_THAN = 4;
   */
  LESS_THAN = 4,

  /**
   * Greater than or equals.
   *
   * @generated from enum value: GREATER_THAN_OR_EQUALS = 5;
   */
  GREATER_THAN_OR_EQUALS = 5,

  /**
   * Less than or equals.
   *
   * @generated from enum value: LESS_THAN_OR_EQUALS = 6;
   */
  LESS_THAN_OR_EQUALS = 6,

  /**
   * Exists
   *
   * @generated from enum value: EXISTS = 7;
   */
  EXISTS = 7,
}
// Retrieve enum metadata with: proto3.getEnumType(RelationalOperator)
proto3.util.setEnumType(RelationalOperator, "google.privacy.dlp.v2beta1.RelationalOperator", [
  { no: 0, name: "RELATIONAL_OPERATOR_UNSPECIFIED" },
  { no: 1, name: "EQUAL_TO" },
  { no: 2, name: "NOT_EQUAL_TO" },
  { no: 3, name: "GREATER_THAN" },
  { no: 4, name: "LESS_THAN" },
  { no: 5, name: "GREATER_THAN_OR_EQUALS" },
  { no: 6, name: "LESS_THAN_OR_EQUALS" },
  { no: 7, name: "EXISTS" },
]);

/**
 * Configuration description of the scanning process.
 * When used with redactContent only info_types and min_likelihood are currently
 * used.
 *
 * @generated from message google.privacy.dlp.v2beta1.InspectConfig
 */
export class InspectConfig extends Message<InspectConfig> {
  /**
   * Restricts what info_types to look for. The values must correspond to
   * InfoType values returned by ListInfoTypes or found in documentation.
   * Empty info_types runs all enabled detectors.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.InfoType info_types = 1;
   */
  infoTypes: InfoType[] = [];

  /**
   * Only returns findings equal or above this threshold.
   *
   * @generated from field: google.privacy.dlp.v2beta1.Likelihood min_likelihood = 2;
   */
  minLikelihood = Likelihood.LIKELIHOOD_UNSPECIFIED;

  /**
   * Limits the number of findings per content item or long running operation.
   *
   * @generated from field: int32 max_findings = 3;
   */
  maxFindings = 0;

  /**
   * When true, a contextual quote from the data that triggered a finding is
   * included in the response; see Finding.quote.
   *
   * @generated from field: bool include_quote = 4;
   */
  includeQuote = false;

  /**
   * When true, excludes type information of the findings.
   *
   * @generated from field: bool exclude_types = 6;
   */
  excludeTypes = false;

  /**
   * Configuration of findings limit given for specified info types.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.InspectConfig.InfoTypeLimit info_type_limits = 7;
   */
  infoTypeLimits: InspectConfig_InfoTypeLimit[] = [];

  constructor(data?: PartialMessage<InspectConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.InspectConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "info_types", kind: "message", T: InfoType, repeated: true },
    { no: 2, name: "min_likelihood", kind: "enum", T: proto3.getEnumType(Likelihood) },
    { no: 3, name: "max_findings", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "include_quote", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "exclude_types", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "info_type_limits", kind: "message", T: InspectConfig_InfoTypeLimit, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InspectConfig {
    return new InspectConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InspectConfig {
    return new InspectConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InspectConfig {
    return new InspectConfig().fromJsonString(jsonString, options);
  }

  static equals(a: InspectConfig | PlainMessage<InspectConfig> | undefined, b: InspectConfig | PlainMessage<InspectConfig> | undefined): boolean {
    return proto3.util.equals(InspectConfig, a, b);
  }
}

/**
 * Max findings configuration per info type, per content item or long running
 * operation.
 *
 * @generated from message google.privacy.dlp.v2beta1.InspectConfig.InfoTypeLimit
 */
export class InspectConfig_InfoTypeLimit extends Message<InspectConfig_InfoTypeLimit> {
  /**
   * Type of information the findings limit applies to. Only one limit per
   * info_type should be provided. If InfoTypeLimit does not have an
   * info_type, the DLP API applies the limit against all info_types that are
   * found but not specified in another InfoTypeLimit.
   *
   * @generated from field: google.privacy.dlp.v2beta1.InfoType info_type = 1;
   */
  infoType?: InfoType;

  /**
   * Max findings limit for the given infoType.
   *
   * @generated from field: int32 max_findings = 2;
   */
  maxFindings = 0;

  constructor(data?: PartialMessage<InspectConfig_InfoTypeLimit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.InspectConfig.InfoTypeLimit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "info_type", kind: "message", T: InfoType },
    { no: 2, name: "max_findings", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InspectConfig_InfoTypeLimit {
    return new InspectConfig_InfoTypeLimit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InspectConfig_InfoTypeLimit {
    return new InspectConfig_InfoTypeLimit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InspectConfig_InfoTypeLimit {
    return new InspectConfig_InfoTypeLimit().fromJsonString(jsonString, options);
  }

  static equals(a: InspectConfig_InfoTypeLimit | PlainMessage<InspectConfig_InfoTypeLimit> | undefined, b: InspectConfig_InfoTypeLimit | PlainMessage<InspectConfig_InfoTypeLimit> | undefined): boolean {
    return proto3.util.equals(InspectConfig_InfoTypeLimit, a, b);
  }
}

/**
 * Additional configuration for inspect long running operations.
 *
 * @generated from message google.privacy.dlp.v2beta1.OperationConfig
 */
export class OperationConfig extends Message<OperationConfig> {
  /**
   * Max number of findings per file, Datastore entity, or database row.
   *
   * @generated from field: int64 max_item_findings = 1;
   */
  maxItemFindings = protoInt64.zero;

  constructor(data?: PartialMessage<OperationConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.OperationConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "max_item_findings", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OperationConfig {
    return new OperationConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OperationConfig {
    return new OperationConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OperationConfig {
    return new OperationConfig().fromJsonString(jsonString, options);
  }

  static equals(a: OperationConfig | PlainMessage<OperationConfig> | undefined, b: OperationConfig | PlainMessage<OperationConfig> | undefined): boolean {
    return proto3.util.equals(OperationConfig, a, b);
  }
}

/**
 * Container structure for the content to inspect.
 *
 * @generated from message google.privacy.dlp.v2beta1.ContentItem
 */
export class ContentItem extends Message<ContentItem> {
  /**
   * Type of the content, as defined in Content-Type HTTP header.
   * Supported types are: all "text" types, octet streams, PNG images,
   * JPEG images.
   *
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * Data of the item either in the byte array or UTF-8 string form.
   *
   * @generated from oneof google.privacy.dlp.v2beta1.ContentItem.data_item
   */
  dataItem: {
    /**
     * Content data to inspect or redact.
     *
     * @generated from field: bytes data = 2;
     */
    value: Uint8Array;
    case: "data";
  } | {
    /**
     * String data to inspect or redact.
     *
     * @generated from field: string value = 3;
     */
    value: string;
    case: "value";
  } | {
    /**
     * Structured content for inspection.
     *
     * @generated from field: google.privacy.dlp.v2beta1.Table table = 4;
     */
    value: Table;
    case: "table";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ContentItem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.ContentItem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "data_item" },
    { no: 3, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "data_item" },
    { no: 4, name: "table", kind: "message", T: Table, oneof: "data_item" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ContentItem {
    return new ContentItem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ContentItem {
    return new ContentItem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ContentItem {
    return new ContentItem().fromJsonString(jsonString, options);
  }

  static equals(a: ContentItem | PlainMessage<ContentItem> | undefined, b: ContentItem | PlainMessage<ContentItem> | undefined): boolean {
    return proto3.util.equals(ContentItem, a, b);
  }
}

/**
 * Structured content to inspect. Up to 50,000 `Value`s per request allowed.
 *
 * @generated from message google.privacy.dlp.v2beta1.Table
 */
export class Table extends Message<Table> {
  /**
   * @generated from field: repeated google.privacy.dlp.v2beta1.FieldId headers = 1;
   */
  headers: FieldId[] = [];

  /**
   * @generated from field: repeated google.privacy.dlp.v2beta1.Table.Row rows = 2;
   */
  rows: Table_Row[] = [];

  constructor(data?: PartialMessage<Table>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.Table";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "headers", kind: "message", T: FieldId, repeated: true },
    { no: 2, name: "rows", kind: "message", T: Table_Row, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Table {
    return new Table().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Table {
    return new Table().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Table {
    return new Table().fromJsonString(jsonString, options);
  }

  static equals(a: Table | PlainMessage<Table> | undefined, b: Table | PlainMessage<Table> | undefined): boolean {
    return proto3.util.equals(Table, a, b);
  }
}

/**
 * @generated from message google.privacy.dlp.v2beta1.Table.Row
 */
export class Table_Row extends Message<Table_Row> {
  /**
   * @generated from field: repeated google.privacy.dlp.v2beta1.Value values = 1;
   */
  values: Value[] = [];

  constructor(data?: PartialMessage<Table_Row>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.Table.Row";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "message", T: Value, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Table_Row {
    return new Table_Row().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Table_Row {
    return new Table_Row().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Table_Row {
    return new Table_Row().fromJsonString(jsonString, options);
  }

  static equals(a: Table_Row | PlainMessage<Table_Row> | undefined, b: Table_Row | PlainMessage<Table_Row> | undefined): boolean {
    return proto3.util.equals(Table_Row, a, b);
  }
}

/**
 * All the findings for a single scanned item.
 *
 * @generated from message google.privacy.dlp.v2beta1.InspectResult
 */
export class InspectResult extends Message<InspectResult> {
  /**
   * List of findings for an item.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.Finding findings = 1;
   */
  findings: Finding[] = [];

  /**
   * If true, then this item might have more findings than were returned,
   * and the findings returned are an arbitrary subset of all findings.
   * The findings list might be truncated because the input items were too
   * large, or because the server reached the maximum amount of resources
   * allowed for a single API call. For best results, divide the input into
   * smaller batches.
   *
   * @generated from field: bool findings_truncated = 2;
   */
  findingsTruncated = false;

  constructor(data?: PartialMessage<InspectResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.InspectResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "findings", kind: "message", T: Finding, repeated: true },
    { no: 2, name: "findings_truncated", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InspectResult {
    return new InspectResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InspectResult {
    return new InspectResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InspectResult {
    return new InspectResult().fromJsonString(jsonString, options);
  }

  static equals(a: InspectResult | PlainMessage<InspectResult> | undefined, b: InspectResult | PlainMessage<InspectResult> | undefined): boolean {
    return proto3.util.equals(InspectResult, a, b);
  }
}

/**
 * Container structure describing a single finding within a string or image.
 *
 * @generated from message google.privacy.dlp.v2beta1.Finding
 */
export class Finding extends Message<Finding> {
  /**
   * The specific string that may be potentially sensitive info.
   *
   * @generated from field: string quote = 1;
   */
  quote = "";

  /**
   * The specific type of info the string might be.
   *
   * @generated from field: google.privacy.dlp.v2beta1.InfoType info_type = 2;
   */
  infoType?: InfoType;

  /**
   * Estimate of how likely it is that the info_type is correct.
   *
   * @generated from field: google.privacy.dlp.v2beta1.Likelihood likelihood = 3;
   */
  likelihood = Likelihood.LIKELIHOOD_UNSPECIFIED;

  /**
   * Location of the info found.
   *
   * @generated from field: google.privacy.dlp.v2beta1.Location location = 4;
   */
  location?: Location;

  /**
   * Timestamp when finding was detected.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 6;
   */
  createTime?: Timestamp;

  constructor(data?: PartialMessage<Finding>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.Finding";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "quote", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "info_type", kind: "message", T: InfoType },
    { no: 3, name: "likelihood", kind: "enum", T: proto3.getEnumType(Likelihood) },
    { no: 4, name: "location", kind: "message", T: Location },
    { no: 6, name: "create_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Finding {
    return new Finding().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Finding {
    return new Finding().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Finding {
    return new Finding().fromJsonString(jsonString, options);
  }

  static equals(a: Finding | PlainMessage<Finding> | undefined, b: Finding | PlainMessage<Finding> | undefined): boolean {
    return proto3.util.equals(Finding, a, b);
  }
}

/**
 * Specifies the location of a finding within its source item.
 *
 * @generated from message google.privacy.dlp.v2beta1.Location
 */
export class Location extends Message<Location> {
  /**
   * Zero-based byte offsets within a content item.
   *
   * @generated from field: google.privacy.dlp.v2beta1.Range byte_range = 1;
   */
  byteRange?: Range;

  /**
   * Character offsets within a content item, included when content type
   * is a text. Default charset assumed to be UTF-8.
   *
   * @generated from field: google.privacy.dlp.v2beta1.Range codepoint_range = 2;
   */
  codepointRange?: Range;

  /**
   * Location within an image's pixels.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.ImageLocation image_boxes = 3;
   */
  imageBoxes: ImageLocation[] = [];

  /**
   * Key of the finding.
   *
   * @generated from field: google.privacy.dlp.v2beta1.RecordKey record_key = 4;
   */
  recordKey?: RecordKey;

  /**
   * Field id of the field containing the finding.
   *
   * @generated from field: google.privacy.dlp.v2beta1.FieldId field_id = 5;
   */
  fieldId?: FieldId;

  /**
   * Location within a `ContentItem.Table`.
   *
   * @generated from field: google.privacy.dlp.v2beta1.TableLocation table_location = 6;
   */
  tableLocation?: TableLocation;

  constructor(data?: PartialMessage<Location>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.Location";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "byte_range", kind: "message", T: Range },
    { no: 2, name: "codepoint_range", kind: "message", T: Range },
    { no: 3, name: "image_boxes", kind: "message", T: ImageLocation, repeated: true },
    { no: 4, name: "record_key", kind: "message", T: RecordKey },
    { no: 5, name: "field_id", kind: "message", T: FieldId },
    { no: 6, name: "table_location", kind: "message", T: TableLocation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Location {
    return new Location().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Location {
    return new Location().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Location {
    return new Location().fromJsonString(jsonString, options);
  }

  static equals(a: Location | PlainMessage<Location> | undefined, b: Location | PlainMessage<Location> | undefined): boolean {
    return proto3.util.equals(Location, a, b);
  }
}

/**
 * Location of a finding within a `ContentItem.Table`.
 *
 * @generated from message google.privacy.dlp.v2beta1.TableLocation
 */
export class TableLocation extends Message<TableLocation> {
  /**
   * The zero-based index of the row where the finding is located.
   *
   * @generated from field: int64 row_index = 1;
   */
  rowIndex = protoInt64.zero;

  constructor(data?: PartialMessage<TableLocation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.TableLocation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "row_index", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TableLocation {
    return new TableLocation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TableLocation {
    return new TableLocation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TableLocation {
    return new TableLocation().fromJsonString(jsonString, options);
  }

  static equals(a: TableLocation | PlainMessage<TableLocation> | undefined, b: TableLocation | PlainMessage<TableLocation> | undefined): boolean {
    return proto3.util.equals(TableLocation, a, b);
  }
}

/**
 * Generic half-open interval [start, end)
 *
 * @generated from message google.privacy.dlp.v2beta1.Range
 */
export class Range extends Message<Range> {
  /**
   * Index of the first character of the range (inclusive).
   *
   * @generated from field: int64 start = 1;
   */
  start = protoInt64.zero;

  /**
   * Index of the last character of the range (exclusive).
   *
   * @generated from field: int64 end = 2;
   */
  end = protoInt64.zero;

  constructor(data?: PartialMessage<Range>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.Range";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "end", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Range {
    return new Range().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Range {
    return new Range().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Range {
    return new Range().fromJsonString(jsonString, options);
  }

  static equals(a: Range | PlainMessage<Range> | undefined, b: Range | PlainMessage<Range> | undefined): boolean {
    return proto3.util.equals(Range, a, b);
  }
}

/**
 * Bounding box encompassing detected text within an image.
 *
 * @generated from message google.privacy.dlp.v2beta1.ImageLocation
 */
export class ImageLocation extends Message<ImageLocation> {
  /**
   * Top coordinate of the bounding box. (0,0) is upper left.
   *
   * @generated from field: int32 top = 1;
   */
  top = 0;

  /**
   * Left coordinate of the bounding box. (0,0) is upper left.
   *
   * @generated from field: int32 left = 2;
   */
  left = 0;

  /**
   * Width of the bounding box in pixels.
   *
   * @generated from field: int32 width = 3;
   */
  width = 0;

  /**
   * Height of the bounding box in pixels.
   *
   * @generated from field: int32 height = 4;
   */
  height = 0;

  constructor(data?: PartialMessage<ImageLocation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.ImageLocation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "top", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "left", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "width", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "height", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImageLocation {
    return new ImageLocation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImageLocation {
    return new ImageLocation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImageLocation {
    return new ImageLocation().fromJsonString(jsonString, options);
  }

  static equals(a: ImageLocation | PlainMessage<ImageLocation> | undefined, b: ImageLocation | PlainMessage<ImageLocation> | undefined): boolean {
    return proto3.util.equals(ImageLocation, a, b);
  }
}

/**
 * Request to search for potentially sensitive info in a list of items
 * and replace it with a default or provided content.
 *
 * @generated from message google.privacy.dlp.v2beta1.RedactContentRequest
 */
export class RedactContentRequest extends Message<RedactContentRequest> {
  /**
   * Configuration for the inspector.
   *
   * @generated from field: google.privacy.dlp.v2beta1.InspectConfig inspect_config = 1;
   */
  inspectConfig?: InspectConfig;

  /**
   * The list of items to inspect. Up to 100 are allowed per request.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.ContentItem items = 2;
   */
  items: ContentItem[] = [];

  /**
   * The strings to replace findings text findings with. Must specify at least
   * one of these or one ImageRedactionConfig if redacting images.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.RedactContentRequest.ReplaceConfig replace_configs = 3;
   */
  replaceConfigs: RedactContentRequest_ReplaceConfig[] = [];

  /**
   * The configuration for specifying what content to redact from images.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.RedactContentRequest.ImageRedactionConfig image_redaction_configs = 4;
   */
  imageRedactionConfigs: RedactContentRequest_ImageRedactionConfig[] = [];

  constructor(data?: PartialMessage<RedactContentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.RedactContentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inspect_config", kind: "message", T: InspectConfig },
    { no: 2, name: "items", kind: "message", T: ContentItem, repeated: true },
    { no: 3, name: "replace_configs", kind: "message", T: RedactContentRequest_ReplaceConfig, repeated: true },
    { no: 4, name: "image_redaction_configs", kind: "message", T: RedactContentRequest_ImageRedactionConfig, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RedactContentRequest {
    return new RedactContentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RedactContentRequest {
    return new RedactContentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RedactContentRequest {
    return new RedactContentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RedactContentRequest | PlainMessage<RedactContentRequest> | undefined, b: RedactContentRequest | PlainMessage<RedactContentRequest> | undefined): boolean {
    return proto3.util.equals(RedactContentRequest, a, b);
  }
}

/**
 * @generated from message google.privacy.dlp.v2beta1.RedactContentRequest.ReplaceConfig
 */
export class RedactContentRequest_ReplaceConfig extends Message<RedactContentRequest_ReplaceConfig> {
  /**
   * Type of information to replace. Only one ReplaceConfig per info_type
   * should be provided. If ReplaceConfig does not have an info_type, the DLP
   * API matches it against all info_types that are found but not specified in
   * another ReplaceConfig.
   *
   * @generated from field: google.privacy.dlp.v2beta1.InfoType info_type = 1;
   */
  infoType?: InfoType;

  /**
   * Content replacing sensitive information of given type. Max 256 chars.
   *
   * @generated from field: string replace_with = 2;
   */
  replaceWith = "";

  constructor(data?: PartialMessage<RedactContentRequest_ReplaceConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.RedactContentRequest.ReplaceConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "info_type", kind: "message", T: InfoType },
    { no: 2, name: "replace_with", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RedactContentRequest_ReplaceConfig {
    return new RedactContentRequest_ReplaceConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RedactContentRequest_ReplaceConfig {
    return new RedactContentRequest_ReplaceConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RedactContentRequest_ReplaceConfig {
    return new RedactContentRequest_ReplaceConfig().fromJsonString(jsonString, options);
  }

  static equals(a: RedactContentRequest_ReplaceConfig | PlainMessage<RedactContentRequest_ReplaceConfig> | undefined, b: RedactContentRequest_ReplaceConfig | PlainMessage<RedactContentRequest_ReplaceConfig> | undefined): boolean {
    return proto3.util.equals(RedactContentRequest_ReplaceConfig, a, b);
  }
}

/**
 * Configuration for determing how redaction of images should occur.
 *
 * @generated from message google.privacy.dlp.v2beta1.RedactContentRequest.ImageRedactionConfig
 */
export class RedactContentRequest_ImageRedactionConfig extends Message<RedactContentRequest_ImageRedactionConfig> {
  /**
   * Type of information to redact from images.
   *
   * @generated from oneof google.privacy.dlp.v2beta1.RedactContentRequest.ImageRedactionConfig.target
   */
  target: {
    /**
     * Only one per info_type should be provided per request. If not
     * specified, and redact_all_text is false, the DLP API will redact all
     * text that it matches against all info_types that are found, but not
     * specified in another ImageRedactionConfig.
     *
     * @generated from field: google.privacy.dlp.v2beta1.InfoType info_type = 1;
     */
    value: InfoType;
    case: "infoType";
  } | {
    /**
     * If true, all text found in the image, regardless whether it matches an
     * info_type, is redacted.
     *
     * @generated from field: bool redact_all_text = 2;
     */
    value: boolean;
    case: "redactAllText";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The color to use when redacting content from an image. If not specified,
   * the default is black.
   *
   * @generated from field: google.privacy.dlp.v2beta1.Color redaction_color = 3;
   */
  redactionColor?: Color;

  constructor(data?: PartialMessage<RedactContentRequest_ImageRedactionConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.RedactContentRequest.ImageRedactionConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "info_type", kind: "message", T: InfoType, oneof: "target" },
    { no: 2, name: "redact_all_text", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "target" },
    { no: 3, name: "redaction_color", kind: "message", T: Color },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RedactContentRequest_ImageRedactionConfig {
    return new RedactContentRequest_ImageRedactionConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RedactContentRequest_ImageRedactionConfig {
    return new RedactContentRequest_ImageRedactionConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RedactContentRequest_ImageRedactionConfig {
    return new RedactContentRequest_ImageRedactionConfig().fromJsonString(jsonString, options);
  }

  static equals(a: RedactContentRequest_ImageRedactionConfig | PlainMessage<RedactContentRequest_ImageRedactionConfig> | undefined, b: RedactContentRequest_ImageRedactionConfig | PlainMessage<RedactContentRequest_ImageRedactionConfig> | undefined): boolean {
    return proto3.util.equals(RedactContentRequest_ImageRedactionConfig, a, b);
  }
}

/**
 * Represents a color in the RGB color space.
 *
 * @generated from message google.privacy.dlp.v2beta1.Color
 */
export class Color extends Message<Color> {
  /**
   * The amount of red in the color as a value in the interval [0, 1].
   *
   * @generated from field: float red = 1;
   */
  red = 0;

  /**
   * The amount of green in the color as a value in the interval [0, 1].
   *
   * @generated from field: float green = 2;
   */
  green = 0;

  /**
   * The amount of blue in the color as a value in the interval [0, 1].
   *
   * @generated from field: float blue = 3;
   */
  blue = 0;

  constructor(data?: PartialMessage<Color>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.Color";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "red", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 2, name: "green", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 3, name: "blue", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Color {
    return new Color().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Color {
    return new Color().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Color {
    return new Color().fromJsonString(jsonString, options);
  }

  static equals(a: Color | PlainMessage<Color> | undefined, b: Color | PlainMessage<Color> | undefined): boolean {
    return proto3.util.equals(Color, a, b);
  }
}

/**
 * Results of redacting a list of items.
 *
 * @generated from message google.privacy.dlp.v2beta1.RedactContentResponse
 */
export class RedactContentResponse extends Message<RedactContentResponse> {
  /**
   * The redacted content.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.ContentItem items = 1;
   */
  items: ContentItem[] = [];

  constructor(data?: PartialMessage<RedactContentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.RedactContentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "items", kind: "message", T: ContentItem, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RedactContentResponse {
    return new RedactContentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RedactContentResponse {
    return new RedactContentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RedactContentResponse {
    return new RedactContentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RedactContentResponse | PlainMessage<RedactContentResponse> | undefined, b: RedactContentResponse | PlainMessage<RedactContentResponse> | undefined): boolean {
    return proto3.util.equals(RedactContentResponse, a, b);
  }
}

/**
 * Request to de-identify a list of items.
 *
 * @generated from message google.privacy.dlp.v2beta1.DeidentifyContentRequest
 */
export class DeidentifyContentRequest extends Message<DeidentifyContentRequest> {
  /**
   * Configuration for the de-identification of the list of content items.
   *
   * @generated from field: google.privacy.dlp.v2beta1.DeidentifyConfig deidentify_config = 1;
   */
  deidentifyConfig?: DeidentifyConfig;

  /**
   * Configuration for the inspector.
   *
   * @generated from field: google.privacy.dlp.v2beta1.InspectConfig inspect_config = 2;
   */
  inspectConfig?: InspectConfig;

  /**
   * The list of items to inspect. Up to 100 are allowed per request.
   * All items will be treated as text/*.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.ContentItem items = 3;
   */
  items: ContentItem[] = [];

  constructor(data?: PartialMessage<DeidentifyContentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.DeidentifyContentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "deidentify_config", kind: "message", T: DeidentifyConfig },
    { no: 2, name: "inspect_config", kind: "message", T: InspectConfig },
    { no: 3, name: "items", kind: "message", T: ContentItem, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeidentifyContentRequest {
    return new DeidentifyContentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeidentifyContentRequest {
    return new DeidentifyContentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeidentifyContentRequest {
    return new DeidentifyContentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeidentifyContentRequest | PlainMessage<DeidentifyContentRequest> | undefined, b: DeidentifyContentRequest | PlainMessage<DeidentifyContentRequest> | undefined): boolean {
    return proto3.util.equals(DeidentifyContentRequest, a, b);
  }
}

/**
 * Results of de-identifying a list of items.
 *
 * @generated from message google.privacy.dlp.v2beta1.DeidentifyContentResponse
 */
export class DeidentifyContentResponse extends Message<DeidentifyContentResponse> {
  /**
   * @generated from field: repeated google.privacy.dlp.v2beta1.ContentItem items = 1;
   */
  items: ContentItem[] = [];

  /**
   * A review of the transformations that took place for each item.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.DeidentificationSummary summaries = 2;
   */
  summaries: DeidentificationSummary[] = [];

  constructor(data?: PartialMessage<DeidentifyContentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.DeidentifyContentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "items", kind: "message", T: ContentItem, repeated: true },
    { no: 2, name: "summaries", kind: "message", T: DeidentificationSummary, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeidentifyContentResponse {
    return new DeidentifyContentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeidentifyContentResponse {
    return new DeidentifyContentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeidentifyContentResponse {
    return new DeidentifyContentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeidentifyContentResponse | PlainMessage<DeidentifyContentResponse> | undefined, b: DeidentifyContentResponse | PlainMessage<DeidentifyContentResponse> | undefined): boolean {
    return proto3.util.equals(DeidentifyContentResponse, a, b);
  }
}

/**
 * Request to search for potentially sensitive info in a list of items.
 *
 * @generated from message google.privacy.dlp.v2beta1.InspectContentRequest
 */
export class InspectContentRequest extends Message<InspectContentRequest> {
  /**
   * Configuration for the inspector.
   *
   * @generated from field: google.privacy.dlp.v2beta1.InspectConfig inspect_config = 1;
   */
  inspectConfig?: InspectConfig;

  /**
   * The list of items to inspect. Items in a single request are
   * considered "related" unless inspect_config.independent_inputs is true.
   * Up to 100 are allowed per request.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.ContentItem items = 2;
   */
  items: ContentItem[] = [];

  constructor(data?: PartialMessage<InspectContentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.InspectContentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inspect_config", kind: "message", T: InspectConfig },
    { no: 2, name: "items", kind: "message", T: ContentItem, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InspectContentRequest {
    return new InspectContentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InspectContentRequest {
    return new InspectContentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InspectContentRequest {
    return new InspectContentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: InspectContentRequest | PlainMessage<InspectContentRequest> | undefined, b: InspectContentRequest | PlainMessage<InspectContentRequest> | undefined): boolean {
    return proto3.util.equals(InspectContentRequest, a, b);
  }
}

/**
 * Results of inspecting a list of items.
 *
 * @generated from message google.privacy.dlp.v2beta1.InspectContentResponse
 */
export class InspectContentResponse extends Message<InspectContentResponse> {
  /**
   * Each content_item from the request has a result in this list, in the
   * same order as the request.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.InspectResult results = 1;
   */
  results: InspectResult[] = [];

  constructor(data?: PartialMessage<InspectContentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.InspectContentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "results", kind: "message", T: InspectResult, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InspectContentResponse {
    return new InspectContentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InspectContentResponse {
    return new InspectContentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InspectContentResponse {
    return new InspectContentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: InspectContentResponse | PlainMessage<InspectContentResponse> | undefined, b: InspectContentResponse | PlainMessage<InspectContentResponse> | undefined): boolean {
    return proto3.util.equals(InspectContentResponse, a, b);
  }
}

/**
 * Request for scheduling a scan of a data subset from a Google Platform data
 * repository.
 *
 * @generated from message google.privacy.dlp.v2beta1.CreateInspectOperationRequest
 */
export class CreateInspectOperationRequest extends Message<CreateInspectOperationRequest> {
  /**
   * Configuration for the inspector.
   *
   * @generated from field: google.privacy.dlp.v2beta1.InspectConfig inspect_config = 1;
   */
  inspectConfig?: InspectConfig;

  /**
   * Specification of the data set to process.
   *
   * @generated from field: google.privacy.dlp.v2beta1.StorageConfig storage_config = 2;
   */
  storageConfig?: StorageConfig;

  /**
   * Optional location to store findings.
   *
   * @generated from field: google.privacy.dlp.v2beta1.OutputStorageConfig output_config = 3;
   */
  outputConfig?: OutputStorageConfig;

  /**
   * Additional configuration settings for long running operations.
   *
   * @generated from field: google.privacy.dlp.v2beta1.OperationConfig operation_config = 5;
   */
  operationConfig?: OperationConfig;

  constructor(data?: PartialMessage<CreateInspectOperationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.CreateInspectOperationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inspect_config", kind: "message", T: InspectConfig },
    { no: 2, name: "storage_config", kind: "message", T: StorageConfig },
    { no: 3, name: "output_config", kind: "message", T: OutputStorageConfig },
    { no: 5, name: "operation_config", kind: "message", T: OperationConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateInspectOperationRequest {
    return new CreateInspectOperationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateInspectOperationRequest {
    return new CreateInspectOperationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateInspectOperationRequest {
    return new CreateInspectOperationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateInspectOperationRequest | PlainMessage<CreateInspectOperationRequest> | undefined, b: CreateInspectOperationRequest | PlainMessage<CreateInspectOperationRequest> | undefined): boolean {
    return proto3.util.equals(CreateInspectOperationRequest, a, b);
  }
}

/**
 * Cloud repository for storing output.
 *
 * @generated from message google.privacy.dlp.v2beta1.OutputStorageConfig
 */
export class OutputStorageConfig extends Message<OutputStorageConfig> {
  /**
   * @generated from oneof google.privacy.dlp.v2beta1.OutputStorageConfig.type
   */
  type: {
    /**
     * Store findings in a new table in the dataset.
     *
     * @generated from field: google.privacy.dlp.v2beta1.BigQueryTable table = 1;
     */
    value: BigQueryTable;
    case: "table";
  } | {
    /**
     * The path to a Google Cloud Storage location to store output.
     * The bucket must already exist and
     * the Google APIs service account for DLP must have write permission to
     * write to the given bucket.
     * Results are split over multiple csv files with each file name matching
     * the pattern "[operation_id]_[count].csv", for example
     * `3094877188788974909_1.csv`. The `operation_id` matches the
     * identifier for the Operation, and the `count` is a counter used for
     * tracking the number of files written.
     *
     * The CSV file(s) contain the following columns regardless of storage type
     * scanned:
     * - id
     * - info_type
     * - likelihood
     * - byte size of finding
     * - quote
     * - timestamp
     *
     * For Cloud Storage the next columns are:
     *
     * - file_path
     * - start_offset
     *
     * For Cloud Datastore the next columns are:
     *
     * - project_id
     * - namespace_id
     * - path
     * - column_name
     * - offset
     *
     * For BigQuery the next columns are:
     *
     * - row_number
     * - project_id
     * - dataset_id
     * - table_id
     *
     * @generated from field: google.privacy.dlp.v2beta1.CloudStoragePath storage_path = 2;
     */
    value: CloudStoragePath;
    case: "storagePath";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<OutputStorageConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.OutputStorageConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table", kind: "message", T: BigQueryTable, oneof: "type" },
    { no: 2, name: "storage_path", kind: "message", T: CloudStoragePath, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OutputStorageConfig {
    return new OutputStorageConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OutputStorageConfig {
    return new OutputStorageConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OutputStorageConfig {
    return new OutputStorageConfig().fromJsonString(jsonString, options);
  }

  static equals(a: OutputStorageConfig | PlainMessage<OutputStorageConfig> | undefined, b: OutputStorageConfig | PlainMessage<OutputStorageConfig> | undefined): boolean {
    return proto3.util.equals(OutputStorageConfig, a, b);
  }
}

/**
 * Statistics regarding a specific InfoType.
 *
 * @generated from message google.privacy.dlp.v2beta1.InfoTypeStatistics
 */
export class InfoTypeStatistics extends Message<InfoTypeStatistics> {
  /**
   * The type of finding this stat is for.
   *
   * @generated from field: google.privacy.dlp.v2beta1.InfoType info_type = 1;
   */
  infoType?: InfoType;

  /**
   * Number of findings for this info type.
   *
   * @generated from field: int64 count = 2;
   */
  count = protoInt64.zero;

  constructor(data?: PartialMessage<InfoTypeStatistics>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.InfoTypeStatistics";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "info_type", kind: "message", T: InfoType },
    { no: 2, name: "count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InfoTypeStatistics {
    return new InfoTypeStatistics().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InfoTypeStatistics {
    return new InfoTypeStatistics().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InfoTypeStatistics {
    return new InfoTypeStatistics().fromJsonString(jsonString, options);
  }

  static equals(a: InfoTypeStatistics | PlainMessage<InfoTypeStatistics> | undefined, b: InfoTypeStatistics | PlainMessage<InfoTypeStatistics> | undefined): boolean {
    return proto3.util.equals(InfoTypeStatistics, a, b);
  }
}

/**
 * Metadata returned within GetOperation for an inspect request.
 *
 * @generated from message google.privacy.dlp.v2beta1.InspectOperationMetadata
 */
export class InspectOperationMetadata extends Message<InspectOperationMetadata> {
  /**
   * Total size in bytes that were processed.
   *
   * @generated from field: int64 processed_bytes = 1;
   */
  processedBytes = protoInt64.zero;

  /**
   * Estimate of the number of bytes to process.
   *
   * @generated from field: int64 total_estimated_bytes = 4;
   */
  totalEstimatedBytes = protoInt64.zero;

  /**
   * @generated from field: repeated google.privacy.dlp.v2beta1.InfoTypeStatistics info_type_stats = 2;
   */
  infoTypeStats: InfoTypeStatistics[] = [];

  /**
   * The time which this request was started.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 3;
   */
  createTime?: Timestamp;

  /**
   * The inspect config used to create the Operation.
   *
   * @generated from field: google.privacy.dlp.v2beta1.InspectConfig request_inspect_config = 5;
   */
  requestInspectConfig?: InspectConfig;

  /**
   * The storage config used to create the Operation.
   *
   * @generated from field: google.privacy.dlp.v2beta1.StorageConfig request_storage_config = 6;
   */
  requestStorageConfig?: StorageConfig;

  /**
   * Optional location to store findings.
   *
   * @generated from field: google.privacy.dlp.v2beta1.OutputStorageConfig request_output_config = 7;
   */
  requestOutputConfig?: OutputStorageConfig;

  constructor(data?: PartialMessage<InspectOperationMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.InspectOperationMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "processed_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "total_estimated_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "info_type_stats", kind: "message", T: InfoTypeStatistics, repeated: true },
    { no: 3, name: "create_time", kind: "message", T: Timestamp },
    { no: 5, name: "request_inspect_config", kind: "message", T: InspectConfig },
    { no: 6, name: "request_storage_config", kind: "message", T: StorageConfig },
    { no: 7, name: "request_output_config", kind: "message", T: OutputStorageConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InspectOperationMetadata {
    return new InspectOperationMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InspectOperationMetadata {
    return new InspectOperationMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InspectOperationMetadata {
    return new InspectOperationMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: InspectOperationMetadata | PlainMessage<InspectOperationMetadata> | undefined, b: InspectOperationMetadata | PlainMessage<InspectOperationMetadata> | undefined): boolean {
    return proto3.util.equals(InspectOperationMetadata, a, b);
  }
}

/**
 * The operational data.
 *
 * @generated from message google.privacy.dlp.v2beta1.InspectOperationResult
 */
export class InspectOperationResult extends Message<InspectOperationResult> {
  /**
   * The server-assigned name, which is only unique within the same service that
   * originally returns it. If you use the default HTTP mapping, the
   * `name` should have the format of `inspect/results/{id}`.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<InspectOperationResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.InspectOperationResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InspectOperationResult {
    return new InspectOperationResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InspectOperationResult {
    return new InspectOperationResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InspectOperationResult {
    return new InspectOperationResult().fromJsonString(jsonString, options);
  }

  static equals(a: InspectOperationResult | PlainMessage<InspectOperationResult> | undefined, b: InspectOperationResult | PlainMessage<InspectOperationResult> | undefined): boolean {
    return proto3.util.equals(InspectOperationResult, a, b);
  }
}

/**
 * Request for the list of results in a given inspect operation.
 *
 * @generated from message google.privacy.dlp.v2beta1.ListInspectFindingsRequest
 */
export class ListInspectFindingsRequest extends Message<ListInspectFindingsRequest> {
  /**
   * Identifier of the results set returned as metadata of
   * the longrunning operation created by a call to InspectDataSource.
   * Should be in the format of `inspect/results/{id}`.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Maximum number of results to return.
   * If 0, the implementation selects a reasonable value.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * The value returned by the last `ListInspectFindingsResponse`; indicates
   * that this is a continuation of a prior `ListInspectFindings` call, and that
   * the system should return the next page of data.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken = "";

  /**
   * Restricts findings to items that match. Supports info_type and likelihood.
   *
   * Examples:
   *
   * - info_type=EMAIL_ADDRESS
   * - info_type=PHONE_NUMBER,EMAIL_ADDRESS
   * - likelihood=VERY_LIKELY
   * - likelihood=VERY_LIKELY,LIKELY
   * - info_type=EMAIL_ADDRESS,likelihood=VERY_LIKELY,LIKELY
   *
   * @generated from field: string filter = 4;
   */
  filter = "";

  constructor(data?: PartialMessage<ListInspectFindingsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.ListInspectFindingsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListInspectFindingsRequest {
    return new ListInspectFindingsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListInspectFindingsRequest {
    return new ListInspectFindingsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListInspectFindingsRequest {
    return new ListInspectFindingsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListInspectFindingsRequest | PlainMessage<ListInspectFindingsRequest> | undefined, b: ListInspectFindingsRequest | PlainMessage<ListInspectFindingsRequest> | undefined): boolean {
    return proto3.util.equals(ListInspectFindingsRequest, a, b);
  }
}

/**
 * Response to the ListInspectFindings request.
 *
 * @generated from message google.privacy.dlp.v2beta1.ListInspectFindingsResponse
 */
export class ListInspectFindingsResponse extends Message<ListInspectFindingsResponse> {
  /**
   * The results.
   *
   * @generated from field: google.privacy.dlp.v2beta1.InspectResult result = 1;
   */
  result?: InspectResult;

  /**
   * If not empty, indicates that there may be more results that match the
   * request; this value should be passed in a new `ListInspectFindingsRequest`.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListInspectFindingsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.ListInspectFindingsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "message", T: InspectResult },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListInspectFindingsResponse {
    return new ListInspectFindingsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListInspectFindingsResponse {
    return new ListInspectFindingsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListInspectFindingsResponse {
    return new ListInspectFindingsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListInspectFindingsResponse | PlainMessage<ListInspectFindingsResponse> | undefined, b: ListInspectFindingsResponse | PlainMessage<ListInspectFindingsResponse> | undefined): boolean {
    return proto3.util.equals(ListInspectFindingsResponse, a, b);
  }
}

/**
 * Description of the information type (infoType).
 *
 * @generated from message google.privacy.dlp.v2beta1.InfoTypeDescription
 */
export class InfoTypeDescription extends Message<InfoTypeDescription> {
  /**
   * Internal name of the infoType.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Human readable form of the infoType name.
   *
   * @generated from field: string display_name = 2;
   */
  displayName = "";

  /**
   * List of categories this infoType belongs to.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.CategoryDescription categories = 3;
   */
  categories: CategoryDescription[] = [];

  constructor(data?: PartialMessage<InfoTypeDescription>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.InfoTypeDescription";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "categories", kind: "message", T: CategoryDescription, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InfoTypeDescription {
    return new InfoTypeDescription().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InfoTypeDescription {
    return new InfoTypeDescription().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InfoTypeDescription {
    return new InfoTypeDescription().fromJsonString(jsonString, options);
  }

  static equals(a: InfoTypeDescription | PlainMessage<InfoTypeDescription> | undefined, b: InfoTypeDescription | PlainMessage<InfoTypeDescription> | undefined): boolean {
    return proto3.util.equals(InfoTypeDescription, a, b);
  }
}

/**
 * Request for the list of info types belonging to a given category,
 * or all supported info types if no category is specified.
 *
 * @generated from message google.privacy.dlp.v2beta1.ListInfoTypesRequest
 */
export class ListInfoTypesRequest extends Message<ListInfoTypesRequest> {
  /**
   * Category name as returned by ListRootCategories.
   *
   * @generated from field: string category = 1;
   */
  category = "";

  /**
   * Optional BCP-47 language code for localized info type friendly
   * names. If omitted, or if localized strings are not available,
   * en-US strings will be returned.
   *
   * @generated from field: string language_code = 2;
   */
  languageCode = "";

  constructor(data?: PartialMessage<ListInfoTypesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.ListInfoTypesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "category", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "language_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListInfoTypesRequest {
    return new ListInfoTypesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListInfoTypesRequest {
    return new ListInfoTypesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListInfoTypesRequest {
    return new ListInfoTypesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListInfoTypesRequest | PlainMessage<ListInfoTypesRequest> | undefined, b: ListInfoTypesRequest | PlainMessage<ListInfoTypesRequest> | undefined): boolean {
    return proto3.util.equals(ListInfoTypesRequest, a, b);
  }
}

/**
 * Response to the ListInfoTypes request.
 *
 * @generated from message google.privacy.dlp.v2beta1.ListInfoTypesResponse
 */
export class ListInfoTypesResponse extends Message<ListInfoTypesResponse> {
  /**
   * Set of sensitive info types belonging to a category.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.InfoTypeDescription info_types = 1;
   */
  infoTypes: InfoTypeDescription[] = [];

  constructor(data?: PartialMessage<ListInfoTypesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.ListInfoTypesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "info_types", kind: "message", T: InfoTypeDescription, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListInfoTypesResponse {
    return new ListInfoTypesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListInfoTypesResponse {
    return new ListInfoTypesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListInfoTypesResponse {
    return new ListInfoTypesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListInfoTypesResponse | PlainMessage<ListInfoTypesResponse> | undefined, b: ListInfoTypesResponse | PlainMessage<ListInfoTypesResponse> | undefined): boolean {
    return proto3.util.equals(ListInfoTypesResponse, a, b);
  }
}

/**
 * Info Type Category description.
 *
 * @generated from message google.privacy.dlp.v2beta1.CategoryDescription
 */
export class CategoryDescription extends Message<CategoryDescription> {
  /**
   * Internal name of the category.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Human readable form of the category name.
   *
   * @generated from field: string display_name = 2;
   */
  displayName = "";

  constructor(data?: PartialMessage<CategoryDescription>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.CategoryDescription";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "display_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CategoryDescription {
    return new CategoryDescription().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CategoryDescription {
    return new CategoryDescription().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CategoryDescription {
    return new CategoryDescription().fromJsonString(jsonString, options);
  }

  static equals(a: CategoryDescription | PlainMessage<CategoryDescription> | undefined, b: CategoryDescription | PlainMessage<CategoryDescription> | undefined): boolean {
    return proto3.util.equals(CategoryDescription, a, b);
  }
}

/**
 * Request for root categories of Info Types supported by the API.
 * Example values might include "FINANCE", "HEALTH", "FAST", "DEFAULT".
 *
 * @generated from message google.privacy.dlp.v2beta1.ListRootCategoriesRequest
 */
export class ListRootCategoriesRequest extends Message<ListRootCategoriesRequest> {
  /**
   * Optional language code for localized friendly category names.
   * If omitted or if localized strings are not available,
   * en-US strings will be returned.
   *
   * @generated from field: string language_code = 1;
   */
  languageCode = "";

  constructor(data?: PartialMessage<ListRootCategoriesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.ListRootCategoriesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "language_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListRootCategoriesRequest {
    return new ListRootCategoriesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListRootCategoriesRequest {
    return new ListRootCategoriesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListRootCategoriesRequest {
    return new ListRootCategoriesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListRootCategoriesRequest | PlainMessage<ListRootCategoriesRequest> | undefined, b: ListRootCategoriesRequest | PlainMessage<ListRootCategoriesRequest> | undefined): boolean {
    return proto3.util.equals(ListRootCategoriesRequest, a, b);
  }
}

/**
 * Response for ListRootCategories request.
 *
 * @generated from message google.privacy.dlp.v2beta1.ListRootCategoriesResponse
 */
export class ListRootCategoriesResponse extends Message<ListRootCategoriesResponse> {
  /**
   * List of all into type categories supported by the API.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.CategoryDescription categories = 1;
   */
  categories: CategoryDescription[] = [];

  constructor(data?: PartialMessage<ListRootCategoriesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.ListRootCategoriesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "categories", kind: "message", T: CategoryDescription, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListRootCategoriesResponse {
    return new ListRootCategoriesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListRootCategoriesResponse {
    return new ListRootCategoriesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListRootCategoriesResponse {
    return new ListRootCategoriesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListRootCategoriesResponse | PlainMessage<ListRootCategoriesResponse> | undefined, b: ListRootCategoriesResponse | PlainMessage<ListRootCategoriesResponse> | undefined): boolean {
    return proto3.util.equals(ListRootCategoriesResponse, a, b);
  }
}

/**
 * Request for creating a risk analysis operation.
 *
 * @generated from message google.privacy.dlp.v2beta1.AnalyzeDataSourceRiskRequest
 */
export class AnalyzeDataSourceRiskRequest extends Message<AnalyzeDataSourceRiskRequest> {
  /**
   * Privacy metric to compute.
   *
   * @generated from field: google.privacy.dlp.v2beta1.PrivacyMetric privacy_metric = 1;
   */
  privacyMetric?: PrivacyMetric;

  /**
   * Input dataset to compute metrics over.
   *
   * @generated from field: google.privacy.dlp.v2beta1.BigQueryTable source_table = 3;
   */
  sourceTable?: BigQueryTable;

  constructor(data?: PartialMessage<AnalyzeDataSourceRiskRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.AnalyzeDataSourceRiskRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "privacy_metric", kind: "message", T: PrivacyMetric },
    { no: 3, name: "source_table", kind: "message", T: BigQueryTable },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnalyzeDataSourceRiskRequest {
    return new AnalyzeDataSourceRiskRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnalyzeDataSourceRiskRequest {
    return new AnalyzeDataSourceRiskRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnalyzeDataSourceRiskRequest {
    return new AnalyzeDataSourceRiskRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AnalyzeDataSourceRiskRequest | PlainMessage<AnalyzeDataSourceRiskRequest> | undefined, b: AnalyzeDataSourceRiskRequest | PlainMessage<AnalyzeDataSourceRiskRequest> | undefined): boolean {
    return proto3.util.equals(AnalyzeDataSourceRiskRequest, a, b);
  }
}

/**
 * Privacy metric to compute for reidentification risk analysis.
 *
 * @generated from message google.privacy.dlp.v2beta1.PrivacyMetric
 */
export class PrivacyMetric extends Message<PrivacyMetric> {
  /**
   * @generated from oneof google.privacy.dlp.v2beta1.PrivacyMetric.type
   */
  type: {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.PrivacyMetric.NumericalStatsConfig numerical_stats_config = 1;
     */
    value: PrivacyMetric_NumericalStatsConfig;
    case: "numericalStatsConfig";
  } | {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.PrivacyMetric.CategoricalStatsConfig categorical_stats_config = 2;
     */
    value: PrivacyMetric_CategoricalStatsConfig;
    case: "categoricalStatsConfig";
  } | {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.PrivacyMetric.KAnonymityConfig k_anonymity_config = 3;
     */
    value: PrivacyMetric_KAnonymityConfig;
    case: "kAnonymityConfig";
  } | {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.PrivacyMetric.LDiversityConfig l_diversity_config = 4;
     */
    value: PrivacyMetric_LDiversityConfig;
    case: "lDiversityConfig";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<PrivacyMetric>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.PrivacyMetric";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "numerical_stats_config", kind: "message", T: PrivacyMetric_NumericalStatsConfig, oneof: "type" },
    { no: 2, name: "categorical_stats_config", kind: "message", T: PrivacyMetric_CategoricalStatsConfig, oneof: "type" },
    { no: 3, name: "k_anonymity_config", kind: "message", T: PrivacyMetric_KAnonymityConfig, oneof: "type" },
    { no: 4, name: "l_diversity_config", kind: "message", T: PrivacyMetric_LDiversityConfig, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrivacyMetric {
    return new PrivacyMetric().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrivacyMetric {
    return new PrivacyMetric().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrivacyMetric {
    return new PrivacyMetric().fromJsonString(jsonString, options);
  }

  static equals(a: PrivacyMetric | PlainMessage<PrivacyMetric> | undefined, b: PrivacyMetric | PlainMessage<PrivacyMetric> | undefined): boolean {
    return proto3.util.equals(PrivacyMetric, a, b);
  }
}

/**
 * Compute numerical stats over an individual column, including
 * min, max, and quantiles.
 *
 * @generated from message google.privacy.dlp.v2beta1.PrivacyMetric.NumericalStatsConfig
 */
export class PrivacyMetric_NumericalStatsConfig extends Message<PrivacyMetric_NumericalStatsConfig> {
  /**
   * Field to compute numerical stats on. Supported types are
   * integer, float, date, datetime, timestamp, time.
   *
   * @generated from field: google.privacy.dlp.v2beta1.FieldId field = 1;
   */
  field?: FieldId;

  constructor(data?: PartialMessage<PrivacyMetric_NumericalStatsConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.PrivacyMetric.NumericalStatsConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field", kind: "message", T: FieldId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrivacyMetric_NumericalStatsConfig {
    return new PrivacyMetric_NumericalStatsConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrivacyMetric_NumericalStatsConfig {
    return new PrivacyMetric_NumericalStatsConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrivacyMetric_NumericalStatsConfig {
    return new PrivacyMetric_NumericalStatsConfig().fromJsonString(jsonString, options);
  }

  static equals(a: PrivacyMetric_NumericalStatsConfig | PlainMessage<PrivacyMetric_NumericalStatsConfig> | undefined, b: PrivacyMetric_NumericalStatsConfig | PlainMessage<PrivacyMetric_NumericalStatsConfig> | undefined): boolean {
    return proto3.util.equals(PrivacyMetric_NumericalStatsConfig, a, b);
  }
}

/**
 * Compute numerical stats over an individual column, including
 * number of distinct values and value count distribution.
 *
 * @generated from message google.privacy.dlp.v2beta1.PrivacyMetric.CategoricalStatsConfig
 */
export class PrivacyMetric_CategoricalStatsConfig extends Message<PrivacyMetric_CategoricalStatsConfig> {
  /**
   * Field to compute categorical stats on. All column types are
   * supported except for arrays and structs. However, it may be more
   * informative to use NumericalStats when the field type is supported,
   * depending on the data.
   *
   * @generated from field: google.privacy.dlp.v2beta1.FieldId field = 1;
   */
  field?: FieldId;

  constructor(data?: PartialMessage<PrivacyMetric_CategoricalStatsConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.PrivacyMetric.CategoricalStatsConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field", kind: "message", T: FieldId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrivacyMetric_CategoricalStatsConfig {
    return new PrivacyMetric_CategoricalStatsConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrivacyMetric_CategoricalStatsConfig {
    return new PrivacyMetric_CategoricalStatsConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrivacyMetric_CategoricalStatsConfig {
    return new PrivacyMetric_CategoricalStatsConfig().fromJsonString(jsonString, options);
  }

  static equals(a: PrivacyMetric_CategoricalStatsConfig | PlainMessage<PrivacyMetric_CategoricalStatsConfig> | undefined, b: PrivacyMetric_CategoricalStatsConfig | PlainMessage<PrivacyMetric_CategoricalStatsConfig> | undefined): boolean {
    return proto3.util.equals(PrivacyMetric_CategoricalStatsConfig, a, b);
  }
}

/**
 * k-anonymity metric, used for analysis of reidentification risk.
 *
 * @generated from message google.privacy.dlp.v2beta1.PrivacyMetric.KAnonymityConfig
 */
export class PrivacyMetric_KAnonymityConfig extends Message<PrivacyMetric_KAnonymityConfig> {
  /**
   * Set of fields to compute k-anonymity over. When multiple fields are
   * specified, they are considered a single composite key. Structs and
   * repeated data types are not supported; however, nested fields are
   * supported so long as they are not structs themselves or nested within
   * a repeated field.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.FieldId quasi_ids = 1;
   */
  quasiIds: FieldId[] = [];

  /**
   * Optional message indicating that each distinct `EntityId` should not
   * contribute to the k-anonymity count more than once per equivalence class.
   *
   * @generated from field: google.privacy.dlp.v2beta1.EntityId entity_id = 2;
   */
  entityId?: EntityId;

  constructor(data?: PartialMessage<PrivacyMetric_KAnonymityConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.PrivacyMetric.KAnonymityConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "quasi_ids", kind: "message", T: FieldId, repeated: true },
    { no: 2, name: "entity_id", kind: "message", T: EntityId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrivacyMetric_KAnonymityConfig {
    return new PrivacyMetric_KAnonymityConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrivacyMetric_KAnonymityConfig {
    return new PrivacyMetric_KAnonymityConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrivacyMetric_KAnonymityConfig {
    return new PrivacyMetric_KAnonymityConfig().fromJsonString(jsonString, options);
  }

  static equals(a: PrivacyMetric_KAnonymityConfig | PlainMessage<PrivacyMetric_KAnonymityConfig> | undefined, b: PrivacyMetric_KAnonymityConfig | PlainMessage<PrivacyMetric_KAnonymityConfig> | undefined): boolean {
    return proto3.util.equals(PrivacyMetric_KAnonymityConfig, a, b);
  }
}

/**
 * l-diversity metric, used for analysis of reidentification risk.
 *
 * @generated from message google.privacy.dlp.v2beta1.PrivacyMetric.LDiversityConfig
 */
export class PrivacyMetric_LDiversityConfig extends Message<PrivacyMetric_LDiversityConfig> {
  /**
   * Set of quasi-identifiers indicating how equivalence classes are
   * defined for the l-diversity computation. When multiple fields are
   * specified, they are considered a single composite key.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.FieldId quasi_ids = 1;
   */
  quasiIds: FieldId[] = [];

  /**
   * Sensitive field for computing the l-value.
   *
   * @generated from field: google.privacy.dlp.v2beta1.FieldId sensitive_attribute = 2;
   */
  sensitiveAttribute?: FieldId;

  constructor(data?: PartialMessage<PrivacyMetric_LDiversityConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.PrivacyMetric.LDiversityConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "quasi_ids", kind: "message", T: FieldId, repeated: true },
    { no: 2, name: "sensitive_attribute", kind: "message", T: FieldId },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrivacyMetric_LDiversityConfig {
    return new PrivacyMetric_LDiversityConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrivacyMetric_LDiversityConfig {
    return new PrivacyMetric_LDiversityConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrivacyMetric_LDiversityConfig {
    return new PrivacyMetric_LDiversityConfig().fromJsonString(jsonString, options);
  }

  static equals(a: PrivacyMetric_LDiversityConfig | PlainMessage<PrivacyMetric_LDiversityConfig> | undefined, b: PrivacyMetric_LDiversityConfig | PlainMessage<PrivacyMetric_LDiversityConfig> | undefined): boolean {
    return proto3.util.equals(PrivacyMetric_LDiversityConfig, a, b);
  }
}

/**
 * Metadata returned within the
 * [`riskAnalysis.operations.get`](/dlp/docs/reference/rest/v2beta1/riskAnalysis.operations/get)
 * for risk analysis.
 *
 * @generated from message google.privacy.dlp.v2beta1.RiskAnalysisOperationMetadata
 */
export class RiskAnalysisOperationMetadata extends Message<RiskAnalysisOperationMetadata> {
  /**
   * The time which this request was started.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 1;
   */
  createTime?: Timestamp;

  /**
   * Privacy metric to compute.
   *
   * @generated from field: google.privacy.dlp.v2beta1.PrivacyMetric requested_privacy_metric = 2;
   */
  requestedPrivacyMetric?: PrivacyMetric;

  /**
   * Input dataset to compute metrics over.
   *
   * @generated from field: google.privacy.dlp.v2beta1.BigQueryTable requested_source_table = 3;
   */
  requestedSourceTable?: BigQueryTable;

  constructor(data?: PartialMessage<RiskAnalysisOperationMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.RiskAnalysisOperationMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "create_time", kind: "message", T: Timestamp },
    { no: 2, name: "requested_privacy_metric", kind: "message", T: PrivacyMetric },
    { no: 3, name: "requested_source_table", kind: "message", T: BigQueryTable },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RiskAnalysisOperationMetadata {
    return new RiskAnalysisOperationMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RiskAnalysisOperationMetadata {
    return new RiskAnalysisOperationMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RiskAnalysisOperationMetadata {
    return new RiskAnalysisOperationMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: RiskAnalysisOperationMetadata | PlainMessage<RiskAnalysisOperationMetadata> | undefined, b: RiskAnalysisOperationMetadata | PlainMessage<RiskAnalysisOperationMetadata> | undefined): boolean {
    return proto3.util.equals(RiskAnalysisOperationMetadata, a, b);
  }
}

/**
 * Result of a risk analysis
 * [`Operation`](/dlp/docs/reference/rest/v2beta1/inspect.operations)
 * request.
 *
 * @generated from message google.privacy.dlp.v2beta1.RiskAnalysisOperationResult
 */
export class RiskAnalysisOperationResult extends Message<RiskAnalysisOperationResult> {
  /**
   * Values associated with this metric.
   *
   * @generated from oneof google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.result
   */
  result: {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.NumericalStatsResult numerical_stats_result = 3;
     */
    value: RiskAnalysisOperationResult_NumericalStatsResult;
    case: "numericalStatsResult";
  } | {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.CategoricalStatsResult categorical_stats_result = 4;
     */
    value: RiskAnalysisOperationResult_CategoricalStatsResult;
    case: "categoricalStatsResult";
  } | {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.KAnonymityResult k_anonymity_result = 5;
     */
    value: RiskAnalysisOperationResult_KAnonymityResult;
    case: "kAnonymityResult";
  } | {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.LDiversityResult l_diversity_result = 6;
     */
    value: RiskAnalysisOperationResult_LDiversityResult;
    case: "lDiversityResult";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<RiskAnalysisOperationResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.RiskAnalysisOperationResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "numerical_stats_result", kind: "message", T: RiskAnalysisOperationResult_NumericalStatsResult, oneof: "result" },
    { no: 4, name: "categorical_stats_result", kind: "message", T: RiskAnalysisOperationResult_CategoricalStatsResult, oneof: "result" },
    { no: 5, name: "k_anonymity_result", kind: "message", T: RiskAnalysisOperationResult_KAnonymityResult, oneof: "result" },
    { no: 6, name: "l_diversity_result", kind: "message", T: RiskAnalysisOperationResult_LDiversityResult, oneof: "result" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RiskAnalysisOperationResult {
    return new RiskAnalysisOperationResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RiskAnalysisOperationResult {
    return new RiskAnalysisOperationResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RiskAnalysisOperationResult {
    return new RiskAnalysisOperationResult().fromJsonString(jsonString, options);
  }

  static equals(a: RiskAnalysisOperationResult | PlainMessage<RiskAnalysisOperationResult> | undefined, b: RiskAnalysisOperationResult | PlainMessage<RiskAnalysisOperationResult> | undefined): boolean {
    return proto3.util.equals(RiskAnalysisOperationResult, a, b);
  }
}

/**
 * Result of the numerical stats computation.
 *
 * @generated from message google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.NumericalStatsResult
 */
export class RiskAnalysisOperationResult_NumericalStatsResult extends Message<RiskAnalysisOperationResult_NumericalStatsResult> {
  /**
   * Minimum value appearing in the column.
   *
   * @generated from field: google.privacy.dlp.v2beta1.Value min_value = 1;
   */
  minValue?: Value;

  /**
   * Maximum value appearing in the column.
   *
   * @generated from field: google.privacy.dlp.v2beta1.Value max_value = 2;
   */
  maxValue?: Value;

  /**
   * List of 99 values that partition the set of field values into 100 equal
   * sized buckets.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.Value quantile_values = 4;
   */
  quantileValues: Value[] = [];

  constructor(data?: PartialMessage<RiskAnalysisOperationResult_NumericalStatsResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.NumericalStatsResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min_value", kind: "message", T: Value },
    { no: 2, name: "max_value", kind: "message", T: Value },
    { no: 4, name: "quantile_values", kind: "message", T: Value, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RiskAnalysisOperationResult_NumericalStatsResult {
    return new RiskAnalysisOperationResult_NumericalStatsResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RiskAnalysisOperationResult_NumericalStatsResult {
    return new RiskAnalysisOperationResult_NumericalStatsResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RiskAnalysisOperationResult_NumericalStatsResult {
    return new RiskAnalysisOperationResult_NumericalStatsResult().fromJsonString(jsonString, options);
  }

  static equals(a: RiskAnalysisOperationResult_NumericalStatsResult | PlainMessage<RiskAnalysisOperationResult_NumericalStatsResult> | undefined, b: RiskAnalysisOperationResult_NumericalStatsResult | PlainMessage<RiskAnalysisOperationResult_NumericalStatsResult> | undefined): boolean {
    return proto3.util.equals(RiskAnalysisOperationResult_NumericalStatsResult, a, b);
  }
}

/**
 * Result of the categorical stats computation.
 *
 * @generated from message google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.CategoricalStatsResult
 */
export class RiskAnalysisOperationResult_CategoricalStatsResult extends Message<RiskAnalysisOperationResult_CategoricalStatsResult> {
  /**
   * Histogram of value frequencies in the column.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.CategoricalStatsResult.CategoricalStatsHistogramBucket value_frequency_histogram_buckets = 5;
   */
  valueFrequencyHistogramBuckets: RiskAnalysisOperationResult_CategoricalStatsResult_CategoricalStatsHistogramBucket[] = [];

  constructor(data?: PartialMessage<RiskAnalysisOperationResult_CategoricalStatsResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.CategoricalStatsResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 5, name: "value_frequency_histogram_buckets", kind: "message", T: RiskAnalysisOperationResult_CategoricalStatsResult_CategoricalStatsHistogramBucket, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RiskAnalysisOperationResult_CategoricalStatsResult {
    return new RiskAnalysisOperationResult_CategoricalStatsResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RiskAnalysisOperationResult_CategoricalStatsResult {
    return new RiskAnalysisOperationResult_CategoricalStatsResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RiskAnalysisOperationResult_CategoricalStatsResult {
    return new RiskAnalysisOperationResult_CategoricalStatsResult().fromJsonString(jsonString, options);
  }

  static equals(a: RiskAnalysisOperationResult_CategoricalStatsResult | PlainMessage<RiskAnalysisOperationResult_CategoricalStatsResult> | undefined, b: RiskAnalysisOperationResult_CategoricalStatsResult | PlainMessage<RiskAnalysisOperationResult_CategoricalStatsResult> | undefined): boolean {
    return proto3.util.equals(RiskAnalysisOperationResult_CategoricalStatsResult, a, b);
  }
}

/**
 * Histogram bucket of value frequencies in the column.
 *
 * @generated from message google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.CategoricalStatsResult.CategoricalStatsHistogramBucket
 */
export class RiskAnalysisOperationResult_CategoricalStatsResult_CategoricalStatsHistogramBucket extends Message<RiskAnalysisOperationResult_CategoricalStatsResult_CategoricalStatsHistogramBucket> {
  /**
   * Lower bound on the value frequency of the values in this bucket.
   *
   * @generated from field: int64 value_frequency_lower_bound = 1;
   */
  valueFrequencyLowerBound = protoInt64.zero;

  /**
   * Upper bound on the value frequency of the values in this bucket.
   *
   * @generated from field: int64 value_frequency_upper_bound = 2;
   */
  valueFrequencyUpperBound = protoInt64.zero;

  /**
   * Total number of records in this bucket.
   *
   * @generated from field: int64 bucket_size = 3;
   */
  bucketSize = protoInt64.zero;

  /**
   * Sample of value frequencies in this bucket. The total number of
   * values returned per bucket is capped at 20.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.ValueFrequency bucket_values = 4;
   */
  bucketValues: ValueFrequency[] = [];

  constructor(data?: PartialMessage<RiskAnalysisOperationResult_CategoricalStatsResult_CategoricalStatsHistogramBucket>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.CategoricalStatsResult.CategoricalStatsHistogramBucket";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value_frequency_lower_bound", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "value_frequency_upper_bound", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "bucket_size", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "bucket_values", kind: "message", T: ValueFrequency, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RiskAnalysisOperationResult_CategoricalStatsResult_CategoricalStatsHistogramBucket {
    return new RiskAnalysisOperationResult_CategoricalStatsResult_CategoricalStatsHistogramBucket().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RiskAnalysisOperationResult_CategoricalStatsResult_CategoricalStatsHistogramBucket {
    return new RiskAnalysisOperationResult_CategoricalStatsResult_CategoricalStatsHistogramBucket().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RiskAnalysisOperationResult_CategoricalStatsResult_CategoricalStatsHistogramBucket {
    return new RiskAnalysisOperationResult_CategoricalStatsResult_CategoricalStatsHistogramBucket().fromJsonString(jsonString, options);
  }

  static equals(a: RiskAnalysisOperationResult_CategoricalStatsResult_CategoricalStatsHistogramBucket | PlainMessage<RiskAnalysisOperationResult_CategoricalStatsResult_CategoricalStatsHistogramBucket> | undefined, b: RiskAnalysisOperationResult_CategoricalStatsResult_CategoricalStatsHistogramBucket | PlainMessage<RiskAnalysisOperationResult_CategoricalStatsResult_CategoricalStatsHistogramBucket> | undefined): boolean {
    return proto3.util.equals(RiskAnalysisOperationResult_CategoricalStatsResult_CategoricalStatsHistogramBucket, a, b);
  }
}

/**
 * Result of the k-anonymity computation.
 *
 * @generated from message google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.KAnonymityResult
 */
export class RiskAnalysisOperationResult_KAnonymityResult extends Message<RiskAnalysisOperationResult_KAnonymityResult> {
  /**
   * Histogram of k-anonymity equivalence classes.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.KAnonymityResult.KAnonymityHistogramBucket equivalence_class_histogram_buckets = 5;
   */
  equivalenceClassHistogramBuckets: RiskAnalysisOperationResult_KAnonymityResult_KAnonymityHistogramBucket[] = [];

  constructor(data?: PartialMessage<RiskAnalysisOperationResult_KAnonymityResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.KAnonymityResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 5, name: "equivalence_class_histogram_buckets", kind: "message", T: RiskAnalysisOperationResult_KAnonymityResult_KAnonymityHistogramBucket, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RiskAnalysisOperationResult_KAnonymityResult {
    return new RiskAnalysisOperationResult_KAnonymityResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RiskAnalysisOperationResult_KAnonymityResult {
    return new RiskAnalysisOperationResult_KAnonymityResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RiskAnalysisOperationResult_KAnonymityResult {
    return new RiskAnalysisOperationResult_KAnonymityResult().fromJsonString(jsonString, options);
  }

  static equals(a: RiskAnalysisOperationResult_KAnonymityResult | PlainMessage<RiskAnalysisOperationResult_KAnonymityResult> | undefined, b: RiskAnalysisOperationResult_KAnonymityResult | PlainMessage<RiskAnalysisOperationResult_KAnonymityResult> | undefined): boolean {
    return proto3.util.equals(RiskAnalysisOperationResult_KAnonymityResult, a, b);
  }
}

/**
 * The set of columns' values that share the same k-anonymity value.
 *
 * @generated from message google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.KAnonymityResult.KAnonymityEquivalenceClass
 */
export class RiskAnalysisOperationResult_KAnonymityResult_KAnonymityEquivalenceClass extends Message<RiskAnalysisOperationResult_KAnonymityResult_KAnonymityEquivalenceClass> {
  /**
   * Set of values defining the equivalence class. One value per
   * quasi-identifier column in the original KAnonymity metric message.
   * The order is always the same as the original request.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.Value quasi_ids_values = 1;
   */
  quasiIdsValues: Value[] = [];

  /**
   * Size of the equivalence class, for example number of rows with the
   * above set of values.
   *
   * @generated from field: int64 equivalence_class_size = 2;
   */
  equivalenceClassSize = protoInt64.zero;

  constructor(data?: PartialMessage<RiskAnalysisOperationResult_KAnonymityResult_KAnonymityEquivalenceClass>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.KAnonymityResult.KAnonymityEquivalenceClass";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "quasi_ids_values", kind: "message", T: Value, repeated: true },
    { no: 2, name: "equivalence_class_size", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RiskAnalysisOperationResult_KAnonymityResult_KAnonymityEquivalenceClass {
    return new RiskAnalysisOperationResult_KAnonymityResult_KAnonymityEquivalenceClass().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RiskAnalysisOperationResult_KAnonymityResult_KAnonymityEquivalenceClass {
    return new RiskAnalysisOperationResult_KAnonymityResult_KAnonymityEquivalenceClass().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RiskAnalysisOperationResult_KAnonymityResult_KAnonymityEquivalenceClass {
    return new RiskAnalysisOperationResult_KAnonymityResult_KAnonymityEquivalenceClass().fromJsonString(jsonString, options);
  }

  static equals(a: RiskAnalysisOperationResult_KAnonymityResult_KAnonymityEquivalenceClass | PlainMessage<RiskAnalysisOperationResult_KAnonymityResult_KAnonymityEquivalenceClass> | undefined, b: RiskAnalysisOperationResult_KAnonymityResult_KAnonymityEquivalenceClass | PlainMessage<RiskAnalysisOperationResult_KAnonymityResult_KAnonymityEquivalenceClass> | undefined): boolean {
    return proto3.util.equals(RiskAnalysisOperationResult_KAnonymityResult_KAnonymityEquivalenceClass, a, b);
  }
}

/**
 * Histogram bucket of equivalence class sizes in the table.
 *
 * @generated from message google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.KAnonymityResult.KAnonymityHistogramBucket
 */
export class RiskAnalysisOperationResult_KAnonymityResult_KAnonymityHistogramBucket extends Message<RiskAnalysisOperationResult_KAnonymityResult_KAnonymityHistogramBucket> {
  /**
   * Lower bound on the size of the equivalence classes in this bucket.
   *
   * @generated from field: int64 equivalence_class_size_lower_bound = 1;
   */
  equivalenceClassSizeLowerBound = protoInt64.zero;

  /**
   * Upper bound on the size of the equivalence classes in this bucket.
   *
   * @generated from field: int64 equivalence_class_size_upper_bound = 2;
   */
  equivalenceClassSizeUpperBound = protoInt64.zero;

  /**
   * Total number of records in this bucket.
   *
   * @generated from field: int64 bucket_size = 3;
   */
  bucketSize = protoInt64.zero;

  /**
   * Sample of equivalence classes in this bucket. The total number of
   * classes returned per bucket is capped at 20.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.KAnonymityResult.KAnonymityEquivalenceClass bucket_values = 4;
   */
  bucketValues: RiskAnalysisOperationResult_KAnonymityResult_KAnonymityEquivalenceClass[] = [];

  constructor(data?: PartialMessage<RiskAnalysisOperationResult_KAnonymityResult_KAnonymityHistogramBucket>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.KAnonymityResult.KAnonymityHistogramBucket";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "equivalence_class_size_lower_bound", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "equivalence_class_size_upper_bound", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "bucket_size", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "bucket_values", kind: "message", T: RiskAnalysisOperationResult_KAnonymityResult_KAnonymityEquivalenceClass, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RiskAnalysisOperationResult_KAnonymityResult_KAnonymityHistogramBucket {
    return new RiskAnalysisOperationResult_KAnonymityResult_KAnonymityHistogramBucket().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RiskAnalysisOperationResult_KAnonymityResult_KAnonymityHistogramBucket {
    return new RiskAnalysisOperationResult_KAnonymityResult_KAnonymityHistogramBucket().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RiskAnalysisOperationResult_KAnonymityResult_KAnonymityHistogramBucket {
    return new RiskAnalysisOperationResult_KAnonymityResult_KAnonymityHistogramBucket().fromJsonString(jsonString, options);
  }

  static equals(a: RiskAnalysisOperationResult_KAnonymityResult_KAnonymityHistogramBucket | PlainMessage<RiskAnalysisOperationResult_KAnonymityResult_KAnonymityHistogramBucket> | undefined, b: RiskAnalysisOperationResult_KAnonymityResult_KAnonymityHistogramBucket | PlainMessage<RiskAnalysisOperationResult_KAnonymityResult_KAnonymityHistogramBucket> | undefined): boolean {
    return proto3.util.equals(RiskAnalysisOperationResult_KAnonymityResult_KAnonymityHistogramBucket, a, b);
  }
}

/**
 * Result of the l-diversity computation.
 *
 * @generated from message google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.LDiversityResult
 */
export class RiskAnalysisOperationResult_LDiversityResult extends Message<RiskAnalysisOperationResult_LDiversityResult> {
  /**
   * Histogram of l-diversity equivalence class sensitive value frequencies.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.LDiversityResult.LDiversityHistogramBucket sensitive_value_frequency_histogram_buckets = 5;
   */
  sensitiveValueFrequencyHistogramBuckets: RiskAnalysisOperationResult_LDiversityResult_LDiversityHistogramBucket[] = [];

  constructor(data?: PartialMessage<RiskAnalysisOperationResult_LDiversityResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.LDiversityResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 5, name: "sensitive_value_frequency_histogram_buckets", kind: "message", T: RiskAnalysisOperationResult_LDiversityResult_LDiversityHistogramBucket, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RiskAnalysisOperationResult_LDiversityResult {
    return new RiskAnalysisOperationResult_LDiversityResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RiskAnalysisOperationResult_LDiversityResult {
    return new RiskAnalysisOperationResult_LDiversityResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RiskAnalysisOperationResult_LDiversityResult {
    return new RiskAnalysisOperationResult_LDiversityResult().fromJsonString(jsonString, options);
  }

  static equals(a: RiskAnalysisOperationResult_LDiversityResult | PlainMessage<RiskAnalysisOperationResult_LDiversityResult> | undefined, b: RiskAnalysisOperationResult_LDiversityResult | PlainMessage<RiskAnalysisOperationResult_LDiversityResult> | undefined): boolean {
    return proto3.util.equals(RiskAnalysisOperationResult_LDiversityResult, a, b);
  }
}

/**
 * The set of columns' values that share the same l-diversity value.
 *
 * @generated from message google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.LDiversityResult.LDiversityEquivalenceClass
 */
export class RiskAnalysisOperationResult_LDiversityResult_LDiversityEquivalenceClass extends Message<RiskAnalysisOperationResult_LDiversityResult_LDiversityEquivalenceClass> {
  /**
   * Quasi-identifier values defining the k-anonymity equivalence
   * class. The order is always the same as the original request.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.Value quasi_ids_values = 1;
   */
  quasiIdsValues: Value[] = [];

  /**
   * Size of the k-anonymity equivalence class.
   *
   * @generated from field: int64 equivalence_class_size = 2;
   */
  equivalenceClassSize = protoInt64.zero;

  /**
   * Number of distinct sensitive values in this equivalence class.
   *
   * @generated from field: int64 num_distinct_sensitive_values = 3;
   */
  numDistinctSensitiveValues = protoInt64.zero;

  /**
   * Estimated frequencies of top sensitive values.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.ValueFrequency top_sensitive_values = 4;
   */
  topSensitiveValues: ValueFrequency[] = [];

  constructor(data?: PartialMessage<RiskAnalysisOperationResult_LDiversityResult_LDiversityEquivalenceClass>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.LDiversityResult.LDiversityEquivalenceClass";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "quasi_ids_values", kind: "message", T: Value, repeated: true },
    { no: 2, name: "equivalence_class_size", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "num_distinct_sensitive_values", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "top_sensitive_values", kind: "message", T: ValueFrequency, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RiskAnalysisOperationResult_LDiversityResult_LDiversityEquivalenceClass {
    return new RiskAnalysisOperationResult_LDiversityResult_LDiversityEquivalenceClass().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RiskAnalysisOperationResult_LDiversityResult_LDiversityEquivalenceClass {
    return new RiskAnalysisOperationResult_LDiversityResult_LDiversityEquivalenceClass().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RiskAnalysisOperationResult_LDiversityResult_LDiversityEquivalenceClass {
    return new RiskAnalysisOperationResult_LDiversityResult_LDiversityEquivalenceClass().fromJsonString(jsonString, options);
  }

  static equals(a: RiskAnalysisOperationResult_LDiversityResult_LDiversityEquivalenceClass | PlainMessage<RiskAnalysisOperationResult_LDiversityResult_LDiversityEquivalenceClass> | undefined, b: RiskAnalysisOperationResult_LDiversityResult_LDiversityEquivalenceClass | PlainMessage<RiskAnalysisOperationResult_LDiversityResult_LDiversityEquivalenceClass> | undefined): boolean {
    return proto3.util.equals(RiskAnalysisOperationResult_LDiversityResult_LDiversityEquivalenceClass, a, b);
  }
}

/**
 * Histogram bucket of sensitive value frequencies in the table.
 *
 * @generated from message google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.LDiversityResult.LDiversityHistogramBucket
 */
export class RiskAnalysisOperationResult_LDiversityResult_LDiversityHistogramBucket extends Message<RiskAnalysisOperationResult_LDiversityResult_LDiversityHistogramBucket> {
  /**
   * Lower bound on the sensitive value frequencies of the equivalence
   * classes in this bucket.
   *
   * @generated from field: int64 sensitive_value_frequency_lower_bound = 1;
   */
  sensitiveValueFrequencyLowerBound = protoInt64.zero;

  /**
   * Upper bound on the sensitive value frequencies of the equivalence
   * classes in this bucket.
   *
   * @generated from field: int64 sensitive_value_frequency_upper_bound = 2;
   */
  sensitiveValueFrequencyUpperBound = protoInt64.zero;

  /**
   * Total number of records in this bucket.
   *
   * @generated from field: int64 bucket_size = 3;
   */
  bucketSize = protoInt64.zero;

  /**
   * Sample of equivalence classes in this bucket. The total number of
   * classes returned per bucket is capped at 20.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.LDiversityResult.LDiversityEquivalenceClass bucket_values = 4;
   */
  bucketValues: RiskAnalysisOperationResult_LDiversityResult_LDiversityEquivalenceClass[] = [];

  constructor(data?: PartialMessage<RiskAnalysisOperationResult_LDiversityResult_LDiversityHistogramBucket>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.RiskAnalysisOperationResult.LDiversityResult.LDiversityHistogramBucket";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sensitive_value_frequency_lower_bound", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "sensitive_value_frequency_upper_bound", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "bucket_size", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "bucket_values", kind: "message", T: RiskAnalysisOperationResult_LDiversityResult_LDiversityEquivalenceClass, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RiskAnalysisOperationResult_LDiversityResult_LDiversityHistogramBucket {
    return new RiskAnalysisOperationResult_LDiversityResult_LDiversityHistogramBucket().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RiskAnalysisOperationResult_LDiversityResult_LDiversityHistogramBucket {
    return new RiskAnalysisOperationResult_LDiversityResult_LDiversityHistogramBucket().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RiskAnalysisOperationResult_LDiversityResult_LDiversityHistogramBucket {
    return new RiskAnalysisOperationResult_LDiversityResult_LDiversityHistogramBucket().fromJsonString(jsonString, options);
  }

  static equals(a: RiskAnalysisOperationResult_LDiversityResult_LDiversityHistogramBucket | PlainMessage<RiskAnalysisOperationResult_LDiversityResult_LDiversityHistogramBucket> | undefined, b: RiskAnalysisOperationResult_LDiversityResult_LDiversityHistogramBucket | PlainMessage<RiskAnalysisOperationResult_LDiversityResult_LDiversityHistogramBucket> | undefined): boolean {
    return proto3.util.equals(RiskAnalysisOperationResult_LDiversityResult_LDiversityHistogramBucket, a, b);
  }
}

/**
 * A value of a field, including its frequency.
 *
 * @generated from message google.privacy.dlp.v2beta1.ValueFrequency
 */
export class ValueFrequency extends Message<ValueFrequency> {
  /**
   * A value contained in the field in question.
   *
   * @generated from field: google.privacy.dlp.v2beta1.Value value = 1;
   */
  value?: Value;

  /**
   * How many times the value is contained in the field.
   *
   * @generated from field: int64 count = 2;
   */
  count = protoInt64.zero;

  constructor(data?: PartialMessage<ValueFrequency>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.ValueFrequency";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "message", T: Value },
    { no: 2, name: "count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValueFrequency {
    return new ValueFrequency().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValueFrequency {
    return new ValueFrequency().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValueFrequency {
    return new ValueFrequency().fromJsonString(jsonString, options);
  }

  static equals(a: ValueFrequency | PlainMessage<ValueFrequency> | undefined, b: ValueFrequency | PlainMessage<ValueFrequency> | undefined): boolean {
    return proto3.util.equals(ValueFrequency, a, b);
  }
}

/**
 * Set of primitive values supported by the system.
 *
 * @generated from message google.privacy.dlp.v2beta1.Value
 */
export class Value extends Message<Value> {
  /**
   * @generated from oneof google.privacy.dlp.v2beta1.Value.type
   */
  type: {
    /**
     * @generated from field: int64 integer_value = 1;
     */
    value: bigint;
    case: "integerValue";
  } | {
    /**
     * @generated from field: double float_value = 2;
     */
    value: number;
    case: "floatValue";
  } | {
    /**
     * @generated from field: string string_value = 3;
     */
    value: string;
    case: "stringValue";
  } | {
    /**
     * @generated from field: bool boolean_value = 4;
     */
    value: boolean;
    case: "booleanValue";
  } | {
    /**
     * @generated from field: google.protobuf.Timestamp timestamp_value = 5;
     */
    value: Timestamp;
    case: "timestampValue";
  } | {
    /**
     * @generated from field: google.type.TimeOfDay time_value = 6;
     */
    value: TimeOfDay;
    case: "timeValue";
  } | {
    /**
     * @generated from field: google.type.Date date_value = 7;
     */
    value: Date;
    case: "dateValue";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Value>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.Value";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "integer_value", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "type" },
    { no: 2, name: "float_value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, oneof: "type" },
    { no: 3, name: "string_value", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "type" },
    { no: 4, name: "boolean_value", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "type" },
    { no: 5, name: "timestamp_value", kind: "message", T: Timestamp, oneof: "type" },
    { no: 6, name: "time_value", kind: "message", T: TimeOfDay, oneof: "type" },
    { no: 7, name: "date_value", kind: "message", T: Date, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Value {
    return new Value().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Value {
    return new Value().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Value {
    return new Value().fromJsonString(jsonString, options);
  }

  static equals(a: Value | PlainMessage<Value> | undefined, b: Value | PlainMessage<Value> | undefined): boolean {
    return proto3.util.equals(Value, a, b);
  }
}

/**
 * The configuration that controls how the data will change.
 *
 * @generated from message google.privacy.dlp.v2beta1.DeidentifyConfig
 */
export class DeidentifyConfig extends Message<DeidentifyConfig> {
  /**
   * @generated from oneof google.privacy.dlp.v2beta1.DeidentifyConfig.transformation
   */
  transformation: {
    /**
     * Treat the dataset as free-form text and apply the same free text
     * transformation everywhere.
     *
     * @generated from field: google.privacy.dlp.v2beta1.InfoTypeTransformations info_type_transformations = 1;
     */
    value: InfoTypeTransformations;
    case: "infoTypeTransformations";
  } | {
    /**
     * Treat the dataset as structured. Transformations can be applied to
     * specific locations within structured datasets, such as transforming
     * a column within a table.
     *
     * @generated from field: google.privacy.dlp.v2beta1.RecordTransformations record_transformations = 2;
     */
    value: RecordTransformations;
    case: "recordTransformations";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<DeidentifyConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.DeidentifyConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "info_type_transformations", kind: "message", T: InfoTypeTransformations, oneof: "transformation" },
    { no: 2, name: "record_transformations", kind: "message", T: RecordTransformations, oneof: "transformation" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeidentifyConfig {
    return new DeidentifyConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeidentifyConfig {
    return new DeidentifyConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeidentifyConfig {
    return new DeidentifyConfig().fromJsonString(jsonString, options);
  }

  static equals(a: DeidentifyConfig | PlainMessage<DeidentifyConfig> | undefined, b: DeidentifyConfig | PlainMessage<DeidentifyConfig> | undefined): boolean {
    return proto3.util.equals(DeidentifyConfig, a, b);
  }
}

/**
 * A rule for transforming a value.
 *
 * @generated from message google.privacy.dlp.v2beta1.PrimitiveTransformation
 */
export class PrimitiveTransformation extends Message<PrimitiveTransformation> {
  /**
   * @generated from oneof google.privacy.dlp.v2beta1.PrimitiveTransformation.transformation
   */
  transformation: {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.ReplaceValueConfig replace_config = 1;
     */
    value: ReplaceValueConfig;
    case: "replaceConfig";
  } | {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.RedactConfig redact_config = 2;
     */
    value: RedactConfig;
    case: "redactConfig";
  } | {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.CharacterMaskConfig character_mask_config = 3;
     */
    value: CharacterMaskConfig;
    case: "characterMaskConfig";
  } | {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.CryptoReplaceFfxFpeConfig crypto_replace_ffx_fpe_config = 4;
     */
    value: CryptoReplaceFfxFpeConfig;
    case: "cryptoReplaceFfxFpeConfig";
  } | {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.FixedSizeBucketingConfig fixed_size_bucketing_config = 5;
     */
    value: FixedSizeBucketingConfig;
    case: "fixedSizeBucketingConfig";
  } | {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.BucketingConfig bucketing_config = 6;
     */
    value: BucketingConfig;
    case: "bucketingConfig";
  } | {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.ReplaceWithInfoTypeConfig replace_with_info_type_config = 7;
     */
    value: ReplaceWithInfoTypeConfig;
    case: "replaceWithInfoTypeConfig";
  } | {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.TimePartConfig time_part_config = 8;
     */
    value: TimePartConfig;
    case: "timePartConfig";
  } | {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.CryptoHashConfig crypto_hash_config = 9;
     */
    value: CryptoHashConfig;
    case: "cryptoHashConfig";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<PrimitiveTransformation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.PrimitiveTransformation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "replace_config", kind: "message", T: ReplaceValueConfig, oneof: "transformation" },
    { no: 2, name: "redact_config", kind: "message", T: RedactConfig, oneof: "transformation" },
    { no: 3, name: "character_mask_config", kind: "message", T: CharacterMaskConfig, oneof: "transformation" },
    { no: 4, name: "crypto_replace_ffx_fpe_config", kind: "message", T: CryptoReplaceFfxFpeConfig, oneof: "transformation" },
    { no: 5, name: "fixed_size_bucketing_config", kind: "message", T: FixedSizeBucketingConfig, oneof: "transformation" },
    { no: 6, name: "bucketing_config", kind: "message", T: BucketingConfig, oneof: "transformation" },
    { no: 7, name: "replace_with_info_type_config", kind: "message", T: ReplaceWithInfoTypeConfig, oneof: "transformation" },
    { no: 8, name: "time_part_config", kind: "message", T: TimePartConfig, oneof: "transformation" },
    { no: 9, name: "crypto_hash_config", kind: "message", T: CryptoHashConfig, oneof: "transformation" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrimitiveTransformation {
    return new PrimitiveTransformation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrimitiveTransformation {
    return new PrimitiveTransformation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrimitiveTransformation {
    return new PrimitiveTransformation().fromJsonString(jsonString, options);
  }

  static equals(a: PrimitiveTransformation | PlainMessage<PrimitiveTransformation> | undefined, b: PrimitiveTransformation | PlainMessage<PrimitiveTransformation> | undefined): boolean {
    return proto3.util.equals(PrimitiveTransformation, a, b);
  }
}

/**
 * For use with `Date`, `Timestamp`, and `TimeOfDay`, extract or preserve a
 * portion of the value.
 *
 * @generated from message google.privacy.dlp.v2beta1.TimePartConfig
 */
export class TimePartConfig extends Message<TimePartConfig> {
  /**
   * @generated from field: google.privacy.dlp.v2beta1.TimePartConfig.TimePart part_to_extract = 1;
   */
  partToExtract = TimePartConfig_TimePart.TIME_PART_UNSPECIFIED;

  constructor(data?: PartialMessage<TimePartConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.TimePartConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "part_to_extract", kind: "enum", T: proto3.getEnumType(TimePartConfig_TimePart) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimePartConfig {
    return new TimePartConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimePartConfig {
    return new TimePartConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimePartConfig {
    return new TimePartConfig().fromJsonString(jsonString, options);
  }

  static equals(a: TimePartConfig | PlainMessage<TimePartConfig> | undefined, b: TimePartConfig | PlainMessage<TimePartConfig> | undefined): boolean {
    return proto3.util.equals(TimePartConfig, a, b);
  }
}

/**
 * @generated from enum google.privacy.dlp.v2beta1.TimePartConfig.TimePart
 */
export enum TimePartConfig_TimePart {
  /**
   * @generated from enum value: TIME_PART_UNSPECIFIED = 0;
   */
  TIME_PART_UNSPECIFIED = 0,

  /**
   * [000-9999]
   *
   * @generated from enum value: YEAR = 1;
   */
  YEAR = 1,

  /**
   * [1-12]
   *
   * @generated from enum value: MONTH = 2;
   */
  MONTH = 2,

  /**
   * [1-31]
   *
   * @generated from enum value: DAY_OF_MONTH = 3;
   */
  DAY_OF_MONTH = 3,

  /**
   * [1-7]
   *
   * @generated from enum value: DAY_OF_WEEK = 4;
   */
  DAY_OF_WEEK = 4,

  /**
   * [1-52]
   *
   * @generated from enum value: WEEK_OF_YEAR = 5;
   */
  WEEK_OF_YEAR = 5,

  /**
   * [0-24]
   *
   * @generated from enum value: HOUR_OF_DAY = 6;
   */
  HOUR_OF_DAY = 6,
}
// Retrieve enum metadata with: proto3.getEnumType(TimePartConfig_TimePart)
proto3.util.setEnumType(TimePartConfig_TimePart, "google.privacy.dlp.v2beta1.TimePartConfig.TimePart", [
  { no: 0, name: "TIME_PART_UNSPECIFIED" },
  { no: 1, name: "YEAR" },
  { no: 2, name: "MONTH" },
  { no: 3, name: "DAY_OF_MONTH" },
  { no: 4, name: "DAY_OF_WEEK" },
  { no: 5, name: "WEEK_OF_YEAR" },
  { no: 6, name: "HOUR_OF_DAY" },
]);

/**
 * Pseudonymization method that generates surrogates via cryptographic hashing.
 * Uses SHA-256.
 * Outputs a 32 byte digest as an uppercase hex string
 * (for example, 41D1567F7F99F1DC2A5FAB886DEE5BEE).
 * Currently, only string and integer values can be hashed.
 *
 * @generated from message google.privacy.dlp.v2beta1.CryptoHashConfig
 */
export class CryptoHashConfig extends Message<CryptoHashConfig> {
  /**
   * The key used by the hash function.
   *
   * @generated from field: google.privacy.dlp.v2beta1.CryptoKey crypto_key = 1;
   */
  cryptoKey?: CryptoKey;

  constructor(data?: PartialMessage<CryptoHashConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.CryptoHashConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "crypto_key", kind: "message", T: CryptoKey },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CryptoHashConfig {
    return new CryptoHashConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CryptoHashConfig {
    return new CryptoHashConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CryptoHashConfig {
    return new CryptoHashConfig().fromJsonString(jsonString, options);
  }

  static equals(a: CryptoHashConfig | PlainMessage<CryptoHashConfig> | undefined, b: CryptoHashConfig | PlainMessage<CryptoHashConfig> | undefined): boolean {
    return proto3.util.equals(CryptoHashConfig, a, b);
  }
}

/**
 * Replace each input value with a given `Value`.
 *
 * @generated from message google.privacy.dlp.v2beta1.ReplaceValueConfig
 */
export class ReplaceValueConfig extends Message<ReplaceValueConfig> {
  /**
   * Value to replace it with.
   *
   * @generated from field: google.privacy.dlp.v2beta1.Value new_value = 1;
   */
  newValue?: Value;

  constructor(data?: PartialMessage<ReplaceValueConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.ReplaceValueConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "new_value", kind: "message", T: Value },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReplaceValueConfig {
    return new ReplaceValueConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReplaceValueConfig {
    return new ReplaceValueConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReplaceValueConfig {
    return new ReplaceValueConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ReplaceValueConfig | PlainMessage<ReplaceValueConfig> | undefined, b: ReplaceValueConfig | PlainMessage<ReplaceValueConfig> | undefined): boolean {
    return proto3.util.equals(ReplaceValueConfig, a, b);
  }
}

/**
 * Replace each matching finding with the name of the info_type.
 *
 * @generated from message google.privacy.dlp.v2beta1.ReplaceWithInfoTypeConfig
 */
export class ReplaceWithInfoTypeConfig extends Message<ReplaceWithInfoTypeConfig> {
  constructor(data?: PartialMessage<ReplaceWithInfoTypeConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.ReplaceWithInfoTypeConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReplaceWithInfoTypeConfig {
    return new ReplaceWithInfoTypeConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReplaceWithInfoTypeConfig {
    return new ReplaceWithInfoTypeConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReplaceWithInfoTypeConfig {
    return new ReplaceWithInfoTypeConfig().fromJsonString(jsonString, options);
  }

  static equals(a: ReplaceWithInfoTypeConfig | PlainMessage<ReplaceWithInfoTypeConfig> | undefined, b: ReplaceWithInfoTypeConfig | PlainMessage<ReplaceWithInfoTypeConfig> | undefined): boolean {
    return proto3.util.equals(ReplaceWithInfoTypeConfig, a, b);
  }
}

/**
 * Redact a given value. For example, if used with an `InfoTypeTransformation`
 * transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the
 * output would be 'My phone number is '.
 *
 * @generated from message google.privacy.dlp.v2beta1.RedactConfig
 */
export class RedactConfig extends Message<RedactConfig> {
  constructor(data?: PartialMessage<RedactConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.RedactConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RedactConfig {
    return new RedactConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RedactConfig {
    return new RedactConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RedactConfig {
    return new RedactConfig().fromJsonString(jsonString, options);
  }

  static equals(a: RedactConfig | PlainMessage<RedactConfig> | undefined, b: RedactConfig | PlainMessage<RedactConfig> | undefined): boolean {
    return proto3.util.equals(RedactConfig, a, b);
  }
}

/**
 * Characters to skip when doing deidentification of a value. These will be left
 * alone and skipped.
 *
 * @generated from message google.privacy.dlp.v2beta1.CharsToIgnore
 */
export class CharsToIgnore extends Message<CharsToIgnore> {
  /**
   * @generated from oneof google.privacy.dlp.v2beta1.CharsToIgnore.characters
   */
  characters: {
    /**
     * @generated from field: string characters_to_skip = 1;
     */
    value: string;
    case: "charactersToSkip";
  } | {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.CharsToIgnore.CharacterGroup common_characters_to_ignore = 2;
     */
    value: CharsToIgnore_CharacterGroup;
    case: "commonCharactersToIgnore";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<CharsToIgnore>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.CharsToIgnore";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "characters_to_skip", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "characters" },
    { no: 2, name: "common_characters_to_ignore", kind: "enum", T: proto3.getEnumType(CharsToIgnore_CharacterGroup), oneof: "characters" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CharsToIgnore {
    return new CharsToIgnore().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CharsToIgnore {
    return new CharsToIgnore().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CharsToIgnore {
    return new CharsToIgnore().fromJsonString(jsonString, options);
  }

  static equals(a: CharsToIgnore | PlainMessage<CharsToIgnore> | undefined, b: CharsToIgnore | PlainMessage<CharsToIgnore> | undefined): boolean {
    return proto3.util.equals(CharsToIgnore, a, b);
  }
}

/**
 * @generated from enum google.privacy.dlp.v2beta1.CharsToIgnore.CharacterGroup
 */
export enum CharsToIgnore_CharacterGroup {
  /**
   * @generated from enum value: CHARACTER_GROUP_UNSPECIFIED = 0;
   */
  CHARACTER_GROUP_UNSPECIFIED = 0,

  /**
   * 0-9
   *
   * @generated from enum value: NUMERIC = 1;
   */
  NUMERIC = 1,

  /**
   * A-Z
   *
   * @generated from enum value: ALPHA_UPPER_CASE = 2;
   */
  ALPHA_UPPER_CASE = 2,

  /**
   * a-z
   *
   * @generated from enum value: ALPHA_LOWER_CASE = 3;
   */
  ALPHA_LOWER_CASE = 3,

  /**
   * US Punctuation, one of !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
   *
   * @generated from enum value: PUNCTUATION = 4;
   */
  PUNCTUATION = 4,

  /**
   * Whitespace character, one of [ \t\n\x0B\f\r]
   *
   * @generated from enum value: WHITESPACE = 5;
   */
  WHITESPACE = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(CharsToIgnore_CharacterGroup)
proto3.util.setEnumType(CharsToIgnore_CharacterGroup, "google.privacy.dlp.v2beta1.CharsToIgnore.CharacterGroup", [
  { no: 0, name: "CHARACTER_GROUP_UNSPECIFIED" },
  { no: 1, name: "NUMERIC" },
  { no: 2, name: "ALPHA_UPPER_CASE" },
  { no: 3, name: "ALPHA_LOWER_CASE" },
  { no: 4, name: "PUNCTUATION" },
  { no: 5, name: "WHITESPACE" },
]);

/**
 * Partially mask a string by replacing a given number of characters with a
 * fixed character. Masking can start from the beginning or end of the string.
 * This can be used on data of any type (numbers, longs, and so on) and when
 * de-identifying structured data we'll attempt to preserve the original data's
 * type. (This allows you to take a long like 123 and modify it to a string like
 * **3.
 *
 * @generated from message google.privacy.dlp.v2beta1.CharacterMaskConfig
 */
export class CharacterMaskConfig extends Message<CharacterMaskConfig> {
  /**
   * Character to mask the sensitive values&mdash;for example, "*" for an
   * alphabetic string such as name, or "0" for a numeric string such as ZIP
   * code or credit card number. String must have length 1. If not supplied, we
   * will default to "*" for strings, 0 for digits.
   *
   * @generated from field: string masking_character = 1;
   */
  maskingCharacter = "";

  /**
   * Number of characters to mask. If not set, all matching chars will be
   * masked. Skipped characters do not count towards this tally.
   *
   * @generated from field: int32 number_to_mask = 2;
   */
  numberToMask = 0;

  /**
   * Mask characters in reverse order. For example, if `masking_character` is
   * '0', number_to_mask is 14, and `reverse_order` is false, then
   * 1234-5678-9012-3456 -> 00000000000000-3456
   * If `masking_character` is '*', `number_to_mask` is 3, and `reverse_order`
   * is true, then 12345 -> 12***
   *
   * @generated from field: bool reverse_order = 3;
   */
  reverseOrder = false;

  /**
   * When masking a string, items in this list will be skipped when replacing.
   * For example, if your string is 555-555-5555 and you ask us to skip `-` and
   * mask 5 chars with * we would produce ***-*55-5555.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.CharsToIgnore characters_to_ignore = 4;
   */
  charactersToIgnore: CharsToIgnore[] = [];

  constructor(data?: PartialMessage<CharacterMaskConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.CharacterMaskConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "masking_character", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "number_to_mask", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "reverse_order", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "characters_to_ignore", kind: "message", T: CharsToIgnore, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CharacterMaskConfig {
    return new CharacterMaskConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CharacterMaskConfig {
    return new CharacterMaskConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CharacterMaskConfig {
    return new CharacterMaskConfig().fromJsonString(jsonString, options);
  }

  static equals(a: CharacterMaskConfig | PlainMessage<CharacterMaskConfig> | undefined, b: CharacterMaskConfig | PlainMessage<CharacterMaskConfig> | undefined): boolean {
    return proto3.util.equals(CharacterMaskConfig, a, b);
  }
}

/**
 * Buckets values based on fixed size ranges. The
 * Bucketing transformation can provide all of this functionality,
 * but requires more configuration. This message is provided as a convenience to
 * the user for simple bucketing strategies.
 * The resulting value will be a hyphenated string of
 * lower_bound-upper_bound.
 * This can be used on data of type: double, long.
 * If the bound Value type differs from the type of data
 * being transformed, we will first attempt converting the type of the data to
 * be transformed to match the type of the bound before comparing.
 *
 * @generated from message google.privacy.dlp.v2beta1.FixedSizeBucketingConfig
 */
export class FixedSizeBucketingConfig extends Message<FixedSizeBucketingConfig> {
  /**
   * Lower bound value of buckets. All values less than `lower_bound` are
   * grouped together into a single bucket; for example if `lower_bound` = 10,
   * then all values less than 10 are replaced with the value -10. [Required].
   *
   * @generated from field: google.privacy.dlp.v2beta1.Value lower_bound = 1;
   */
  lowerBound?: Value;

  /**
   * Upper bound value of buckets. All values greater than upper_bound are
   * grouped together into a single bucket; for example if `upper_bound` = 89,
   * then all values greater than 89 are replaced with the value 89+.
   * [Required].
   *
   * @generated from field: google.privacy.dlp.v2beta1.Value upper_bound = 2;
   */
  upperBound?: Value;

  /**
   * Size of each bucket (except for minimum and maximum buckets). So if
   * `lower_bound` = 10, `upper_bound` = 89, and `bucket_size` = 10, then the
   * following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60,
   * 60-70, 70-80, 80-89, 89+. Precision up to 2 decimals works. [Required].
   *
   * @generated from field: double bucket_size = 3;
   */
  bucketSize = 0;

  constructor(data?: PartialMessage<FixedSizeBucketingConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.FixedSizeBucketingConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "lower_bound", kind: "message", T: Value },
    { no: 2, name: "upper_bound", kind: "message", T: Value },
    { no: 3, name: "bucket_size", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FixedSizeBucketingConfig {
    return new FixedSizeBucketingConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FixedSizeBucketingConfig {
    return new FixedSizeBucketingConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FixedSizeBucketingConfig {
    return new FixedSizeBucketingConfig().fromJsonString(jsonString, options);
  }

  static equals(a: FixedSizeBucketingConfig | PlainMessage<FixedSizeBucketingConfig> | undefined, b: FixedSizeBucketingConfig | PlainMessage<FixedSizeBucketingConfig> | undefined): boolean {
    return proto3.util.equals(FixedSizeBucketingConfig, a, b);
  }
}

/**
 * Generalization function that buckets values based on ranges. The ranges and
 * replacement values are dynamically provided by the user for custom behavior,
 * such as 1-30 -> LOW 31-65 -> MEDIUM 66-100 -> HIGH
 * This can be used on
 * data of type: number, long, string, timestamp.
 * If the bound `Value` type differs from the type of data being transformed, we
 * will first attempt converting the type of the data to be transformed to match
 * the type of the bound before comparing.
 *
 * @generated from message google.privacy.dlp.v2beta1.BucketingConfig
 */
export class BucketingConfig extends Message<BucketingConfig> {
  /**
   * @generated from field: repeated google.privacy.dlp.v2beta1.BucketingConfig.Bucket buckets = 1;
   */
  buckets: BucketingConfig_Bucket[] = [];

  constructor(data?: PartialMessage<BucketingConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.BucketingConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "buckets", kind: "message", T: BucketingConfig_Bucket, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BucketingConfig {
    return new BucketingConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BucketingConfig {
    return new BucketingConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BucketingConfig {
    return new BucketingConfig().fromJsonString(jsonString, options);
  }

  static equals(a: BucketingConfig | PlainMessage<BucketingConfig> | undefined, b: BucketingConfig | PlainMessage<BucketingConfig> | undefined): boolean {
    return proto3.util.equals(BucketingConfig, a, b);
  }
}

/**
 * Buckets represented as ranges, along with replacement values. Ranges must
 * be non-overlapping.
 *
 * @generated from message google.privacy.dlp.v2beta1.BucketingConfig.Bucket
 */
export class BucketingConfig_Bucket extends Message<BucketingConfig_Bucket> {
  /**
   * Lower bound of the range, inclusive. Type should be the same as max if
   * used.
   *
   * @generated from field: google.privacy.dlp.v2beta1.Value min = 1;
   */
  min?: Value;

  /**
   * Upper bound of the range, exclusive; type must match min.
   *
   * @generated from field: google.privacy.dlp.v2beta1.Value max = 2;
   */
  max?: Value;

  /**
   * Replacement value for this bucket. If not provided
   * the default behavior will be to hyphenate the min-max range.
   *
   * @generated from field: google.privacy.dlp.v2beta1.Value replacement_value = 3;
   */
  replacementValue?: Value;

  constructor(data?: PartialMessage<BucketingConfig_Bucket>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.BucketingConfig.Bucket";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min", kind: "message", T: Value },
    { no: 2, name: "max", kind: "message", T: Value },
    { no: 3, name: "replacement_value", kind: "message", T: Value },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BucketingConfig_Bucket {
    return new BucketingConfig_Bucket().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BucketingConfig_Bucket {
    return new BucketingConfig_Bucket().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BucketingConfig_Bucket {
    return new BucketingConfig_Bucket().fromJsonString(jsonString, options);
  }

  static equals(a: BucketingConfig_Bucket | PlainMessage<BucketingConfig_Bucket> | undefined, b: BucketingConfig_Bucket | PlainMessage<BucketingConfig_Bucket> | undefined): boolean {
    return proto3.util.equals(BucketingConfig_Bucket, a, b);
  }
}

/**
 * Replaces an identifier with an surrogate using FPE with the FFX
 * mode of operation.
 * The identifier must be representable by the US-ASCII character set.
 * For a given crypto key and context, the same identifier will be
 * replaced with the same surrogate.
 * Note that a given identifier must be either the empty string or be at
 * least two characters long.
 *
 * @generated from message google.privacy.dlp.v2beta1.CryptoReplaceFfxFpeConfig
 */
export class CryptoReplaceFfxFpeConfig extends Message<CryptoReplaceFfxFpeConfig> {
  /**
   * The key used by the encryption algorithm. [required]
   *
   * @generated from field: google.privacy.dlp.v2beta1.CryptoKey crypto_key = 1;
   */
  cryptoKey?: CryptoKey;

  /**
   * A context may be used for higher security since the same
   * identifier in two different contexts likely will be given a distinct
   * surrogate. The principle is that the likeliness is inversely related
   * to the ratio of the number of distinct identifiers per context over the
   * number of possible surrogates: As long as this ratio is small, the
   * likehood is large.
   *
   * If the context is not set, a default tweak will be used.
   * If the context is set but:
   *
   * 1. there is no record present when transforming a given value or
   * 1. the field is not present when transforming a given value,
   *
   * a default tweak will be used.
   *
   * Note that case (1) is expected when an `InfoTypeTransformation` is
   * applied to both structured and non-structured `ContentItem`s.
   * Currently, the referenced field may be of value type integer or string.
   *
   * The tweak is constructed as a sequence of bytes in big endian byte order
   * such that:
   *
   * - a 64 bit integer is encoded followed by a single byte of value 1
   * - a string is encoded in UTF-8 format followed by a single byte of value 2
   *
   * This is also known as the 'tweak', as in tweakable encryption.
   *
   * @generated from field: google.privacy.dlp.v2beta1.FieldId context = 2;
   */
  context?: FieldId;

  /**
   * @generated from oneof google.privacy.dlp.v2beta1.CryptoReplaceFfxFpeConfig.alphabet
   */
  alphabet: {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet common_alphabet = 4;
     */
    value: CryptoReplaceFfxFpeConfig_FfxCommonNativeAlphabet;
    case: "commonAlphabet";
  } | {
    /**
     * This is supported by mapping these to the alphanumeric characters
     * that the FFX mode natively supports. This happens before/after
     * encryption/decryption.
     * Each character listed must appear only once.
     * Number of characters must be in the range [2, 62].
     * This must be encoded as ASCII.
     * The order of characters does not matter.
     *
     * @generated from field: string custom_alphabet = 5;
     */
    value: string;
    case: "customAlphabet";
  } | {
    /**
     * The native way to select the alphabet. Must be in the range [2, 62].
     *
     * @generated from field: int32 radix = 6;
     */
    value: number;
    case: "radix";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<CryptoReplaceFfxFpeConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.CryptoReplaceFfxFpeConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "crypto_key", kind: "message", T: CryptoKey },
    { no: 2, name: "context", kind: "message", T: FieldId },
    { no: 4, name: "common_alphabet", kind: "enum", T: proto3.getEnumType(CryptoReplaceFfxFpeConfig_FfxCommonNativeAlphabet), oneof: "alphabet" },
    { no: 5, name: "custom_alphabet", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "alphabet" },
    { no: 6, name: "radix", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "alphabet" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CryptoReplaceFfxFpeConfig {
    return new CryptoReplaceFfxFpeConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CryptoReplaceFfxFpeConfig {
    return new CryptoReplaceFfxFpeConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CryptoReplaceFfxFpeConfig {
    return new CryptoReplaceFfxFpeConfig().fromJsonString(jsonString, options);
  }

  static equals(a: CryptoReplaceFfxFpeConfig | PlainMessage<CryptoReplaceFfxFpeConfig> | undefined, b: CryptoReplaceFfxFpeConfig | PlainMessage<CryptoReplaceFfxFpeConfig> | undefined): boolean {
    return proto3.util.equals(CryptoReplaceFfxFpeConfig, a, b);
  }
}

/**
 * These are commonly used subsets of the alphabet that the FFX mode
 * natively supports. In the algorithm, the alphabet is selected using
 * the "radix". Therefore each corresponds to particular radix.
 *
 * @generated from enum google.privacy.dlp.v2beta1.CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet
 */
export enum CryptoReplaceFfxFpeConfig_FfxCommonNativeAlphabet {
  /**
   * @generated from enum value: FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED = 0;
   */
  FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED = 0,

  /**
   * [0-9] (radix of 10)
   *
   * @generated from enum value: NUMERIC = 1;
   */
  NUMERIC = 1,

  /**
   * [0-9A-F] (radix of 16)
   *
   * @generated from enum value: HEXADECIMAL = 2;
   */
  HEXADECIMAL = 2,

  /**
   * [0-9A-Z] (radix of 36)
   *
   * @generated from enum value: UPPER_CASE_ALPHA_NUMERIC = 3;
   */
  UPPER_CASE_ALPHA_NUMERIC = 3,

  /**
   * [0-9A-Za-z] (radix of 62)
   *
   * @generated from enum value: ALPHA_NUMERIC = 4;
   */
  ALPHA_NUMERIC = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(CryptoReplaceFfxFpeConfig_FfxCommonNativeAlphabet)
proto3.util.setEnumType(CryptoReplaceFfxFpeConfig_FfxCommonNativeAlphabet, "google.privacy.dlp.v2beta1.CryptoReplaceFfxFpeConfig.FfxCommonNativeAlphabet", [
  { no: 0, name: "FFX_COMMON_NATIVE_ALPHABET_UNSPECIFIED" },
  { no: 1, name: "NUMERIC" },
  { no: 2, name: "HEXADECIMAL" },
  { no: 3, name: "UPPER_CASE_ALPHA_NUMERIC" },
  { no: 4, name: "ALPHA_NUMERIC" },
]);

/**
 * This is a data encryption key (DEK) (as opposed to
 * a key encryption key (KEK) stored by KMS).
 * When using KMS to wrap/unwrap DEKs, be sure to set an appropriate
 * IAM policy on the KMS CryptoKey (KEK) to ensure an attacker cannot
 * unwrap the data crypto key.
 *
 * @generated from message google.privacy.dlp.v2beta1.CryptoKey
 */
export class CryptoKey extends Message<CryptoKey> {
  /**
   * @generated from oneof google.privacy.dlp.v2beta1.CryptoKey.source
   */
  source: {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.TransientCryptoKey transient = 1;
     */
    value: TransientCryptoKey;
    case: "transient";
  } | {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.UnwrappedCryptoKey unwrapped = 2;
     */
    value: UnwrappedCryptoKey;
    case: "unwrapped";
  } | {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.KmsWrappedCryptoKey kms_wrapped = 3;
     */
    value: KmsWrappedCryptoKey;
    case: "kmsWrapped";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<CryptoKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.CryptoKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transient", kind: "message", T: TransientCryptoKey, oneof: "source" },
    { no: 2, name: "unwrapped", kind: "message", T: UnwrappedCryptoKey, oneof: "source" },
    { no: 3, name: "kms_wrapped", kind: "message", T: KmsWrappedCryptoKey, oneof: "source" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CryptoKey {
    return new CryptoKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CryptoKey {
    return new CryptoKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CryptoKey {
    return new CryptoKey().fromJsonString(jsonString, options);
  }

  static equals(a: CryptoKey | PlainMessage<CryptoKey> | undefined, b: CryptoKey | PlainMessage<CryptoKey> | undefined): boolean {
    return proto3.util.equals(CryptoKey, a, b);
  }
}

/**
 * Use this to have a random data crypto key generated.
 * It will be discarded after the operation/request finishes.
 *
 * @generated from message google.privacy.dlp.v2beta1.TransientCryptoKey
 */
export class TransientCryptoKey extends Message<TransientCryptoKey> {
  /**
   * Name of the key. [required]
   * This is an arbitrary string used to differentiate different keys.
   * A unique key is generated per name: two separate `TransientCryptoKey`
   * protos share the same generated key if their names are the same.
   * When the data crypto key is generated, this name is not used in any way
   * (repeating the api call will result in a different key being generated).
   *
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<TransientCryptoKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.TransientCryptoKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransientCryptoKey {
    return new TransientCryptoKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransientCryptoKey {
    return new TransientCryptoKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransientCryptoKey {
    return new TransientCryptoKey().fromJsonString(jsonString, options);
  }

  static equals(a: TransientCryptoKey | PlainMessage<TransientCryptoKey> | undefined, b: TransientCryptoKey | PlainMessage<TransientCryptoKey> | undefined): boolean {
    return proto3.util.equals(TransientCryptoKey, a, b);
  }
}

/**
 * Using raw keys is prone to security risks due to accidentally
 * leaking the key. Choose another type of key if possible.
 *
 * @generated from message google.privacy.dlp.v2beta1.UnwrappedCryptoKey
 */
export class UnwrappedCryptoKey extends Message<UnwrappedCryptoKey> {
  /**
   * The AES 128/192/256 bit key. [required]
   *
   * @generated from field: bytes key = 1;
   */
  key = new Uint8Array(0);

  constructor(data?: PartialMessage<UnwrappedCryptoKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.UnwrappedCryptoKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnwrappedCryptoKey {
    return new UnwrappedCryptoKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnwrappedCryptoKey {
    return new UnwrappedCryptoKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnwrappedCryptoKey {
    return new UnwrappedCryptoKey().fromJsonString(jsonString, options);
  }

  static equals(a: UnwrappedCryptoKey | PlainMessage<UnwrappedCryptoKey> | undefined, b: UnwrappedCryptoKey | PlainMessage<UnwrappedCryptoKey> | undefined): boolean {
    return proto3.util.equals(UnwrappedCryptoKey, a, b);
  }
}

/**
 * Include to use an existing data crypto key wrapped by KMS.
 * Authorization requires the following IAM permissions when sending a request
 * to perform a crypto transformation using a kms-wrapped crypto key:
 * dlp.kms.encrypt
 *
 * @generated from message google.privacy.dlp.v2beta1.KmsWrappedCryptoKey
 */
export class KmsWrappedCryptoKey extends Message<KmsWrappedCryptoKey> {
  /**
   * The wrapped data crypto key. [required]
   *
   * @generated from field: bytes wrapped_key = 1;
   */
  wrappedKey = new Uint8Array(0);

  /**
   * The resource name of the KMS CryptoKey to use for unwrapping. [required]
   *
   * @generated from field: string crypto_key_name = 2;
   */
  cryptoKeyName = "";

  constructor(data?: PartialMessage<KmsWrappedCryptoKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.KmsWrappedCryptoKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "wrapped_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "crypto_key_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KmsWrappedCryptoKey {
    return new KmsWrappedCryptoKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KmsWrappedCryptoKey {
    return new KmsWrappedCryptoKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KmsWrappedCryptoKey {
    return new KmsWrappedCryptoKey().fromJsonString(jsonString, options);
  }

  static equals(a: KmsWrappedCryptoKey | PlainMessage<KmsWrappedCryptoKey> | undefined, b: KmsWrappedCryptoKey | PlainMessage<KmsWrappedCryptoKey> | undefined): boolean {
    return proto3.util.equals(KmsWrappedCryptoKey, a, b);
  }
}

/**
 * A type of transformation that will scan unstructured text and
 * apply various `PrimitiveTransformation`s to each finding, where the
 * transformation is applied to only values that were identified as a specific
 * info_type.
 *
 * @generated from message google.privacy.dlp.v2beta1.InfoTypeTransformations
 */
export class InfoTypeTransformations extends Message<InfoTypeTransformations> {
  /**
   * Transformation for each info type. Cannot specify more than one
   * for a given info type. [required]
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.InfoTypeTransformations.InfoTypeTransformation transformations = 1;
   */
  transformations: InfoTypeTransformations_InfoTypeTransformation[] = [];

  constructor(data?: PartialMessage<InfoTypeTransformations>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.InfoTypeTransformations";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transformations", kind: "message", T: InfoTypeTransformations_InfoTypeTransformation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InfoTypeTransformations {
    return new InfoTypeTransformations().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InfoTypeTransformations {
    return new InfoTypeTransformations().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InfoTypeTransformations {
    return new InfoTypeTransformations().fromJsonString(jsonString, options);
  }

  static equals(a: InfoTypeTransformations | PlainMessage<InfoTypeTransformations> | undefined, b: InfoTypeTransformations | PlainMessage<InfoTypeTransformations> | undefined): boolean {
    return proto3.util.equals(InfoTypeTransformations, a, b);
  }
}

/**
 * A transformation to apply to text that is identified as a specific
 * info_type.
 *
 * @generated from message google.privacy.dlp.v2beta1.InfoTypeTransformations.InfoTypeTransformation
 */
export class InfoTypeTransformations_InfoTypeTransformation extends Message<InfoTypeTransformations_InfoTypeTransformation> {
  /**
   * Info types to apply the transformation to. Empty list will match all
   * available info types for this transformation.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.InfoType info_types = 1;
   */
  infoTypes: InfoType[] = [];

  /**
   * Primitive transformation to apply to the info type. [required]
   *
   * @generated from field: google.privacy.dlp.v2beta1.PrimitiveTransformation primitive_transformation = 2;
   */
  primitiveTransformation?: PrimitiveTransformation;

  constructor(data?: PartialMessage<InfoTypeTransformations_InfoTypeTransformation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.InfoTypeTransformations.InfoTypeTransformation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "info_types", kind: "message", T: InfoType, repeated: true },
    { no: 2, name: "primitive_transformation", kind: "message", T: PrimitiveTransformation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InfoTypeTransformations_InfoTypeTransformation {
    return new InfoTypeTransformations_InfoTypeTransformation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InfoTypeTransformations_InfoTypeTransformation {
    return new InfoTypeTransformations_InfoTypeTransformation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InfoTypeTransformations_InfoTypeTransformation {
    return new InfoTypeTransformations_InfoTypeTransformation().fromJsonString(jsonString, options);
  }

  static equals(a: InfoTypeTransformations_InfoTypeTransformation | PlainMessage<InfoTypeTransformations_InfoTypeTransformation> | undefined, b: InfoTypeTransformations_InfoTypeTransformation | PlainMessage<InfoTypeTransformations_InfoTypeTransformation> | undefined): boolean {
    return proto3.util.equals(InfoTypeTransformations_InfoTypeTransformation, a, b);
  }
}

/**
 * The transformation to apply to the field.
 *
 * @generated from message google.privacy.dlp.v2beta1.FieldTransformation
 */
export class FieldTransformation extends Message<FieldTransformation> {
  /**
   * Input field(s) to apply the transformation to. [required]
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.FieldId fields = 1;
   */
  fields: FieldId[] = [];

  /**
   * Only apply the transformation if the condition evaluates to true for the
   * given `RecordCondition`. The conditions are allowed to reference fields
   * that are not used in the actual transformation. [optional]
   *
   * Example Use Cases:
   *
   * - Apply a different bucket transformation to an age column if the zip code
   * column for the same record is within a specific range.
   * - Redact a field if the date of birth field is greater than 85.
   *
   * @generated from field: google.privacy.dlp.v2beta1.RecordCondition condition = 3;
   */
  condition?: RecordCondition;

  /**
   * Transformation to apply. [required]
   *
   * @generated from oneof google.privacy.dlp.v2beta1.FieldTransformation.transformation
   */
  transformation: {
    /**
     * Apply the transformation to the entire field.
     *
     * @generated from field: google.privacy.dlp.v2beta1.PrimitiveTransformation primitive_transformation = 4;
     */
    value: PrimitiveTransformation;
    case: "primitiveTransformation";
  } | {
    /**
     * Treat the contents of the field as free text, and selectively
     * transform content that matches an `InfoType`.
     *
     * @generated from field: google.privacy.dlp.v2beta1.InfoTypeTransformations info_type_transformations = 5;
     */
    value: InfoTypeTransformations;
    case: "infoTypeTransformations";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<FieldTransformation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.FieldTransformation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fields", kind: "message", T: FieldId, repeated: true },
    { no: 3, name: "condition", kind: "message", T: RecordCondition },
    { no: 4, name: "primitive_transformation", kind: "message", T: PrimitiveTransformation, oneof: "transformation" },
    { no: 5, name: "info_type_transformations", kind: "message", T: InfoTypeTransformations, oneof: "transformation" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FieldTransformation {
    return new FieldTransformation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FieldTransformation {
    return new FieldTransformation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FieldTransformation {
    return new FieldTransformation().fromJsonString(jsonString, options);
  }

  static equals(a: FieldTransformation | PlainMessage<FieldTransformation> | undefined, b: FieldTransformation | PlainMessage<FieldTransformation> | undefined): boolean {
    return proto3.util.equals(FieldTransformation, a, b);
  }
}

/**
 * A type of transformation that is applied over structured data such as a
 * table.
 *
 * @generated from message google.privacy.dlp.v2beta1.RecordTransformations
 */
export class RecordTransformations extends Message<RecordTransformations> {
  /**
   * Transform the record by applying various field transformations.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.FieldTransformation field_transformations = 1;
   */
  fieldTransformations: FieldTransformation[] = [];

  /**
   * Configuration defining which records get suppressed entirely. Records that
   * match any suppression rule are omitted from the output [optional].
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.RecordSuppression record_suppressions = 2;
   */
  recordSuppressions: RecordSuppression[] = [];

  constructor(data?: PartialMessage<RecordTransformations>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.RecordTransformations";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field_transformations", kind: "message", T: FieldTransformation, repeated: true },
    { no: 2, name: "record_suppressions", kind: "message", T: RecordSuppression, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordTransformations {
    return new RecordTransformations().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordTransformations {
    return new RecordTransformations().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordTransformations {
    return new RecordTransformations().fromJsonString(jsonString, options);
  }

  static equals(a: RecordTransformations | PlainMessage<RecordTransformations> | undefined, b: RecordTransformations | PlainMessage<RecordTransformations> | undefined): boolean {
    return proto3.util.equals(RecordTransformations, a, b);
  }
}

/**
 * Configuration to suppress records whose suppression conditions evaluate to
 * true.
 *
 * @generated from message google.privacy.dlp.v2beta1.RecordSuppression
 */
export class RecordSuppression extends Message<RecordSuppression> {
  /**
   * @generated from field: google.privacy.dlp.v2beta1.RecordCondition condition = 1;
   */
  condition?: RecordCondition;

  constructor(data?: PartialMessage<RecordSuppression>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.RecordSuppression";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "condition", kind: "message", T: RecordCondition },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordSuppression {
    return new RecordSuppression().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordSuppression {
    return new RecordSuppression().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordSuppression {
    return new RecordSuppression().fromJsonString(jsonString, options);
  }

  static equals(a: RecordSuppression | PlainMessage<RecordSuppression> | undefined, b: RecordSuppression | PlainMessage<RecordSuppression> | undefined): boolean {
    return proto3.util.equals(RecordSuppression, a, b);
  }
}

/**
 * A condition for determing whether a transformation should be applied to
 * a field.
 *
 * @generated from message google.privacy.dlp.v2beta1.RecordCondition
 */
export class RecordCondition extends Message<RecordCondition> {
  /**
   * @generated from field: google.privacy.dlp.v2beta1.RecordCondition.Expressions expressions = 3;
   */
  expressions?: RecordCondition_Expressions;

  constructor(data?: PartialMessage<RecordCondition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.RecordCondition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "expressions", kind: "message", T: RecordCondition_Expressions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordCondition {
    return new RecordCondition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordCondition {
    return new RecordCondition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordCondition {
    return new RecordCondition().fromJsonString(jsonString, options);
  }

  static equals(a: RecordCondition | PlainMessage<RecordCondition> | undefined, b: RecordCondition | PlainMessage<RecordCondition> | undefined): boolean {
    return proto3.util.equals(RecordCondition, a, b);
  }
}

/**
 * The field type of `value` and `field` do not need to match to be
 * considered equal, but not all comparisons are possible.
 *
 * A `value` of type:
 *
 * - `string` can be compared against all other types
 * - `boolean` can only be compared against other booleans
 * - `integer` can be compared against doubles or a string if the string value
 * can be parsed as an integer.
 * - `double` can be compared against integers or a string if the string can
 * be parsed as a double.
 * - `Timestamp` can be compared against strings in RFC 3339 date string
 * format.
 * - `TimeOfDay` can be compared against timestamps and strings in the format
 * of 'HH:mm:ss'.
 *
 * If we fail to compare do to type mismatch, a warning will be given and
 * the condition will evaluate to false.
 *
 * @generated from message google.privacy.dlp.v2beta1.RecordCondition.Condition
 */
export class RecordCondition_Condition extends Message<RecordCondition_Condition> {
  /**
   * Field within the record this condition is evaluated against. [required]
   *
   * @generated from field: google.privacy.dlp.v2beta1.FieldId field = 1;
   */
  field?: FieldId;

  /**
   * Operator used to compare the field or info type to the value. [required]
   *
   * @generated from field: google.privacy.dlp.v2beta1.RelationalOperator operator = 3;
   */
  operator = RelationalOperator.RELATIONAL_OPERATOR_UNSPECIFIED;

  /**
   * Value to compare against. [Required, except for `EXISTS` tests.]
   *
   * @generated from field: google.privacy.dlp.v2beta1.Value value = 4;
   */
  value?: Value;

  constructor(data?: PartialMessage<RecordCondition_Condition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.RecordCondition.Condition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field", kind: "message", T: FieldId },
    { no: 3, name: "operator", kind: "enum", T: proto3.getEnumType(RelationalOperator) },
    { no: 4, name: "value", kind: "message", T: Value },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordCondition_Condition {
    return new RecordCondition_Condition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordCondition_Condition {
    return new RecordCondition_Condition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordCondition_Condition {
    return new RecordCondition_Condition().fromJsonString(jsonString, options);
  }

  static equals(a: RecordCondition_Condition | PlainMessage<RecordCondition_Condition> | undefined, b: RecordCondition_Condition | PlainMessage<RecordCondition_Condition> | undefined): boolean {
    return proto3.util.equals(RecordCondition_Condition, a, b);
  }
}

/**
 * @generated from message google.privacy.dlp.v2beta1.RecordCondition.Conditions
 */
export class RecordCondition_Conditions extends Message<RecordCondition_Conditions> {
  /**
   * @generated from field: repeated google.privacy.dlp.v2beta1.RecordCondition.Condition conditions = 1;
   */
  conditions: RecordCondition_Condition[] = [];

  constructor(data?: PartialMessage<RecordCondition_Conditions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.RecordCondition.Conditions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "conditions", kind: "message", T: RecordCondition_Condition, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordCondition_Conditions {
    return new RecordCondition_Conditions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordCondition_Conditions {
    return new RecordCondition_Conditions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordCondition_Conditions {
    return new RecordCondition_Conditions().fromJsonString(jsonString, options);
  }

  static equals(a: RecordCondition_Conditions | PlainMessage<RecordCondition_Conditions> | undefined, b: RecordCondition_Conditions | PlainMessage<RecordCondition_Conditions> | undefined): boolean {
    return proto3.util.equals(RecordCondition_Conditions, a, b);
  }
}

/**
 * A collection of expressions
 *
 * @generated from message google.privacy.dlp.v2beta1.RecordCondition.Expressions
 */
export class RecordCondition_Expressions extends Message<RecordCondition_Expressions> {
  /**
   * The operator to apply to the result of conditions. Default and currently
   * only supported value is `AND`.
   *
   * @generated from field: google.privacy.dlp.v2beta1.RecordCondition.Expressions.LogicalOperator logical_operator = 1;
   */
  logicalOperator = RecordCondition_Expressions_LogicalOperator.LOGICAL_OPERATOR_UNSPECIFIED;

  /**
   * @generated from oneof google.privacy.dlp.v2beta1.RecordCondition.Expressions.type
   */
  type: {
    /**
     * @generated from field: google.privacy.dlp.v2beta1.RecordCondition.Conditions conditions = 3;
     */
    value: RecordCondition_Conditions;
    case: "conditions";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<RecordCondition_Expressions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.RecordCondition.Expressions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "logical_operator", kind: "enum", T: proto3.getEnumType(RecordCondition_Expressions_LogicalOperator) },
    { no: 3, name: "conditions", kind: "message", T: RecordCondition_Conditions, oneof: "type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RecordCondition_Expressions {
    return new RecordCondition_Expressions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RecordCondition_Expressions {
    return new RecordCondition_Expressions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RecordCondition_Expressions {
    return new RecordCondition_Expressions().fromJsonString(jsonString, options);
  }

  static equals(a: RecordCondition_Expressions | PlainMessage<RecordCondition_Expressions> | undefined, b: RecordCondition_Expressions | PlainMessage<RecordCondition_Expressions> | undefined): boolean {
    return proto3.util.equals(RecordCondition_Expressions, a, b);
  }
}

/**
 * @generated from enum google.privacy.dlp.v2beta1.RecordCondition.Expressions.LogicalOperator
 */
export enum RecordCondition_Expressions_LogicalOperator {
  /**
   * @generated from enum value: LOGICAL_OPERATOR_UNSPECIFIED = 0;
   */
  LOGICAL_OPERATOR_UNSPECIFIED = 0,

  /**
   * @generated from enum value: AND = 1;
   */
  AND = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(RecordCondition_Expressions_LogicalOperator)
proto3.util.setEnumType(RecordCondition_Expressions_LogicalOperator, "google.privacy.dlp.v2beta1.RecordCondition.Expressions.LogicalOperator", [
  { no: 0, name: "LOGICAL_OPERATOR_UNSPECIFIED" },
  { no: 1, name: "AND" },
]);

/**
 * High level summary of deidentification.
 *
 * @generated from message google.privacy.dlp.v2beta1.DeidentificationSummary
 */
export class DeidentificationSummary extends Message<DeidentificationSummary> {
  /**
   * Total size in bytes that were transformed in some way.
   *
   * @generated from field: int64 transformed_bytes = 2;
   */
  transformedBytes = protoInt64.zero;

  /**
   * Transformations applied to the dataset.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.TransformationSummary transformation_summaries = 3;
   */
  transformationSummaries: TransformationSummary[] = [];

  constructor(data?: PartialMessage<DeidentificationSummary>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.DeidentificationSummary";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "transformed_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "transformation_summaries", kind: "message", T: TransformationSummary, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeidentificationSummary {
    return new DeidentificationSummary().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeidentificationSummary {
    return new DeidentificationSummary().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeidentificationSummary {
    return new DeidentificationSummary().fromJsonString(jsonString, options);
  }

  static equals(a: DeidentificationSummary | PlainMessage<DeidentificationSummary> | undefined, b: DeidentificationSummary | PlainMessage<DeidentificationSummary> | undefined): boolean {
    return proto3.util.equals(DeidentificationSummary, a, b);
  }
}

/**
 * Summary of a single tranformation.
 *
 * @generated from message google.privacy.dlp.v2beta1.TransformationSummary
 */
export class TransformationSummary extends Message<TransformationSummary> {
  /**
   * Set if the transformation was limited to a specific info_type.
   *
   * @generated from field: google.privacy.dlp.v2beta1.InfoType info_type = 1;
   */
  infoType?: InfoType;

  /**
   * Set if the transformation was limited to a specific FieldId.
   *
   * @generated from field: google.privacy.dlp.v2beta1.FieldId field = 2;
   */
  field?: FieldId;

  /**
   * The specific transformation these stats apply to.
   *
   * @generated from field: google.privacy.dlp.v2beta1.PrimitiveTransformation transformation = 3;
   */
  transformation?: PrimitiveTransformation;

  /**
   * The field transformation that was applied. This list will contain
   * multiple only in the case of errors.
   *
   * @generated from field: repeated google.privacy.dlp.v2beta1.FieldTransformation field_transformations = 5;
   */
  fieldTransformations: FieldTransformation[] = [];

  /**
   * The specific suppression option these stats apply to.
   *
   * @generated from field: google.privacy.dlp.v2beta1.RecordSuppression record_suppress = 6;
   */
  recordSuppress?: RecordSuppression;

  /**
   * @generated from field: repeated google.privacy.dlp.v2beta1.TransformationSummary.SummaryResult results = 4;
   */
  results: TransformationSummary_SummaryResult[] = [];

  constructor(data?: PartialMessage<TransformationSummary>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.TransformationSummary";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "info_type", kind: "message", T: InfoType },
    { no: 2, name: "field", kind: "message", T: FieldId },
    { no: 3, name: "transformation", kind: "message", T: PrimitiveTransformation },
    { no: 5, name: "field_transformations", kind: "message", T: FieldTransformation, repeated: true },
    { no: 6, name: "record_suppress", kind: "message", T: RecordSuppression },
    { no: 4, name: "results", kind: "message", T: TransformationSummary_SummaryResult, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransformationSummary {
    return new TransformationSummary().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransformationSummary {
    return new TransformationSummary().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransformationSummary {
    return new TransformationSummary().fromJsonString(jsonString, options);
  }

  static equals(a: TransformationSummary | PlainMessage<TransformationSummary> | undefined, b: TransformationSummary | PlainMessage<TransformationSummary> | undefined): boolean {
    return proto3.util.equals(TransformationSummary, a, b);
  }
}

/**
 * Possible outcomes of transformations.
 *
 * @generated from enum google.privacy.dlp.v2beta1.TransformationSummary.TransformationResultCode
 */
export enum TransformationSummary_TransformationResultCode {
  /**
   * @generated from enum value: TRANSFORMATION_RESULT_CODE_UNSPECIFIED = 0;
   */
  TRANSFORMATION_RESULT_CODE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: SUCCESS = 1;
   */
  SUCCESS = 1,

  /**
   * @generated from enum value: ERROR = 2;
   */
  ERROR = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(TransformationSummary_TransformationResultCode)
proto3.util.setEnumType(TransformationSummary_TransformationResultCode, "google.privacy.dlp.v2beta1.TransformationSummary.TransformationResultCode", [
  { no: 0, name: "TRANSFORMATION_RESULT_CODE_UNSPECIFIED" },
  { no: 1, name: "SUCCESS" },
  { no: 2, name: "ERROR" },
]);

/**
 * A collection that informs the user the number of times a particular
 * `TransformationResultCode` and error details occurred.
 *
 * @generated from message google.privacy.dlp.v2beta1.TransformationSummary.SummaryResult
 */
export class TransformationSummary_SummaryResult extends Message<TransformationSummary_SummaryResult> {
  /**
   * @generated from field: int64 count = 1;
   */
  count = protoInt64.zero;

  /**
   * @generated from field: google.privacy.dlp.v2beta1.TransformationSummary.TransformationResultCode code = 2;
   */
  code = TransformationSummary_TransformationResultCode.TRANSFORMATION_RESULT_CODE_UNSPECIFIED;

  /**
   * A place for warnings or errors to show up if a transformation didn't
   * work as expected.
   *
   * @generated from field: string details = 3;
   */
  details = "";

  constructor(data?: PartialMessage<TransformationSummary_SummaryResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.privacy.dlp.v2beta1.TransformationSummary.SummaryResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "code", kind: "enum", T: proto3.getEnumType(TransformationSummary_TransformationResultCode) },
    { no: 3, name: "details", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransformationSummary_SummaryResult {
    return new TransformationSummary_SummaryResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransformationSummary_SummaryResult {
    return new TransformationSummary_SummaryResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransformationSummary_SummaryResult {
    return new TransformationSummary_SummaryResult().fromJsonString(jsonString, options);
  }

  static equals(a: TransformationSummary_SummaryResult | PlainMessage<TransformationSummary_SummaryResult> | undefined, b: TransformationSummary_SummaryResult | PlainMessage<TransformationSummary_SummaryResult> | undefined): boolean {
    return proto3.util.equals(TransformationSummary_SummaryResult, a, b);
  }
}

