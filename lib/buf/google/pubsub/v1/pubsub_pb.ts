// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/pubsub/v1/pubsub.proto (package google.pubsub.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, FieldMask, Message, proto3, Timestamp } from "@bufbuild/protobuf";

/**
 * A topic resource.
 *
 * @generated from message google.pubsub.v1.Topic
 */
export class Topic extends Message<Topic> {
  /**
   * The name of the topic. It must have the format
   * `"projects/{project}/topics/{topic}"`. `{topic}` must start with a letter,
   * and contain only letters (`[A-Za-z]`), numbers (`[0-9]`), dashes (`-`),
   * underscores (`_`), periods (`.`), tildes (`~`), plus (`+`) or percent
   * signs (`%`). It must be between 3 and 255 characters in length, and it
   * must not start with `"goog"`.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * User labels.
   *
   * @generated from field: map<string, string> labels = 2;
   */
  labels: { [key: string]: string } = {};

  constructor(data?: PartialMessage<Topic>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.Topic";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Topic {
    return new Topic().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Topic {
    return new Topic().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Topic {
    return new Topic().fromJsonString(jsonString, options);
  }

  static equals(a: Topic | PlainMessage<Topic> | undefined, b: Topic | PlainMessage<Topic> | undefined): boolean {
    return proto3.util.equals(Topic, a, b);
  }
}

/**
 * A message data and its attributes. The message payload must not be empty;
 * it must contain either a non-empty data field, or at least one attribute.
 *
 * @generated from message google.pubsub.v1.PubsubMessage
 */
export class PubsubMessage extends Message<PubsubMessage> {
  /**
   * The message payload.
   *
   * @generated from field: bytes data = 1;
   */
  data = new Uint8Array(0);

  /**
   * Optional attributes for this message.
   *
   * @generated from field: map<string, string> attributes = 2;
   */
  attributes: { [key: string]: string } = {};

  /**
   * ID of this message, assigned by the server when the message is published.
   * Guaranteed to be unique within the topic. This value may be read by a
   * subscriber that receives a `PubsubMessage` via a `Pull` call or a push
   * delivery. It must not be populated by the publisher in a `Publish` call.
   *
   * @generated from field: string message_id = 3;
   */
  messageId = "";

  /**
   * The time at which the message was published, populated by the server when
   * it receives the `Publish` call. It must not be populated by the
   * publisher in a `Publish` call.
   *
   * @generated from field: google.protobuf.Timestamp publish_time = 4;
   */
  publishTime?: Timestamp;

  constructor(data?: PartialMessage<PubsubMessage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.PubsubMessage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "attributes", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 3, name: "message_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "publish_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PubsubMessage {
    return new PubsubMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PubsubMessage {
    return new PubsubMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PubsubMessage {
    return new PubsubMessage().fromJsonString(jsonString, options);
  }

  static equals(a: PubsubMessage | PlainMessage<PubsubMessage> | undefined, b: PubsubMessage | PlainMessage<PubsubMessage> | undefined): boolean {
    return proto3.util.equals(PubsubMessage, a, b);
  }
}

/**
 * Request for the GetTopic method.
 *
 * @generated from message google.pubsub.v1.GetTopicRequest
 */
export class GetTopicRequest extends Message<GetTopicRequest> {
  /**
   * The name of the topic to get.
   * Format is `projects/{project}/topics/{topic}`.
   *
   * @generated from field: string topic = 1;
   */
  topic = "";

  constructor(data?: PartialMessage<GetTopicRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.GetTopicRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "topic", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTopicRequest {
    return new GetTopicRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTopicRequest {
    return new GetTopicRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTopicRequest {
    return new GetTopicRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetTopicRequest | PlainMessage<GetTopicRequest> | undefined, b: GetTopicRequest | PlainMessage<GetTopicRequest> | undefined): boolean {
    return proto3.util.equals(GetTopicRequest, a, b);
  }
}

/**
 * Request for the UpdateTopic method.
 *
 * @generated from message google.pubsub.v1.UpdateTopicRequest
 */
export class UpdateTopicRequest extends Message<UpdateTopicRequest> {
  /**
   * The topic to update.
   *
   * @generated from field: google.pubsub.v1.Topic topic = 1;
   */
  topic?: Topic;

  /**
   * Indicates which fields in the provided topic to update.
   * Must be specified and non-empty.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  constructor(data?: PartialMessage<UpdateTopicRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.UpdateTopicRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "topic", kind: "message", T: Topic },
    { no: 2, name: "update_mask", kind: "message", T: FieldMask },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateTopicRequest {
    return new UpdateTopicRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateTopicRequest {
    return new UpdateTopicRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateTopicRequest {
    return new UpdateTopicRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateTopicRequest | PlainMessage<UpdateTopicRequest> | undefined, b: UpdateTopicRequest | PlainMessage<UpdateTopicRequest> | undefined): boolean {
    return proto3.util.equals(UpdateTopicRequest, a, b);
  }
}

/**
 * Request for the Publish method.
 *
 * @generated from message google.pubsub.v1.PublishRequest
 */
export class PublishRequest extends Message<PublishRequest> {
  /**
   * The messages in the request will be published on this topic.
   * Format is `projects/{project}/topics/{topic}`.
   *
   * @generated from field: string topic = 1;
   */
  topic = "";

  /**
   * The messages to publish.
   *
   * @generated from field: repeated google.pubsub.v1.PubsubMessage messages = 2;
   */
  messages: PubsubMessage[] = [];

  constructor(data?: PartialMessage<PublishRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.PublishRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "topic", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "messages", kind: "message", T: PubsubMessage, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublishRequest {
    return new PublishRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublishRequest {
    return new PublishRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublishRequest {
    return new PublishRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PublishRequest | PlainMessage<PublishRequest> | undefined, b: PublishRequest | PlainMessage<PublishRequest> | undefined): boolean {
    return proto3.util.equals(PublishRequest, a, b);
  }
}

/**
 * Response for the `Publish` method.
 *
 * @generated from message google.pubsub.v1.PublishResponse
 */
export class PublishResponse extends Message<PublishResponse> {
  /**
   * The server-assigned ID of each published message, in the same order as
   * the messages in the request. IDs are guaranteed to be unique within
   * the topic.
   *
   * @generated from field: repeated string message_ids = 1;
   */
  messageIds: string[] = [];

  constructor(data?: PartialMessage<PublishResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.PublishResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PublishResponse {
    return new PublishResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PublishResponse {
    return new PublishResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PublishResponse {
    return new PublishResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PublishResponse | PlainMessage<PublishResponse> | undefined, b: PublishResponse | PlainMessage<PublishResponse> | undefined): boolean {
    return proto3.util.equals(PublishResponse, a, b);
  }
}

/**
 * Request for the `ListTopics` method.
 *
 * @generated from message google.pubsub.v1.ListTopicsRequest
 */
export class ListTopicsRequest extends Message<ListTopicsRequest> {
  /**
   * The name of the cloud project that topics belong to.
   * Format is `projects/{project}`.
   *
   * @generated from field: string project = 1;
   */
  project = "";

  /**
   * Maximum number of topics to return.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * The value returned by the last `ListTopicsResponse`; indicates that this is
   * a continuation of a prior `ListTopics` call, and that the system should
   * return the next page of data.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListTopicsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.ListTopicsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListTopicsRequest {
    return new ListTopicsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListTopicsRequest {
    return new ListTopicsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListTopicsRequest {
    return new ListTopicsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListTopicsRequest | PlainMessage<ListTopicsRequest> | undefined, b: ListTopicsRequest | PlainMessage<ListTopicsRequest> | undefined): boolean {
    return proto3.util.equals(ListTopicsRequest, a, b);
  }
}

/**
 * Response for the `ListTopics` method.
 *
 * @generated from message google.pubsub.v1.ListTopicsResponse
 */
export class ListTopicsResponse extends Message<ListTopicsResponse> {
  /**
   * The resulting topics.
   *
   * @generated from field: repeated google.pubsub.v1.Topic topics = 1;
   */
  topics: Topic[] = [];

  /**
   * If not empty, indicates that there may be more topics that match the
   * request; this value should be passed in a new `ListTopicsRequest`.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListTopicsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.ListTopicsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "topics", kind: "message", T: Topic, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListTopicsResponse {
    return new ListTopicsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListTopicsResponse {
    return new ListTopicsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListTopicsResponse {
    return new ListTopicsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListTopicsResponse | PlainMessage<ListTopicsResponse> | undefined, b: ListTopicsResponse | PlainMessage<ListTopicsResponse> | undefined): boolean {
    return proto3.util.equals(ListTopicsResponse, a, b);
  }
}

/**
 * Request for the `ListTopicSubscriptions` method.
 *
 * @generated from message google.pubsub.v1.ListTopicSubscriptionsRequest
 */
export class ListTopicSubscriptionsRequest extends Message<ListTopicSubscriptionsRequest> {
  /**
   * The name of the topic that subscriptions are attached to.
   * Format is `projects/{project}/topics/{topic}`.
   *
   * @generated from field: string topic = 1;
   */
  topic = "";

  /**
   * Maximum number of subscription names to return.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * The value returned by the last `ListTopicSubscriptionsResponse`; indicates
   * that this is a continuation of a prior `ListTopicSubscriptions` call, and
   * that the system should return the next page of data.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListTopicSubscriptionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.ListTopicSubscriptionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "topic", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListTopicSubscriptionsRequest {
    return new ListTopicSubscriptionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListTopicSubscriptionsRequest {
    return new ListTopicSubscriptionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListTopicSubscriptionsRequest {
    return new ListTopicSubscriptionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListTopicSubscriptionsRequest | PlainMessage<ListTopicSubscriptionsRequest> | undefined, b: ListTopicSubscriptionsRequest | PlainMessage<ListTopicSubscriptionsRequest> | undefined): boolean {
    return proto3.util.equals(ListTopicSubscriptionsRequest, a, b);
  }
}

/**
 * Response for the `ListTopicSubscriptions` method.
 *
 * @generated from message google.pubsub.v1.ListTopicSubscriptionsResponse
 */
export class ListTopicSubscriptionsResponse extends Message<ListTopicSubscriptionsResponse> {
  /**
   * The names of the subscriptions that match the request.
   *
   * @generated from field: repeated string subscriptions = 1;
   */
  subscriptions: string[] = [];

  /**
   * If not empty, indicates that there may be more subscriptions that match
   * the request; this value should be passed in a new
   * `ListTopicSubscriptionsRequest` to get more subscriptions.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListTopicSubscriptionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.ListTopicSubscriptionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subscriptions", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListTopicSubscriptionsResponse {
    return new ListTopicSubscriptionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListTopicSubscriptionsResponse {
    return new ListTopicSubscriptionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListTopicSubscriptionsResponse {
    return new ListTopicSubscriptionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListTopicSubscriptionsResponse | PlainMessage<ListTopicSubscriptionsResponse> | undefined, b: ListTopicSubscriptionsResponse | PlainMessage<ListTopicSubscriptionsResponse> | undefined): boolean {
    return proto3.util.equals(ListTopicSubscriptionsResponse, a, b);
  }
}

/**
 * Request for the `DeleteTopic` method.
 *
 * @generated from message google.pubsub.v1.DeleteTopicRequest
 */
export class DeleteTopicRequest extends Message<DeleteTopicRequest> {
  /**
   * Name of the topic to delete.
   * Format is `projects/{project}/topics/{topic}`.
   *
   * @generated from field: string topic = 1;
   */
  topic = "";

  constructor(data?: PartialMessage<DeleteTopicRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.DeleteTopicRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "topic", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteTopicRequest {
    return new DeleteTopicRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteTopicRequest {
    return new DeleteTopicRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteTopicRequest {
    return new DeleteTopicRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteTopicRequest | PlainMessage<DeleteTopicRequest> | undefined, b: DeleteTopicRequest | PlainMessage<DeleteTopicRequest> | undefined): boolean {
    return proto3.util.equals(DeleteTopicRequest, a, b);
  }
}

/**
 * A subscription resource.
 *
 * @generated from message google.pubsub.v1.Subscription
 */
export class Subscription extends Message<Subscription> {
  /**
   * The name of the subscription. It must have the format
   * `"projects/{project}/subscriptions/{subscription}"`. `{subscription}` must
   * start with a letter, and contain only letters (`[A-Za-z]`), numbers
   * (`[0-9]`), dashes (`-`), underscores (`_`), periods (`.`), tildes (`~`),
   * plus (`+`) or percent signs (`%`). It must be between 3 and 255 characters
   * in length, and it must not start with `"goog"`.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The name of the topic from which this subscription is receiving messages.
   * Format is `projects/{project}/topics/{topic}`.
   * The value of this field will be `_deleted-topic_` if the topic has been
   * deleted.
   *
   * @generated from field: string topic = 2;
   */
  topic = "";

  /**
   * If push delivery is used with this subscription, this field is
   * used to configure it. An empty `pushConfig` signifies that the subscriber
   * will pull and ack messages using API methods.
   *
   * @generated from field: google.pubsub.v1.PushConfig push_config = 4;
   */
  pushConfig?: PushConfig;

  /**
   * This value is the maximum time after a subscriber receives a message
   * before the subscriber should acknowledge the message. After message
   * delivery but before the ack deadline expires and before the message is
   * acknowledged, it is an outstanding message and will not be delivered
   * again during that time (on a best-effort basis).
   *
   * For pull subscriptions, this value is used as the initial value for the ack
   * deadline. To override this value for a given message, call
   * `ModifyAckDeadline` with the corresponding `ack_id` if using
   * pull.
   * The minimum custom deadline you can specify is 10 seconds.
   * The maximum custom deadline you can specify is 600 seconds (10 minutes).
   * If this parameter is 0, a default value of 10 seconds is used.
   *
   * For push delivery, this value is also used to set the request timeout for
   * the call to the push endpoint.
   *
   * If the subscriber never acknowledges the message, the Pub/Sub
   * system will eventually redeliver the message.
   *
   * @generated from field: int32 ack_deadline_seconds = 5;
   */
  ackDeadlineSeconds = 0;

  /**
   * Indicates whether to retain acknowledged messages. If true, then
   * messages are not expunged from the subscription's backlog, even if they are
   * acknowledged, until they fall out of the `message_retention_duration`
   * window.
   *
   * @generated from field: bool retain_acked_messages = 7;
   */
  retainAckedMessages = false;

  /**
   * How long to retain unacknowledged messages in the subscription's backlog,
   * from the moment a message is published.
   * If `retain_acked_messages` is true, then this also configures the retention
   * of acknowledged messages, and thus configures how far back in time a `Seek`
   * can be done. Defaults to 7 days. Cannot be more than 7 days or less than 10
   * minutes.
   *
   * @generated from field: google.protobuf.Duration message_retention_duration = 8;
   */
  messageRetentionDuration?: Duration;

  /**
   * User labels.
   *
   * @generated from field: map<string, string> labels = 9;
   */
  labels: { [key: string]: string } = {};

  constructor(data?: PartialMessage<Subscription>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.Subscription";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "topic", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "push_config", kind: "message", T: PushConfig },
    { no: 5, name: "ack_deadline_seconds", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 7, name: "retain_acked_messages", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "message_retention_duration", kind: "message", T: Duration },
    { no: 9, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Subscription {
    return new Subscription().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Subscription {
    return new Subscription().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Subscription {
    return new Subscription().fromJsonString(jsonString, options);
  }

  static equals(a: Subscription | PlainMessage<Subscription> | undefined, b: Subscription | PlainMessage<Subscription> | undefined): boolean {
    return proto3.util.equals(Subscription, a, b);
  }
}

/**
 * Configuration for a push delivery endpoint.
 *
 * @generated from message google.pubsub.v1.PushConfig
 */
export class PushConfig extends Message<PushConfig> {
  /**
   * A URL locating the endpoint to which messages should be pushed.
   * For example, a Webhook endpoint might use "https://example.com/push".
   *
   * @generated from field: string push_endpoint = 1;
   */
  pushEndpoint = "";

  /**
   * Endpoint configuration attributes.
   *
   * Every endpoint has a set of API supported attributes that can be used to
   * control different aspects of the message delivery.
   *
   * The currently supported attribute is `x-goog-version`, which you can
   * use to change the format of the pushed message. This attribute
   * indicates the version of the data expected by the endpoint. This
   * controls the shape of the pushed message (i.e., its fields and metadata).
   * The endpoint version is based on the version of the Pub/Sub API.
   *
   * If not present during the `CreateSubscription` call, it will default to
   * the version of the API used to make such call. If not present during a
   * `ModifyPushConfig` call, its value will not be changed. `GetSubscription`
   * calls will always return a valid version, even if the subscription was
   * created without this attribute.
   *
   * The possible values for this attribute are:
   *
   * * `v1beta1`: uses the push format defined in the v1beta1 Pub/Sub API.
   * * `v1` or `v1beta2`: uses the push format defined in the v1 Pub/Sub API.
   *
   * @generated from field: map<string, string> attributes = 2;
   */
  attributes: { [key: string]: string } = {};

  constructor(data?: PartialMessage<PushConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.PushConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "push_endpoint", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "attributes", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PushConfig {
    return new PushConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PushConfig {
    return new PushConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PushConfig {
    return new PushConfig().fromJsonString(jsonString, options);
  }

  static equals(a: PushConfig | PlainMessage<PushConfig> | undefined, b: PushConfig | PlainMessage<PushConfig> | undefined): boolean {
    return proto3.util.equals(PushConfig, a, b);
  }
}

/**
 * A message and its corresponding acknowledgment ID.
 *
 * @generated from message google.pubsub.v1.ReceivedMessage
 */
export class ReceivedMessage extends Message<ReceivedMessage> {
  /**
   * This ID can be used to acknowledge the received message.
   *
   * @generated from field: string ack_id = 1;
   */
  ackId = "";

  /**
   * The message.
   *
   * @generated from field: google.pubsub.v1.PubsubMessage message = 2;
   */
  message?: PubsubMessage;

  constructor(data?: PartialMessage<ReceivedMessage>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.ReceivedMessage";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ack_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "message", kind: "message", T: PubsubMessage },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReceivedMessage {
    return new ReceivedMessage().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReceivedMessage {
    return new ReceivedMessage().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReceivedMessage {
    return new ReceivedMessage().fromJsonString(jsonString, options);
  }

  static equals(a: ReceivedMessage | PlainMessage<ReceivedMessage> | undefined, b: ReceivedMessage | PlainMessage<ReceivedMessage> | undefined): boolean {
    return proto3.util.equals(ReceivedMessage, a, b);
  }
}

/**
 * Request for the GetSubscription method.
 *
 * @generated from message google.pubsub.v1.GetSubscriptionRequest
 */
export class GetSubscriptionRequest extends Message<GetSubscriptionRequest> {
  /**
   * The name of the subscription to get.
   * Format is `projects/{project}/subscriptions/{sub}`.
   *
   * @generated from field: string subscription = 1;
   */
  subscription = "";

  constructor(data?: PartialMessage<GetSubscriptionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.GetSubscriptionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subscription", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSubscriptionRequest {
    return new GetSubscriptionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSubscriptionRequest {
    return new GetSubscriptionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSubscriptionRequest {
    return new GetSubscriptionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSubscriptionRequest | PlainMessage<GetSubscriptionRequest> | undefined, b: GetSubscriptionRequest | PlainMessage<GetSubscriptionRequest> | undefined): boolean {
    return proto3.util.equals(GetSubscriptionRequest, a, b);
  }
}

/**
 * Request for the UpdateSubscription method.
 *
 * @generated from message google.pubsub.v1.UpdateSubscriptionRequest
 */
export class UpdateSubscriptionRequest extends Message<UpdateSubscriptionRequest> {
  /**
   * The updated subscription object.
   *
   * @generated from field: google.pubsub.v1.Subscription subscription = 1;
   */
  subscription?: Subscription;

  /**
   * Indicates which fields in the provided subscription to update.
   * Must be specified and non-empty.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  constructor(data?: PartialMessage<UpdateSubscriptionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.UpdateSubscriptionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subscription", kind: "message", T: Subscription },
    { no: 2, name: "update_mask", kind: "message", T: FieldMask },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateSubscriptionRequest {
    return new UpdateSubscriptionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateSubscriptionRequest {
    return new UpdateSubscriptionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateSubscriptionRequest {
    return new UpdateSubscriptionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateSubscriptionRequest | PlainMessage<UpdateSubscriptionRequest> | undefined, b: UpdateSubscriptionRequest | PlainMessage<UpdateSubscriptionRequest> | undefined): boolean {
    return proto3.util.equals(UpdateSubscriptionRequest, a, b);
  }
}

/**
 * Request for the `ListSubscriptions` method.
 *
 * @generated from message google.pubsub.v1.ListSubscriptionsRequest
 */
export class ListSubscriptionsRequest extends Message<ListSubscriptionsRequest> {
  /**
   * The name of the cloud project that subscriptions belong to.
   * Format is `projects/{project}`.
   *
   * @generated from field: string project = 1;
   */
  project = "";

  /**
   * Maximum number of subscriptions to return.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * The value returned by the last `ListSubscriptionsResponse`; indicates that
   * this is a continuation of a prior `ListSubscriptions` call, and that the
   * system should return the next page of data.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListSubscriptionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.ListSubscriptionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSubscriptionsRequest {
    return new ListSubscriptionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSubscriptionsRequest {
    return new ListSubscriptionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSubscriptionsRequest {
    return new ListSubscriptionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListSubscriptionsRequest | PlainMessage<ListSubscriptionsRequest> | undefined, b: ListSubscriptionsRequest | PlainMessage<ListSubscriptionsRequest> | undefined): boolean {
    return proto3.util.equals(ListSubscriptionsRequest, a, b);
  }
}

/**
 * Response for the `ListSubscriptions` method.
 *
 * @generated from message google.pubsub.v1.ListSubscriptionsResponse
 */
export class ListSubscriptionsResponse extends Message<ListSubscriptionsResponse> {
  /**
   * The subscriptions that match the request.
   *
   * @generated from field: repeated google.pubsub.v1.Subscription subscriptions = 1;
   */
  subscriptions: Subscription[] = [];

  /**
   * If not empty, indicates that there may be more subscriptions that match
   * the request; this value should be passed in a new
   * `ListSubscriptionsRequest` to get more subscriptions.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListSubscriptionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.ListSubscriptionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subscriptions", kind: "message", T: Subscription, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSubscriptionsResponse {
    return new ListSubscriptionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSubscriptionsResponse {
    return new ListSubscriptionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSubscriptionsResponse {
    return new ListSubscriptionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListSubscriptionsResponse | PlainMessage<ListSubscriptionsResponse> | undefined, b: ListSubscriptionsResponse | PlainMessage<ListSubscriptionsResponse> | undefined): boolean {
    return proto3.util.equals(ListSubscriptionsResponse, a, b);
  }
}

/**
 * Request for the DeleteSubscription method.
 *
 * @generated from message google.pubsub.v1.DeleteSubscriptionRequest
 */
export class DeleteSubscriptionRequest extends Message<DeleteSubscriptionRequest> {
  /**
   * The subscription to delete.
   * Format is `projects/{project}/subscriptions/{sub}`.
   *
   * @generated from field: string subscription = 1;
   */
  subscription = "";

  constructor(data?: PartialMessage<DeleteSubscriptionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.DeleteSubscriptionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subscription", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteSubscriptionRequest {
    return new DeleteSubscriptionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteSubscriptionRequest {
    return new DeleteSubscriptionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteSubscriptionRequest {
    return new DeleteSubscriptionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteSubscriptionRequest | PlainMessage<DeleteSubscriptionRequest> | undefined, b: DeleteSubscriptionRequest | PlainMessage<DeleteSubscriptionRequest> | undefined): boolean {
    return proto3.util.equals(DeleteSubscriptionRequest, a, b);
  }
}

/**
 * Request for the ModifyPushConfig method.
 *
 * @generated from message google.pubsub.v1.ModifyPushConfigRequest
 */
export class ModifyPushConfigRequest extends Message<ModifyPushConfigRequest> {
  /**
   * The name of the subscription.
   * Format is `projects/{project}/subscriptions/{sub}`.
   *
   * @generated from field: string subscription = 1;
   */
  subscription = "";

  /**
   * The push configuration for future deliveries.
   *
   * An empty `pushConfig` indicates that the Pub/Sub system should
   * stop pushing messages from the given subscription and allow
   * messages to be pulled and acknowledged - effectively pausing
   * the subscription if `Pull` is not called.
   *
   * @generated from field: google.pubsub.v1.PushConfig push_config = 2;
   */
  pushConfig?: PushConfig;

  constructor(data?: PartialMessage<ModifyPushConfigRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.ModifyPushConfigRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subscription", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "push_config", kind: "message", T: PushConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModifyPushConfigRequest {
    return new ModifyPushConfigRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModifyPushConfigRequest {
    return new ModifyPushConfigRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModifyPushConfigRequest {
    return new ModifyPushConfigRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ModifyPushConfigRequest | PlainMessage<ModifyPushConfigRequest> | undefined, b: ModifyPushConfigRequest | PlainMessage<ModifyPushConfigRequest> | undefined): boolean {
    return proto3.util.equals(ModifyPushConfigRequest, a, b);
  }
}

/**
 * Request for the `Pull` method.
 *
 * @generated from message google.pubsub.v1.PullRequest
 */
export class PullRequest extends Message<PullRequest> {
  /**
   * The subscription from which messages should be pulled.
   * Format is `projects/{project}/subscriptions/{sub}`.
   *
   * @generated from field: string subscription = 1;
   */
  subscription = "";

  /**
   * If this field set to true, the system will respond immediately even if
   * it there are no messages available to return in the `Pull` response.
   * Otherwise, the system may wait (for a bounded amount of time) until at
   * least one message is available, rather than returning no messages. The
   * client may cancel the request if it does not wish to wait any longer for
   * the response.
   *
   * @generated from field: bool return_immediately = 2;
   */
  returnImmediately = false;

  /**
   * The maximum number of messages returned for this request. The Pub/Sub
   * system may return fewer than the number specified.
   *
   * @generated from field: int32 max_messages = 3;
   */
  maxMessages = 0;

  constructor(data?: PartialMessage<PullRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.PullRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subscription", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "return_immediately", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "max_messages", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PullRequest {
    return new PullRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PullRequest {
    return new PullRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PullRequest {
    return new PullRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PullRequest | PlainMessage<PullRequest> | undefined, b: PullRequest | PlainMessage<PullRequest> | undefined): boolean {
    return proto3.util.equals(PullRequest, a, b);
  }
}

/**
 * Response for the `Pull` method.
 *
 * @generated from message google.pubsub.v1.PullResponse
 */
export class PullResponse extends Message<PullResponse> {
  /**
   * Received Pub/Sub messages. The Pub/Sub system will return zero messages if
   * there are no more available in the backlog. The Pub/Sub system may return
   * fewer than the `maxMessages` requested even if there are more messages
   * available in the backlog.
   *
   * @generated from field: repeated google.pubsub.v1.ReceivedMessage received_messages = 1;
   */
  receivedMessages: ReceivedMessage[] = [];

  constructor(data?: PartialMessage<PullResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.PullResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "received_messages", kind: "message", T: ReceivedMessage, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PullResponse {
    return new PullResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PullResponse {
    return new PullResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PullResponse {
    return new PullResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PullResponse | PlainMessage<PullResponse> | undefined, b: PullResponse | PlainMessage<PullResponse> | undefined): boolean {
    return proto3.util.equals(PullResponse, a, b);
  }
}

/**
 * Request for the ModifyAckDeadline method.
 *
 * @generated from message google.pubsub.v1.ModifyAckDeadlineRequest
 */
export class ModifyAckDeadlineRequest extends Message<ModifyAckDeadlineRequest> {
  /**
   * The name of the subscription.
   * Format is `projects/{project}/subscriptions/{sub}`.
   *
   * @generated from field: string subscription = 1;
   */
  subscription = "";

  /**
   * List of acknowledgment IDs.
   *
   * @generated from field: repeated string ack_ids = 4;
   */
  ackIds: string[] = [];

  /**
   * The new ack deadline with respect to the time this request was sent to
   * the Pub/Sub system. For example, if the value is 10, the new
   * ack deadline will expire 10 seconds after the `ModifyAckDeadline` call
   * was made. Specifying zero may immediately make the message available for
   * another pull request.
   * The minimum deadline you can specify is 0 seconds.
   * The maximum deadline you can specify is 600 seconds (10 minutes).
   *
   * @generated from field: int32 ack_deadline_seconds = 3;
   */
  ackDeadlineSeconds = 0;

  constructor(data?: PartialMessage<ModifyAckDeadlineRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.ModifyAckDeadlineRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subscription", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "ack_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "ack_deadline_seconds", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ModifyAckDeadlineRequest {
    return new ModifyAckDeadlineRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ModifyAckDeadlineRequest {
    return new ModifyAckDeadlineRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ModifyAckDeadlineRequest {
    return new ModifyAckDeadlineRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ModifyAckDeadlineRequest | PlainMessage<ModifyAckDeadlineRequest> | undefined, b: ModifyAckDeadlineRequest | PlainMessage<ModifyAckDeadlineRequest> | undefined): boolean {
    return proto3.util.equals(ModifyAckDeadlineRequest, a, b);
  }
}

/**
 * Request for the Acknowledge method.
 *
 * @generated from message google.pubsub.v1.AcknowledgeRequest
 */
export class AcknowledgeRequest extends Message<AcknowledgeRequest> {
  /**
   * The subscription whose message is being acknowledged.
   * Format is `projects/{project}/subscriptions/{sub}`.
   *
   * @generated from field: string subscription = 1;
   */
  subscription = "";

  /**
   * The acknowledgment ID for the messages being acknowledged that was returned
   * by the Pub/Sub system in the `Pull` response. Must not be empty.
   *
   * @generated from field: repeated string ack_ids = 2;
   */
  ackIds: string[] = [];

  constructor(data?: PartialMessage<AcknowledgeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.AcknowledgeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subscription", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ack_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AcknowledgeRequest {
    return new AcknowledgeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AcknowledgeRequest {
    return new AcknowledgeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AcknowledgeRequest {
    return new AcknowledgeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AcknowledgeRequest | PlainMessage<AcknowledgeRequest> | undefined, b: AcknowledgeRequest | PlainMessage<AcknowledgeRequest> | undefined): boolean {
    return proto3.util.equals(AcknowledgeRequest, a, b);
  }
}

/**
 * Request for the `StreamingPull` streaming RPC method. This request is used to
 * establish the initial stream as well as to stream acknowledgements and ack
 * deadline modifications from the client to the server.
 *
 * @generated from message google.pubsub.v1.StreamingPullRequest
 */
export class StreamingPullRequest extends Message<StreamingPullRequest> {
  /**
   * The subscription for which to initialize the new stream. This must be
   * provided in the first request on the stream, and must not be set in
   * subsequent requests from client to server.
   * Format is `projects/{project}/subscriptions/{sub}`.
   *
   * @generated from field: string subscription = 1;
   */
  subscription = "";

  /**
   * List of acknowledgement IDs for acknowledging previously received messages
   * (received on this stream or a different stream). If an ack ID has expired,
   * the corresponding message may be redelivered later. Acknowledging a message
   * more than once will not result in an error. If the acknowledgement ID is
   * malformed, the stream will be aborted with status `INVALID_ARGUMENT`.
   *
   * @generated from field: repeated string ack_ids = 2;
   */
  ackIds: string[] = [];

  /**
   * The list of new ack deadlines for the IDs listed in
   * `modify_deadline_ack_ids`. The size of this list must be the same as the
   * size of `modify_deadline_ack_ids`. If it differs the stream will be aborted
   * with `INVALID_ARGUMENT`. Each element in this list is applied to the
   * element in the same position in `modify_deadline_ack_ids`. The new ack
   * deadline is with respect to the time this request was sent to the Pub/Sub
   * system. Must be >= 0. For example, if the value is 10, the new ack deadline
   * will expire 10 seconds after this request is received. If the value is 0,
   * the message is immediately made available for another streaming or
   * non-streaming pull request. If the value is < 0 (an error), the stream will
   * be aborted with status `INVALID_ARGUMENT`.
   *
   * @generated from field: repeated int32 modify_deadline_seconds = 3;
   */
  modifyDeadlineSeconds: number[] = [];

  /**
   * List of acknowledgement IDs whose deadline will be modified based on the
   * corresponding element in `modify_deadline_seconds`. This field can be used
   * to indicate that more time is needed to process a message by the
   * subscriber, or to make the message available for redelivery if the
   * processing was interrupted.
   *
   * @generated from field: repeated string modify_deadline_ack_ids = 4;
   */
  modifyDeadlineAckIds: string[] = [];

  /**
   * The ack deadline to use for the stream. This must be provided in the
   * first request on the stream, but it can also be updated on subsequent
   * requests from client to server. The minimum deadline you can specify is 10
   * seconds. The maximum deadline you can specify is 600 seconds (10 minutes).
   *
   * @generated from field: int32 stream_ack_deadline_seconds = 5;
   */
  streamAckDeadlineSeconds = 0;

  constructor(data?: PartialMessage<StreamingPullRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.StreamingPullRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subscription", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "ack_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "modify_deadline_seconds", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 4, name: "modify_deadline_ack_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "stream_ack_deadline_seconds", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamingPullRequest {
    return new StreamingPullRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamingPullRequest {
    return new StreamingPullRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamingPullRequest {
    return new StreamingPullRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamingPullRequest | PlainMessage<StreamingPullRequest> | undefined, b: StreamingPullRequest | PlainMessage<StreamingPullRequest> | undefined): boolean {
    return proto3.util.equals(StreamingPullRequest, a, b);
  }
}

/**
 * Response for the `StreamingPull` method. This response is used to stream
 * messages from the server to the client.
 *
 * @generated from message google.pubsub.v1.StreamingPullResponse
 */
export class StreamingPullResponse extends Message<StreamingPullResponse> {
  /**
   * Received Pub/Sub messages. This will not be empty.
   *
   * @generated from field: repeated google.pubsub.v1.ReceivedMessage received_messages = 1;
   */
  receivedMessages: ReceivedMessage[] = [];

  constructor(data?: PartialMessage<StreamingPullResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.StreamingPullResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "received_messages", kind: "message", T: ReceivedMessage, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamingPullResponse {
    return new StreamingPullResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamingPullResponse {
    return new StreamingPullResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamingPullResponse {
    return new StreamingPullResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StreamingPullResponse | PlainMessage<StreamingPullResponse> | undefined, b: StreamingPullResponse | PlainMessage<StreamingPullResponse> | undefined): boolean {
    return proto3.util.equals(StreamingPullResponse, a, b);
  }
}

/**
 * Request for the `CreateSnapshot` method.
 *
 * @generated from message google.pubsub.v1.CreateSnapshotRequest
 */
export class CreateSnapshotRequest extends Message<CreateSnapshotRequest> {
  /**
   * Optional user-provided name for this snapshot.
   * If the name is not provided in the request, the server will assign a random
   * name for this snapshot on the same project as the subscription.
   * Note that for REST API requests, you must specify a name.
   * Format is `projects/{project}/snapshots/{snap}`.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The subscription whose backlog the snapshot retains.
   * Specifically, the created snapshot is guaranteed to retain:
   *  (a) The existing backlog on the subscription. More precisely, this is
   *      defined as the messages in the subscription's backlog that are
   *      unacknowledged upon the successful completion of the
   *      `CreateSnapshot` request; as well as:
   *  (b) Any messages published to the subscription's topic following the
   *      successful completion of the CreateSnapshot request.
   * Format is `projects/{project}/subscriptions/{sub}`.
   *
   * @generated from field: string subscription = 2;
   */
  subscription = "";

  constructor(data?: PartialMessage<CreateSnapshotRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.CreateSnapshotRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "subscription", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateSnapshotRequest {
    return new CreateSnapshotRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateSnapshotRequest {
    return new CreateSnapshotRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateSnapshotRequest {
    return new CreateSnapshotRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateSnapshotRequest | PlainMessage<CreateSnapshotRequest> | undefined, b: CreateSnapshotRequest | PlainMessage<CreateSnapshotRequest> | undefined): boolean {
    return proto3.util.equals(CreateSnapshotRequest, a, b);
  }
}

/**
 * Request for the UpdateSnapshot method.
 *
 * @generated from message google.pubsub.v1.UpdateSnapshotRequest
 */
export class UpdateSnapshotRequest extends Message<UpdateSnapshotRequest> {
  /**
   * The updated snpashot object.
   *
   * @generated from field: google.pubsub.v1.Snapshot snapshot = 1;
   */
  snapshot?: Snapshot;

  /**
   * Indicates which fields in the provided snapshot to update.
   * Must be specified and non-empty.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 2;
   */
  updateMask?: FieldMask;

  constructor(data?: PartialMessage<UpdateSnapshotRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.UpdateSnapshotRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "snapshot", kind: "message", T: Snapshot },
    { no: 2, name: "update_mask", kind: "message", T: FieldMask },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateSnapshotRequest {
    return new UpdateSnapshotRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateSnapshotRequest {
    return new UpdateSnapshotRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateSnapshotRequest {
    return new UpdateSnapshotRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateSnapshotRequest | PlainMessage<UpdateSnapshotRequest> | undefined, b: UpdateSnapshotRequest | PlainMessage<UpdateSnapshotRequest> | undefined): boolean {
    return proto3.util.equals(UpdateSnapshotRequest, a, b);
  }
}

/**
 * A snapshot resource.
 *
 * @generated from message google.pubsub.v1.Snapshot
 */
export class Snapshot extends Message<Snapshot> {
  /**
   * The name of the snapshot.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The name of the topic from which this snapshot is retaining messages.
   *
   * @generated from field: string topic = 2;
   */
  topic = "";

  /**
   * The snapshot is guaranteed to exist up until this time.
   * A newly-created snapshot expires no later than 7 days from the time of its
   * creation. Its exact lifetime is determined at creation by the existing
   * backlog in the source subscription. Specifically, the lifetime of the
   * snapshot is `7 days - (age of oldest unacked message in the subscription)`.
   * For example, consider a subscription whose oldest unacked message is 3 days
   * old. If a snapshot is created from this subscription, the snapshot -- which
   * will always capture this 3-day-old backlog as long as the snapshot
   * exists -- will expire in 4 days.
   *
   * @generated from field: google.protobuf.Timestamp expire_time = 3;
   */
  expireTime?: Timestamp;

  /**
   * User labels.
   *
   * @generated from field: map<string, string> labels = 4;
   */
  labels: { [key: string]: string } = {};

  constructor(data?: PartialMessage<Snapshot>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.Snapshot";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "topic", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "expire_time", kind: "message", T: Timestamp },
    { no: 4, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Snapshot {
    return new Snapshot().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Snapshot {
    return new Snapshot().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Snapshot {
    return new Snapshot().fromJsonString(jsonString, options);
  }

  static equals(a: Snapshot | PlainMessage<Snapshot> | undefined, b: Snapshot | PlainMessage<Snapshot> | undefined): boolean {
    return proto3.util.equals(Snapshot, a, b);
  }
}

/**
 * Request for the `ListSnapshots` method.
 *
 * @generated from message google.pubsub.v1.ListSnapshotsRequest
 */
export class ListSnapshotsRequest extends Message<ListSnapshotsRequest> {
  /**
   * The name of the cloud project that snapshots belong to.
   * Format is `projects/{project}`.
   *
   * @generated from field: string project = 1;
   */
  project = "";

  /**
   * Maximum number of snapshots to return.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * The value returned by the last `ListSnapshotsResponse`; indicates that this
   * is a continuation of a prior `ListSnapshots` call, and that the system
   * should return the next page of data.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListSnapshotsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.ListSnapshotsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSnapshotsRequest {
    return new ListSnapshotsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSnapshotsRequest {
    return new ListSnapshotsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSnapshotsRequest {
    return new ListSnapshotsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListSnapshotsRequest | PlainMessage<ListSnapshotsRequest> | undefined, b: ListSnapshotsRequest | PlainMessage<ListSnapshotsRequest> | undefined): boolean {
    return proto3.util.equals(ListSnapshotsRequest, a, b);
  }
}

/**
 * Response for the `ListSnapshots` method.
 *
 * @generated from message google.pubsub.v1.ListSnapshotsResponse
 */
export class ListSnapshotsResponse extends Message<ListSnapshotsResponse> {
  /**
   * The resulting snapshots.
   *
   * @generated from field: repeated google.pubsub.v1.Snapshot snapshots = 1;
   */
  snapshots: Snapshot[] = [];

  /**
   * If not empty, indicates that there may be more snapshot that match the
   * request; this value should be passed in a new `ListSnapshotsRequest`.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListSnapshotsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.ListSnapshotsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "snapshots", kind: "message", T: Snapshot, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSnapshotsResponse {
    return new ListSnapshotsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSnapshotsResponse {
    return new ListSnapshotsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSnapshotsResponse {
    return new ListSnapshotsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListSnapshotsResponse | PlainMessage<ListSnapshotsResponse> | undefined, b: ListSnapshotsResponse | PlainMessage<ListSnapshotsResponse> | undefined): boolean {
    return proto3.util.equals(ListSnapshotsResponse, a, b);
  }
}

/**
 * Request for the `DeleteSnapshot` method.
 *
 * @generated from message google.pubsub.v1.DeleteSnapshotRequest
 */
export class DeleteSnapshotRequest extends Message<DeleteSnapshotRequest> {
  /**
   * The name of the snapshot to delete.
   * Format is `projects/{project}/snapshots/{snap}`.
   *
   * @generated from field: string snapshot = 1;
   */
  snapshot = "";

  constructor(data?: PartialMessage<DeleteSnapshotRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.DeleteSnapshotRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "snapshot", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteSnapshotRequest {
    return new DeleteSnapshotRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteSnapshotRequest {
    return new DeleteSnapshotRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteSnapshotRequest {
    return new DeleteSnapshotRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteSnapshotRequest | PlainMessage<DeleteSnapshotRequest> | undefined, b: DeleteSnapshotRequest | PlainMessage<DeleteSnapshotRequest> | undefined): boolean {
    return proto3.util.equals(DeleteSnapshotRequest, a, b);
  }
}

/**
 * Request for the `Seek` method.
 *
 * @generated from message google.pubsub.v1.SeekRequest
 */
export class SeekRequest extends Message<SeekRequest> {
  /**
   * The subscription to affect.
   *
   * @generated from field: string subscription = 1;
   */
  subscription = "";

  /**
   * @generated from oneof google.pubsub.v1.SeekRequest.target
   */
  target: {
    /**
     * The time to seek to.
     * Messages retained in the subscription that were published before this
     * time are marked as acknowledged, and messages retained in the
     * subscription that were published after this time are marked as
     * unacknowledged. Note that this operation affects only those messages
     * retained in the subscription (configured by the combination of
     * `message_retention_duration` and `retain_acked_messages`). For example,
     * if `time` corresponds to a point before the message retention
     * window (or to a point before the system's notion of the subscription
     * creation time), only retained messages will be marked as unacknowledged,
     * and already-expunged messages will not be restored.
     *
     * @generated from field: google.protobuf.Timestamp time = 2;
     */
    value: Timestamp;
    case: "time";
  } | {
    /**
     * The snapshot to seek to. The snapshot's topic must be the same as that of
     * the provided subscription.
     * Format is `projects/{project}/snapshots/{snap}`.
     *
     * @generated from field: string snapshot = 3;
     */
    value: string;
    case: "snapshot";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SeekRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.SeekRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subscription", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "time", kind: "message", T: Timestamp, oneof: "target" },
    { no: 3, name: "snapshot", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "target" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SeekRequest {
    return new SeekRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SeekRequest {
    return new SeekRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SeekRequest {
    return new SeekRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SeekRequest | PlainMessage<SeekRequest> | undefined, b: SeekRequest | PlainMessage<SeekRequest> | undefined): boolean {
    return proto3.util.equals(SeekRequest, a, b);
  }
}

/**
 * @generated from message google.pubsub.v1.SeekResponse
 */
export class SeekResponse extends Message<SeekResponse> {
  constructor(data?: PartialMessage<SeekResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.pubsub.v1.SeekResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SeekResponse {
    return new SeekResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SeekResponse {
    return new SeekResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SeekResponse {
    return new SeekResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SeekResponse | PlainMessage<SeekResponse> | undefined, b: SeekResponse | PlainMessage<SeekResponse> | undefined): boolean {
    return proto3.util.equals(SeekResponse, a, b);
  }
}

