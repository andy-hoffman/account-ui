// Copyright 2016 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/tracing/trace.proto (package google.tracing.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { Status } from "../rpc/status_pb.js";

/**
 * A TraceId uniquely identifies a Trace. It is conceptually a 128-bit value,
 * represented as a string, containing the hex-encoded value.
 *
 * @generated from message google.tracing.v1.TraceId
 */
export class TraceId extends Message<TraceId> {
  /**
   * Trace ID specified as a hex-encoded string. *Must* be 32 bytes long.
   *
   * @generated from field: string hex_encoded = 1;
   */
  hexEncoded = "";

  constructor(data?: PartialMessage<TraceId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.tracing.v1.TraceId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hex_encoded", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TraceId {
    return new TraceId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TraceId {
    return new TraceId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TraceId {
    return new TraceId().fromJsonString(jsonString, options);
  }

  static equals(a: TraceId | PlainMessage<TraceId> | undefined, b: TraceId | PlainMessage<TraceId> | undefined): boolean {
    return proto3.util.equals(TraceId, a, b);
  }
}

/**
 * @generated from message google.tracing.v1.Module
 */
export class Module extends Message<Module> {
  /**
   * Binary module.
   * E.g. main binary, kernel modules, and dynamic libraries
   * such as libc.so, sharedlib.so
   *
   * @generated from field: string module = 1;
   */
  module = "";

  /**
   * Build_id is a unique identifier for the module,
   * probably a hash of its contents
   *
   * @generated from field: string build_id = 2;
   */
  buildId = "";

  constructor(data?: PartialMessage<Module>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.tracing.v1.Module";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "module", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "build_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Module {
    return new Module().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Module {
    return new Module().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Module {
    return new Module().fromJsonString(jsonString, options);
  }

  static equals(a: Module | PlainMessage<Module> | undefined, b: Module | PlainMessage<Module> | undefined): boolean {
    return proto3.util.equals(Module, a, b);
  }
}

/**
 * @generated from message google.tracing.v1.StackTrace
 */
export class StackTrace extends Message<StackTrace> {
  /**
   * Stack frames of this stack trace.
   *
   * @generated from field: repeated google.tracing.v1.StackTrace.StackFrame stack_frame = 1;
   */
  stackFrame: StackTrace_StackFrame[] = [];

  /**
   * User can choose to use his own hash function to hash large labels to save
   * network bandwidth and storage.
   * Typical usage is to pass both initially to inform the storage of the
   * mapping. And in subsequent calls, pass in stack_trace_hash_id only.
   * User shall verify the hash value is successfully stored.
   *
   * @generated from field: uint64 stack_trace_hash_id = 2;
   */
  stackTraceHashId = protoInt64.zero;

  constructor(data?: PartialMessage<StackTrace>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.tracing.v1.StackTrace";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stack_frame", kind: "message", T: StackTrace_StackFrame, repeated: true },
    { no: 2, name: "stack_trace_hash_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StackTrace {
    return new StackTrace().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StackTrace {
    return new StackTrace().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StackTrace {
    return new StackTrace().fromJsonString(jsonString, options);
  }

  static equals(a: StackTrace | PlainMessage<StackTrace> | undefined, b: StackTrace | PlainMessage<StackTrace> | undefined): boolean {
    return proto3.util.equals(StackTrace, a, b);
  }
}

/**
 * Presents a single stack frame in a stack trace.
 *
 * @generated from message google.tracing.v1.StackTrace.StackFrame
 */
export class StackTrace_StackFrame extends Message<StackTrace_StackFrame> {
  /**
   * Fully qualified names which uniquely identify function/method/etc.
   *
   * @generated from field: string function_name = 1;
   */
  functionName = "";

  /**
   * Used when function name is ‘mangled’. Not guaranteed to be fully
   * qualified but usually it is.
   *
   * @generated from field: string orig_function_name = 2;
   */
  origFunctionName = "";

  /**
   * File name of the frame.
   *
   * @generated from field: string file_name = 3;
   */
  fileName = "";

  /**
   * Line number of the frame.
   *
   * @generated from field: int64 line_number = 4;
   */
  lineNumber = protoInt64.zero;

  /**
   * Column number is important in JavaScript(anonymous functions),
   * Might not be available in some languages.
   *
   * @generated from field: int64 column_number = 5;
   */
  columnNumber = protoInt64.zero;

  /**
   * Binary module the code is loaded from.
   *
   * @generated from field: google.tracing.v1.Module load_module = 6;
   */
  loadModule?: Module;

  /**
   * source_version is deployment specific. It might be
   * better to be stored in deployment metadata.
   * However, in distributed tracing, it’s hard to keep track of
   * source/binary versions at one place for all spans.
   *
   * @generated from field: string source_version = 7;
   */
  sourceVersion = "";

  constructor(data?: PartialMessage<StackTrace_StackFrame>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.tracing.v1.StackTrace.StackFrame";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "function_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "orig_function_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "file_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "line_number", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "column_number", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "load_module", kind: "message", T: Module },
    { no: 7, name: "source_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StackTrace_StackFrame {
    return new StackTrace_StackFrame().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StackTrace_StackFrame {
    return new StackTrace_StackFrame().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StackTrace_StackFrame {
    return new StackTrace_StackFrame().fromJsonString(jsonString, options);
  }

  static equals(a: StackTrace_StackFrame | PlainMessage<StackTrace_StackFrame> | undefined, b: StackTrace_StackFrame | PlainMessage<StackTrace_StackFrame> | undefined): boolean {
    return proto3.util.equals(StackTrace_StackFrame, a, b);
  }
}

/**
 * Allowed label values.
 *
 * @generated from message google.tracing.v1.LabelValue
 */
export class LabelValue extends Message<LabelValue> {
  /**
   * The value of the label.
   *
   * @generated from oneof google.tracing.v1.LabelValue.value
   */
  value: {
    /**
     * A string value.
     *
     * @generated from field: string string_value = 1;
     */
    value: string;
    case: "stringValue";
  } | {
    /**
     * An integer value.
     *
     * @generated from field: int64 int_value = 2;
     */
    value: bigint;
    case: "intValue";
  } | {
    /**
     * A boolean value.
     *
     * @generated from field: bool bool_value = 3;
     */
    value: boolean;
    case: "boolValue";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<LabelValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.tracing.v1.LabelValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "string_value", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "value" },
    { no: 2, name: "int_value", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "value" },
    { no: 3, name: "bool_value", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LabelValue {
    return new LabelValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LabelValue {
    return new LabelValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LabelValue {
    return new LabelValue().fromJsonString(jsonString, options);
  }

  static equals(a: LabelValue | PlainMessage<LabelValue> | undefined, b: LabelValue | PlainMessage<LabelValue> | undefined): boolean {
    return proto3.util.equals(LabelValue, a, b);
  }
}

/**
 * A span represents a single operation within a trace. Spans can be nested
 * and form a trace tree. Often, a trace contains a root span that describes the
 * end-to-end latency and, optionally, one or more subspans for
 * its sub-operations. Spans do not need to be contiguous. There may be gaps
 * between spans in a trace.
 *
 * @generated from message google.tracing.v1.Span
 */
export class Span extends Message<Span> {
  /**
   * Identifier for the span. Must be a 64-bit integer other than 0 and
   * unique within a trace.
   *
   * @generated from field: fixed64 id = 1;
   */
  id = protoInt64.zero;

  /**
   * Name of the span. The span name is sanitized and displayed in the
   * Stackdriver Trace tool in the {% dynamic print site_values.console_name %}.
   * The name may be a method name or some other per-call site name.
   * For the same executable and the same call point, a best practice is
   * to use a consistent name, which makes it easier to correlate
   * cross-trace spans.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * ID of parent span. 0 or missing if this is a root span.
   *
   * @generated from field: fixed64 parent_id = 3;
   */
  parentId = protoInt64.zero;

  /**
   * Local machine clock in nanoseconds from the UNIX epoch,
   * at which span execution started.
   * On the server side these are the times when the server application
   * handler starts running.
   *
   * @generated from field: google.protobuf.Timestamp local_start_time = 4;
   */
  localStartTime?: Timestamp;

  /**
   * Local machine clock in nanoseconds from the UNIX epoch,
   * at which span execution ended.
   * On the server side these are the times when the server application
   * handler finishes running.
   *
   * @generated from field: google.protobuf.Timestamp local_end_time = 5;
   */
  localEndTime?: Timestamp;

  /**
   * Properties of a span. Labels at the span level.
   * E.g.
   * "/instance_id": "my-instance"
   * "/zone": "us-central1-a"
   * "/grpc/peer_address": "ip:port" (dns, etc.)
   * "/grpc/deadline": "Duration"
   * "/http/user_agent"
   * "/http/request_bytes": 300
   * "/http/response_bytes": 1200
   * "/http/url": google.com/apis
   * "/pid"
   * "abc.com/mylabel": "my label value"
   *
   * @generated from field: map<string, google.tracing.v1.LabelValue> labels = 6;
   */
  labels: { [key: string]: LabelValue } = {};

  /**
   * Stack trace captured at the start of the span. This is optional.
   *
   * @generated from field: google.tracing.v1.StackTrace stack_trace = 7;
   */
  stackTrace?: StackTrace;

  /**
   * A collection of time-stamped events.
   *
   * @generated from field: repeated google.tracing.v1.Span.TimeEvent time_events = 8;
   */
  timeEvents: Span_TimeEvent[] = [];

  /**
   * A collection of links.
   *
   * @generated from field: repeated google.tracing.v1.Span.Link links = 9;
   */
  links: Span_Link[] = [];

  /**
   * The final status of the Span. This is optional.
   *
   * @generated from field: google.rpc.Status status = 10;
   */
  status?: Status;

  /**
   * True if this Span has a remote parent (is an RPC server Span).
   *
   * @generated from field: bool has_remote_parent = 11;
   */
  hasRemoteParent = false;

  constructor(data?: PartialMessage<Span>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.tracing.v1.Span";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "parent_id", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 4, name: "local_start_time", kind: "message", T: Timestamp },
    { no: 5, name: "local_end_time", kind: "message", T: Timestamp },
    { no: 6, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: LabelValue} },
    { no: 7, name: "stack_trace", kind: "message", T: StackTrace },
    { no: 8, name: "time_events", kind: "message", T: Span_TimeEvent, repeated: true },
    { no: 9, name: "links", kind: "message", T: Span_Link, repeated: true },
    { no: 10, name: "status", kind: "message", T: Status },
    { no: 11, name: "has_remote_parent", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Span {
    return new Span().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Span {
    return new Span().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Span {
    return new Span().fromJsonString(jsonString, options);
  }

  static equals(a: Span | PlainMessage<Span> | undefined, b: Span | PlainMessage<Span> | undefined): boolean {
    return proto3.util.equals(Span, a, b);
  }
}

/**
 * A time-stamped annotation in the Span.
 *
 * @generated from message google.tracing.v1.Span.TimeEvent
 */
export class Span_TimeEvent extends Message<Span_TimeEvent> {
  /**
   * The local machine absolute timestamp when this event happened.
   *
   * @generated from field: google.protobuf.Timestamp local_time = 1;
   */
  localTime?: Timestamp;

  /**
   * @generated from oneof google.tracing.v1.Span.TimeEvent.value
   */
  value: {
    /**
     * Optional field for user supplied <string, LabelValue> map
     *
     * @generated from field: google.tracing.v1.Span.TimeEvent.Annotation annotation = 2;
     */
    value: Span_TimeEvent_Annotation;
    case: "annotation";
  } | {
    /**
     * Optional field that can be used only for network events.
     *
     * @generated from field: google.tracing.v1.Span.TimeEvent.NetworkEvent network_event = 3;
     */
    value: Span_TimeEvent_NetworkEvent;
    case: "networkEvent";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Span_TimeEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.tracing.v1.Span.TimeEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "local_time", kind: "message", T: Timestamp },
    { no: 2, name: "annotation", kind: "message", T: Span_TimeEvent_Annotation, oneof: "value" },
    { no: 3, name: "network_event", kind: "message", T: Span_TimeEvent_NetworkEvent, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Span_TimeEvent {
    return new Span_TimeEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Span_TimeEvent {
    return new Span_TimeEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Span_TimeEvent {
    return new Span_TimeEvent().fromJsonString(jsonString, options);
  }

  static equals(a: Span_TimeEvent | PlainMessage<Span_TimeEvent> | undefined, b: Span_TimeEvent | PlainMessage<Span_TimeEvent> | undefined): boolean {
    return proto3.util.equals(Span_TimeEvent, a, b);
  }
}

/**
 * Text annotation with a set of labels.
 *
 * @generated from message google.tracing.v1.Span.TimeEvent.Annotation
 */
export class Span_TimeEvent_Annotation extends Message<Span_TimeEvent_Annotation> {
  /**
   * A user-supplied message describing the event.
   *
   * @generated from field: string description = 1;
   */
  description = "";

  /**
   * A set of labels on the annotation.
   *
   * @generated from field: map<string, google.tracing.v1.LabelValue> labels = 2;
   */
  labels: { [key: string]: LabelValue } = {};

  constructor(data?: PartialMessage<Span_TimeEvent_Annotation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.tracing.v1.Span.TimeEvent.Annotation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: LabelValue} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Span_TimeEvent_Annotation {
    return new Span_TimeEvent_Annotation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Span_TimeEvent_Annotation {
    return new Span_TimeEvent_Annotation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Span_TimeEvent_Annotation {
    return new Span_TimeEvent_Annotation().fromJsonString(jsonString, options);
  }

  static equals(a: Span_TimeEvent_Annotation | PlainMessage<Span_TimeEvent_Annotation> | undefined, b: Span_TimeEvent_Annotation | PlainMessage<Span_TimeEvent_Annotation> | undefined): boolean {
    return proto3.util.equals(Span_TimeEvent_Annotation, a, b);
  }
}

/**
 * An event describing an RPC message sent/received on the network.
 *
 * @generated from message google.tracing.v1.Span.TimeEvent.NetworkEvent
 */
export class Span_TimeEvent_NetworkEvent extends Message<Span_TimeEvent_NetworkEvent> {
  /**
   * If available, this is the kernel time:
   * For sent messages, this is the time at which the first bit was sent.
   * For received messages, this is the time at which the last bit was
   * received.
   *
   * @generated from field: google.protobuf.Timestamp kernel_time = 1;
   */
  kernelTime?: Timestamp;

  /**
   * @generated from field: google.tracing.v1.Span.TimeEvent.NetworkEvent.Type type = 2;
   */
  type = Span_TimeEvent_NetworkEvent_Type.UNSPECIFIED;

  /**
   * Every message has an identifier, that must be different from all the
   * network messages in this span.
   * This is very important when the request/response are streamed.
   *
   * @generated from field: uint64 message_id = 3;
   */
  messageId = protoInt64.zero;

  /**
   * Number of bytes send/receive.
   *
   * @generated from field: uint64 message_size = 4;
   */
  messageSize = protoInt64.zero;

  constructor(data?: PartialMessage<Span_TimeEvent_NetworkEvent>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.tracing.v1.Span.TimeEvent.NetworkEvent";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "kernel_time", kind: "message", T: Timestamp },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(Span_TimeEvent_NetworkEvent_Type) },
    { no: 3, name: "message_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "message_size", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Span_TimeEvent_NetworkEvent {
    return new Span_TimeEvent_NetworkEvent().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Span_TimeEvent_NetworkEvent {
    return new Span_TimeEvent_NetworkEvent().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Span_TimeEvent_NetworkEvent {
    return new Span_TimeEvent_NetworkEvent().fromJsonString(jsonString, options);
  }

  static equals(a: Span_TimeEvent_NetworkEvent | PlainMessage<Span_TimeEvent_NetworkEvent> | undefined, b: Span_TimeEvent_NetworkEvent | PlainMessage<Span_TimeEvent_NetworkEvent> | undefined): boolean {
    return proto3.util.equals(Span_TimeEvent_NetworkEvent, a, b);
  }
}

/**
 * The type of the network event. SENT or RECV event.
 *
 * @generated from enum google.tracing.v1.Span.TimeEvent.NetworkEvent.Type
 */
export enum Span_TimeEvent_NetworkEvent_Type {
  /**
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SENT = 1;
   */
  SENT = 1,

  /**
   * @generated from enum value: RECV = 2;
   */
  RECV = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(Span_TimeEvent_NetworkEvent_Type)
proto3.util.setEnumType(Span_TimeEvent_NetworkEvent_Type, "google.tracing.v1.Span.TimeEvent.NetworkEvent.Type", [
  { no: 0, name: "UNSPECIFIED" },
  { no: 1, name: "SENT" },
  { no: 2, name: "RECV" },
]);

/**
 * Link one span with another which may be in a different Trace. Used (for
 * example) in batching operations, where a single batch handler processes
 * multiple requests from different traces.
 *
 * @generated from message google.tracing.v1.Span.Link
 */
export class Span_Link extends Message<Span_Link> {
  /**
   * The trace and span identifier of the linked span.
   *
   * @generated from field: google.tracing.v1.TraceId trace_id = 1;
   */
  traceId?: TraceId;

  /**
   * @generated from field: fixed64 span_id = 2;
   */
  spanId = protoInt64.zero;

  /**
   * @generated from field: google.tracing.v1.Span.Link.Type type = 3;
   */
  type = Span_Link_Type.UNSPECIFIED;

  constructor(data?: PartialMessage<Span_Link>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.tracing.v1.Span.Link";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trace_id", kind: "message", T: TraceId },
    { no: 2, name: "span_id", kind: "scalar", T: 6 /* ScalarType.FIXED64 */ },
    { no: 3, name: "type", kind: "enum", T: proto3.getEnumType(Span_Link_Type) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Span_Link {
    return new Span_Link().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Span_Link {
    return new Span_Link().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Span_Link {
    return new Span_Link().fromJsonString(jsonString, options);
  }

  static equals(a: Span_Link | PlainMessage<Span_Link> | undefined, b: Span_Link | PlainMessage<Span_Link> | undefined): boolean {
    return proto3.util.equals(Span_Link, a, b);
  }
}

/**
 * The type of the link.
 *
 * @generated from enum google.tracing.v1.Span.Link.Type
 */
export enum Span_Link_Type {
  /**
   * @generated from enum value: UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: CHILD = 1;
   */
  CHILD = 1,

  /**
   * @generated from enum value: PARENT = 2;
   */
  PARENT = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(Span_Link_Type)
proto3.util.setEnumType(Span_Link_Type, "google.tracing.v1.Span.Link.Type", [
  { no: 0, name: "UNSPECIFIED" },
  { no: 1, name: "CHILD" },
  { no: 2, name: "PARENT" },
]);

/**
 * A trace describes how long it takes for an application to perform some
 * operations. It consists of a tree of spans, each of which contains details
 * about an operation with time information and operation details.
 *
 * @generated from message google.tracing.v1.Trace
 */
export class Trace extends Message<Trace> {
  /**
   * Globally unique identifier for the trace. Common to all the spans.
   *
   * @generated from field: google.tracing.v1.TraceId trace_id = 1;
   */
  traceId?: TraceId;

  /**
   * Collection of spans in the trace. The root span has parent_id == 0.
   *
   * @generated from field: repeated google.tracing.v1.Span spans = 2;
   */
  spans: Span[] = [];

  constructor(data?: PartialMessage<Trace>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.tracing.v1.Trace";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "trace_id", kind: "message", T: TraceId },
    { no: 2, name: "spans", kind: "message", T: Span, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Trace {
    return new Trace().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Trace {
    return new Trace().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Trace {
    return new Trace().fromJsonString(jsonString, options);
  }

  static equals(a: Trace | PlainMessage<Trace> | undefined, b: Trace | PlainMessage<Trace> | undefined): boolean {
    return proto3.util.equals(Trace, a, b);
  }
}

