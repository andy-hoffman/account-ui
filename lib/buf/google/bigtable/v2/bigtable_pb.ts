// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/bigtable/v2/bigtable.proto (package google.bigtable.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { BytesValue, Message, proto3, protoInt64, StringValue } from "@bufbuild/protobuf";
import { Mutation, ReadModifyWriteRule, Row, RowFilter, RowSet } from "./data_pb.js";
import { Status } from "../../rpc/status_pb.js";

/**
 * Request message for Bigtable.ReadRows.
 *
 * @generated from message google.bigtable.v2.ReadRowsRequest
 */
export class ReadRowsRequest extends Message<ReadRowsRequest> {
  /**
   * The unique name of the table from which to read.
   * Values are of the form
   * `projects/<project>/instances/<instance>/tables/<table>`.
   *
   * @generated from field: string table_name = 1;
   */
  tableName = "";

  /**
   * The row keys and/or ranges to read. If not specified, reads from all rows.
   *
   * @generated from field: google.bigtable.v2.RowSet rows = 2;
   */
  rows?: RowSet;

  /**
   * The filter to apply to the contents of the specified row(s). If unset,
   * reads the entirety of each row.
   *
   * @generated from field: google.bigtable.v2.RowFilter filter = 3;
   */
  filter?: RowFilter;

  /**
   * The read will terminate after committing to N rows' worth of results. The
   * default (zero) is to return all results.
   *
   * @generated from field: int64 rows_limit = 4;
   */
  rowsLimit = protoInt64.zero;

  constructor(data?: PartialMessage<ReadRowsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v2.ReadRowsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "rows", kind: "message", T: RowSet },
    { no: 3, name: "filter", kind: "message", T: RowFilter },
    { no: 4, name: "rows_limit", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadRowsRequest {
    return new ReadRowsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadRowsRequest {
    return new ReadRowsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadRowsRequest {
    return new ReadRowsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReadRowsRequest | PlainMessage<ReadRowsRequest> | undefined, b: ReadRowsRequest | PlainMessage<ReadRowsRequest> | undefined): boolean {
    return proto3.util.equals(ReadRowsRequest, a, b);
  }
}

/**
 * Response message for Bigtable.ReadRows.
 *
 * @generated from message google.bigtable.v2.ReadRowsResponse
 */
export class ReadRowsResponse extends Message<ReadRowsResponse> {
  /**
   * @generated from field: repeated google.bigtable.v2.ReadRowsResponse.CellChunk chunks = 1;
   */
  chunks: ReadRowsResponse_CellChunk[] = [];

  /**
   * Optionally the server might return the row key of the last row it
   * has scanned.  The client can use this to construct a more
   * efficient retry request if needed: any row keys or portions of
   * ranges less than this row key can be dropped from the request.
   * This is primarily useful for cases where the server has read a
   * lot of data that was filtered out since the last committed row
   * key, allowing the client to skip that work on a retry.
   *
   * @generated from field: bytes last_scanned_row_key = 2;
   */
  lastScannedRowKey = new Uint8Array(0);

  constructor(data?: PartialMessage<ReadRowsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v2.ReadRowsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chunks", kind: "message", T: ReadRowsResponse_CellChunk, repeated: true },
    { no: 2, name: "last_scanned_row_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadRowsResponse {
    return new ReadRowsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadRowsResponse {
    return new ReadRowsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadRowsResponse {
    return new ReadRowsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReadRowsResponse | PlainMessage<ReadRowsResponse> | undefined, b: ReadRowsResponse | PlainMessage<ReadRowsResponse> | undefined): boolean {
    return proto3.util.equals(ReadRowsResponse, a, b);
  }
}

/**
 * Specifies a piece of a row's contents returned as part of the read
 * response stream.
 *
 * @generated from message google.bigtable.v2.ReadRowsResponse.CellChunk
 */
export class ReadRowsResponse_CellChunk extends Message<ReadRowsResponse_CellChunk> {
  /**
   * The row key for this chunk of data.  If the row key is empty,
   * this CellChunk is a continuation of the same row as the previous
   * CellChunk in the response stream, even if that CellChunk was in a
   * previous ReadRowsResponse message.
   *
   * @generated from field: bytes row_key = 1;
   */
  rowKey = new Uint8Array(0);

  /**
   * The column family name for this chunk of data.  If this message
   * is not present this CellChunk is a continuation of the same column
   * family as the previous CellChunk.  The empty string can occur as a
   * column family name in a response so clients must check
   * explicitly for the presence of this message, not just for
   * `family_name.value` being non-empty.
   *
   * @generated from field: google.protobuf.StringValue family_name = 2;
   */
  familyName?: string;

  /**
   * The column qualifier for this chunk of data.  If this message
   * is not present, this CellChunk is a continuation of the same column
   * as the previous CellChunk.  Column qualifiers may be empty so
   * clients must check for the presence of this message, not just
   * for `qualifier.value` being non-empty.
   *
   * @generated from field: google.protobuf.BytesValue qualifier = 3;
   */
  qualifier?: Uint8Array;

  /**
   * The cell's stored timestamp, which also uniquely identifies it
   * within its column.  Values are always expressed in
   * microseconds, but individual tables may set a coarser
   * granularity to further restrict the allowed values. For
   * example, a table which specifies millisecond granularity will
   * only allow values of `timestamp_micros` which are multiples of
   * 1000.  Timestamps are only set in the first CellChunk per cell
   * (for cells split into multiple chunks).
   *
   * @generated from field: int64 timestamp_micros = 4;
   */
  timestampMicros = protoInt64.zero;

  /**
   * Labels applied to the cell by a
   * [RowFilter][google.bigtable.v2.RowFilter].  Labels are only set
   * on the first CellChunk per cell.
   *
   * @generated from field: repeated string labels = 5;
   */
  labels: string[] = [];

  /**
   * The value stored in the cell.  Cell values can be split across
   * multiple CellChunks.  In that case only the value field will be
   * set in CellChunks after the first: the timestamp and labels
   * will only be present in the first CellChunk, even if the first
   * CellChunk came in a previous ReadRowsResponse.
   *
   * @generated from field: bytes value = 6;
   */
  value = new Uint8Array(0);

  /**
   * If this CellChunk is part of a chunked cell value and this is
   * not the final chunk of that cell, value_size will be set to the
   * total length of the cell value.  The client can use this size
   * to pre-allocate memory to hold the full cell value.
   *
   * @generated from field: int32 value_size = 7;
   */
  valueSize = 0;

  /**
   * @generated from oneof google.bigtable.v2.ReadRowsResponse.CellChunk.row_status
   */
  rowStatus: {
    /**
     * Indicates that the client should drop all previous chunks for
     * `row_key`, as it will be re-read from the beginning.
     *
     * @generated from field: bool reset_row = 8;
     */
    value: boolean;
    case: "resetRow";
  } | {
    /**
     * Indicates that the client can safely process all previous chunks for
     * `row_key`, as its data has been fully read.
     *
     * @generated from field: bool commit_row = 9;
     */
    value: boolean;
    case: "commitRow";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ReadRowsResponse_CellChunk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v2.ReadRowsResponse.CellChunk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "row_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "family_name", kind: "message", T: StringValue },
    { no: 3, name: "qualifier", kind: "message", T: BytesValue },
    { no: 4, name: "timestamp_micros", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "labels", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "value_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 8, name: "reset_row", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "row_status" },
    { no: 9, name: "commit_row", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "row_status" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadRowsResponse_CellChunk {
    return new ReadRowsResponse_CellChunk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadRowsResponse_CellChunk {
    return new ReadRowsResponse_CellChunk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadRowsResponse_CellChunk {
    return new ReadRowsResponse_CellChunk().fromJsonString(jsonString, options);
  }

  static equals(a: ReadRowsResponse_CellChunk | PlainMessage<ReadRowsResponse_CellChunk> | undefined, b: ReadRowsResponse_CellChunk | PlainMessage<ReadRowsResponse_CellChunk> | undefined): boolean {
    return proto3.util.equals(ReadRowsResponse_CellChunk, a, b);
  }
}

/**
 * Request message for Bigtable.SampleRowKeys.
 *
 * @generated from message google.bigtable.v2.SampleRowKeysRequest
 */
export class SampleRowKeysRequest extends Message<SampleRowKeysRequest> {
  /**
   * The unique name of the table from which to sample row keys.
   * Values are of the form
   * `projects/<project>/instances/<instance>/tables/<table>`.
   *
   * @generated from field: string table_name = 1;
   */
  tableName = "";

  constructor(data?: PartialMessage<SampleRowKeysRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v2.SampleRowKeysRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SampleRowKeysRequest {
    return new SampleRowKeysRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SampleRowKeysRequest {
    return new SampleRowKeysRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SampleRowKeysRequest {
    return new SampleRowKeysRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SampleRowKeysRequest | PlainMessage<SampleRowKeysRequest> | undefined, b: SampleRowKeysRequest | PlainMessage<SampleRowKeysRequest> | undefined): boolean {
    return proto3.util.equals(SampleRowKeysRequest, a, b);
  }
}

/**
 * Response message for Bigtable.SampleRowKeys.
 *
 * @generated from message google.bigtable.v2.SampleRowKeysResponse
 */
export class SampleRowKeysResponse extends Message<SampleRowKeysResponse> {
  /**
   * Sorted streamed sequence of sample row keys in the table. The table might
   * have contents before the first row key in the list and after the last one,
   * but a key containing the empty string indicates "end of table" and will be
   * the last response given, if present.
   * Note that row keys in this list may not have ever been written to or read
   * from, and users should therefore not make any assumptions about the row key
   * structure that are specific to their use case.
   *
   * @generated from field: bytes row_key = 1;
   */
  rowKey = new Uint8Array(0);

  /**
   * Approximate total storage space used by all rows in the table which precede
   * `row_key`. Buffering the contents of all rows between two subsequent
   * samples would require space roughly equal to the difference in their
   * `offset_bytes` fields.
   *
   * @generated from field: int64 offset_bytes = 2;
   */
  offsetBytes = protoInt64.zero;

  constructor(data?: PartialMessage<SampleRowKeysResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v2.SampleRowKeysResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "row_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "offset_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SampleRowKeysResponse {
    return new SampleRowKeysResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SampleRowKeysResponse {
    return new SampleRowKeysResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SampleRowKeysResponse {
    return new SampleRowKeysResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SampleRowKeysResponse | PlainMessage<SampleRowKeysResponse> | undefined, b: SampleRowKeysResponse | PlainMessage<SampleRowKeysResponse> | undefined): boolean {
    return proto3.util.equals(SampleRowKeysResponse, a, b);
  }
}

/**
 * Request message for Bigtable.MutateRow.
 *
 * @generated from message google.bigtable.v2.MutateRowRequest
 */
export class MutateRowRequest extends Message<MutateRowRequest> {
  /**
   * The unique name of the table to which the mutation should be applied.
   * Values are of the form
   * `projects/<project>/instances/<instance>/tables/<table>`.
   *
   * @generated from field: string table_name = 1;
   */
  tableName = "";

  /**
   * The key of the row to which the mutation should be applied.
   *
   * @generated from field: bytes row_key = 2;
   */
  rowKey = new Uint8Array(0);

  /**
   * Changes to be atomically applied to the specified row. Entries are applied
   * in order, meaning that earlier mutations can be masked by later ones.
   * Must contain at least one entry and at most 100000.
   *
   * @generated from field: repeated google.bigtable.v2.Mutation mutations = 3;
   */
  mutations: Mutation[] = [];

  constructor(data?: PartialMessage<MutateRowRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v2.MutateRowRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "row_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "mutations", kind: "message", T: Mutation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MutateRowRequest {
    return new MutateRowRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MutateRowRequest {
    return new MutateRowRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MutateRowRequest {
    return new MutateRowRequest().fromJsonString(jsonString, options);
  }

  static equals(a: MutateRowRequest | PlainMessage<MutateRowRequest> | undefined, b: MutateRowRequest | PlainMessage<MutateRowRequest> | undefined): boolean {
    return proto3.util.equals(MutateRowRequest, a, b);
  }
}

/**
 * Response message for Bigtable.MutateRow.
 *
 * @generated from message google.bigtable.v2.MutateRowResponse
 */
export class MutateRowResponse extends Message<MutateRowResponse> {
  constructor(data?: PartialMessage<MutateRowResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v2.MutateRowResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MutateRowResponse {
    return new MutateRowResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MutateRowResponse {
    return new MutateRowResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MutateRowResponse {
    return new MutateRowResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MutateRowResponse | PlainMessage<MutateRowResponse> | undefined, b: MutateRowResponse | PlainMessage<MutateRowResponse> | undefined): boolean {
    return proto3.util.equals(MutateRowResponse, a, b);
  }
}

/**
 * Request message for BigtableService.MutateRows.
 *
 * @generated from message google.bigtable.v2.MutateRowsRequest
 */
export class MutateRowsRequest extends Message<MutateRowsRequest> {
  /**
   * The unique name of the table to which the mutations should be applied.
   *
   * @generated from field: string table_name = 1;
   */
  tableName = "";

  /**
   * The row keys and corresponding mutations to be applied in bulk.
   * Each entry is applied as an atomic mutation, but the entries may be
   * applied in arbitrary order (even between entries for the same row).
   * At least one entry must be specified, and in total the entries can
   * contain at most 100000 mutations.
   *
   * @generated from field: repeated google.bigtable.v2.MutateRowsRequest.Entry entries = 2;
   */
  entries: MutateRowsRequest_Entry[] = [];

  constructor(data?: PartialMessage<MutateRowsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v2.MutateRowsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "entries", kind: "message", T: MutateRowsRequest_Entry, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MutateRowsRequest {
    return new MutateRowsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MutateRowsRequest {
    return new MutateRowsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MutateRowsRequest {
    return new MutateRowsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: MutateRowsRequest | PlainMessage<MutateRowsRequest> | undefined, b: MutateRowsRequest | PlainMessage<MutateRowsRequest> | undefined): boolean {
    return proto3.util.equals(MutateRowsRequest, a, b);
  }
}

/**
 * @generated from message google.bigtable.v2.MutateRowsRequest.Entry
 */
export class MutateRowsRequest_Entry extends Message<MutateRowsRequest_Entry> {
  /**
   * The key of the row to which the `mutations` should be applied.
   *
   * @generated from field: bytes row_key = 1;
   */
  rowKey = new Uint8Array(0);

  /**
   * Changes to be atomically applied to the specified row. Mutations are
   * applied in order, meaning that earlier mutations can be masked by
   * later ones.
   * You must specify at least one mutation.
   *
   * @generated from field: repeated google.bigtable.v2.Mutation mutations = 2;
   */
  mutations: Mutation[] = [];

  constructor(data?: PartialMessage<MutateRowsRequest_Entry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v2.MutateRowsRequest.Entry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "row_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "mutations", kind: "message", T: Mutation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MutateRowsRequest_Entry {
    return new MutateRowsRequest_Entry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MutateRowsRequest_Entry {
    return new MutateRowsRequest_Entry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MutateRowsRequest_Entry {
    return new MutateRowsRequest_Entry().fromJsonString(jsonString, options);
  }

  static equals(a: MutateRowsRequest_Entry | PlainMessage<MutateRowsRequest_Entry> | undefined, b: MutateRowsRequest_Entry | PlainMessage<MutateRowsRequest_Entry> | undefined): boolean {
    return proto3.util.equals(MutateRowsRequest_Entry, a, b);
  }
}

/**
 * Response message for BigtableService.MutateRows.
 *
 * @generated from message google.bigtable.v2.MutateRowsResponse
 */
export class MutateRowsResponse extends Message<MutateRowsResponse> {
  /**
   * One or more results for Entries from the batch request.
   *
   * @generated from field: repeated google.bigtable.v2.MutateRowsResponse.Entry entries = 1;
   */
  entries: MutateRowsResponse_Entry[] = [];

  constructor(data?: PartialMessage<MutateRowsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v2.MutateRowsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entries", kind: "message", T: MutateRowsResponse_Entry, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MutateRowsResponse {
    return new MutateRowsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MutateRowsResponse {
    return new MutateRowsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MutateRowsResponse {
    return new MutateRowsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MutateRowsResponse | PlainMessage<MutateRowsResponse> | undefined, b: MutateRowsResponse | PlainMessage<MutateRowsResponse> | undefined): boolean {
    return proto3.util.equals(MutateRowsResponse, a, b);
  }
}

/**
 * @generated from message google.bigtable.v2.MutateRowsResponse.Entry
 */
export class MutateRowsResponse_Entry extends Message<MutateRowsResponse_Entry> {
  /**
   * The index into the original request's `entries` list of the Entry
   * for which a result is being reported.
   *
   * @generated from field: int64 index = 1;
   */
  index = protoInt64.zero;

  /**
   * The result of the request Entry identified by `index`.
   * Depending on how requests are batched during execution, it is possible
   * for one Entry to fail due to an error with another Entry. In the event
   * that this occurs, the same error will be reported for both entries.
   *
   * @generated from field: google.rpc.Status status = 2;
   */
  status?: Status;

  constructor(data?: PartialMessage<MutateRowsResponse_Entry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v2.MutateRowsResponse.Entry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "index", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "status", kind: "message", T: Status },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MutateRowsResponse_Entry {
    return new MutateRowsResponse_Entry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MutateRowsResponse_Entry {
    return new MutateRowsResponse_Entry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MutateRowsResponse_Entry {
    return new MutateRowsResponse_Entry().fromJsonString(jsonString, options);
  }

  static equals(a: MutateRowsResponse_Entry | PlainMessage<MutateRowsResponse_Entry> | undefined, b: MutateRowsResponse_Entry | PlainMessage<MutateRowsResponse_Entry> | undefined): boolean {
    return proto3.util.equals(MutateRowsResponse_Entry, a, b);
  }
}

/**
 * Request message for Bigtable.CheckAndMutateRow.
 *
 * @generated from message google.bigtable.v2.CheckAndMutateRowRequest
 */
export class CheckAndMutateRowRequest extends Message<CheckAndMutateRowRequest> {
  /**
   * The unique name of the table to which the conditional mutation should be
   * applied.
   * Values are of the form
   * `projects/<project>/instances/<instance>/tables/<table>`.
   *
   * @generated from field: string table_name = 1;
   */
  tableName = "";

  /**
   * The key of the row to which the conditional mutation should be applied.
   *
   * @generated from field: bytes row_key = 2;
   */
  rowKey = new Uint8Array(0);

  /**
   * The filter to be applied to the contents of the specified row. Depending
   * on whether or not any results are yielded, either `true_mutations` or
   * `false_mutations` will be executed. If unset, checks that the row contains
   * any values at all.
   *
   * @generated from field: google.bigtable.v2.RowFilter predicate_filter = 6;
   */
  predicateFilter?: RowFilter;

  /**
   * Changes to be atomically applied to the specified row if `predicate_filter`
   * yields at least one cell when applied to `row_key`. Entries are applied in
   * order, meaning that earlier mutations can be masked by later ones.
   * Must contain at least one entry if `false_mutations` is empty, and at most
   * 100000.
   *
   * @generated from field: repeated google.bigtable.v2.Mutation true_mutations = 4;
   */
  trueMutations: Mutation[] = [];

  /**
   * Changes to be atomically applied to the specified row if `predicate_filter`
   * does not yield any cells when applied to `row_key`. Entries are applied in
   * order, meaning that earlier mutations can be masked by later ones.
   * Must contain at least one entry if `true_mutations` is empty, and at most
   * 100000.
   *
   * @generated from field: repeated google.bigtable.v2.Mutation false_mutations = 5;
   */
  falseMutations: Mutation[] = [];

  constructor(data?: PartialMessage<CheckAndMutateRowRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v2.CheckAndMutateRowRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "row_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "predicate_filter", kind: "message", T: RowFilter },
    { no: 4, name: "true_mutations", kind: "message", T: Mutation, repeated: true },
    { no: 5, name: "false_mutations", kind: "message", T: Mutation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckAndMutateRowRequest {
    return new CheckAndMutateRowRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckAndMutateRowRequest {
    return new CheckAndMutateRowRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckAndMutateRowRequest {
    return new CheckAndMutateRowRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CheckAndMutateRowRequest | PlainMessage<CheckAndMutateRowRequest> | undefined, b: CheckAndMutateRowRequest | PlainMessage<CheckAndMutateRowRequest> | undefined): boolean {
    return proto3.util.equals(CheckAndMutateRowRequest, a, b);
  }
}

/**
 * Response message for Bigtable.CheckAndMutateRow.
 *
 * @generated from message google.bigtable.v2.CheckAndMutateRowResponse
 */
export class CheckAndMutateRowResponse extends Message<CheckAndMutateRowResponse> {
  /**
   * Whether or not the request's `predicate_filter` yielded any results for
   * the specified row.
   *
   * @generated from field: bool predicate_matched = 1;
   */
  predicateMatched = false;

  constructor(data?: PartialMessage<CheckAndMutateRowResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v2.CheckAndMutateRowResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "predicate_matched", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckAndMutateRowResponse {
    return new CheckAndMutateRowResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckAndMutateRowResponse {
    return new CheckAndMutateRowResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckAndMutateRowResponse {
    return new CheckAndMutateRowResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CheckAndMutateRowResponse | PlainMessage<CheckAndMutateRowResponse> | undefined, b: CheckAndMutateRowResponse | PlainMessage<CheckAndMutateRowResponse> | undefined): boolean {
    return proto3.util.equals(CheckAndMutateRowResponse, a, b);
  }
}

/**
 * Request message for Bigtable.ReadModifyWriteRow.
 *
 * @generated from message google.bigtable.v2.ReadModifyWriteRowRequest
 */
export class ReadModifyWriteRowRequest extends Message<ReadModifyWriteRowRequest> {
  /**
   * The unique name of the table to which the read/modify/write rules should be
   * applied.
   * Values are of the form
   * `projects/<project>/instances/<instance>/tables/<table>`.
   *
   * @generated from field: string table_name = 1;
   */
  tableName = "";

  /**
   * The key of the row to which the read/modify/write rules should be applied.
   *
   * @generated from field: bytes row_key = 2;
   */
  rowKey = new Uint8Array(0);

  /**
   * Rules specifying how the specified row's contents are to be transformed
   * into writes. Entries are applied in order, meaning that earlier rules will
   * affect the results of later ones.
   *
   * @generated from field: repeated google.bigtable.v2.ReadModifyWriteRule rules = 3;
   */
  rules: ReadModifyWriteRule[] = [];

  constructor(data?: PartialMessage<ReadModifyWriteRowRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v2.ReadModifyWriteRowRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "row_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "rules", kind: "message", T: ReadModifyWriteRule, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadModifyWriteRowRequest {
    return new ReadModifyWriteRowRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadModifyWriteRowRequest {
    return new ReadModifyWriteRowRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadModifyWriteRowRequest {
    return new ReadModifyWriteRowRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReadModifyWriteRowRequest | PlainMessage<ReadModifyWriteRowRequest> | undefined, b: ReadModifyWriteRowRequest | PlainMessage<ReadModifyWriteRowRequest> | undefined): boolean {
    return proto3.util.equals(ReadModifyWriteRowRequest, a, b);
  }
}

/**
 * Response message for Bigtable.ReadModifyWriteRow.
 *
 * @generated from message google.bigtable.v2.ReadModifyWriteRowResponse
 */
export class ReadModifyWriteRowResponse extends Message<ReadModifyWriteRowResponse> {
  /**
   * A Row containing the new contents of all cells modified by the request.
   *
   * @generated from field: google.bigtable.v2.Row row = 1;
   */
  row?: Row;

  constructor(data?: PartialMessage<ReadModifyWriteRowResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v2.ReadModifyWriteRowResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "row", kind: "message", T: Row },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadModifyWriteRowResponse {
    return new ReadModifyWriteRowResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadModifyWriteRowResponse {
    return new ReadModifyWriteRowResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadModifyWriteRowResponse {
    return new ReadModifyWriteRowResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReadModifyWriteRowResponse | PlainMessage<ReadModifyWriteRowResponse> | undefined, b: ReadModifyWriteRowResponse | PlainMessage<ReadModifyWriteRowResponse> | undefined): boolean {
    return proto3.util.equals(ReadModifyWriteRowResponse, a, b);
  }
}

