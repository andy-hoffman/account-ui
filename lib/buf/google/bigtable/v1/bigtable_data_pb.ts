// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/bigtable/v1/bigtable_data.proto (package google.bigtable.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * Specifies the complete (requested) contents of a single row of a table.
 * Rows which exceed 256MiB in size cannot be read in full.
 *
 * @generated from message google.bigtable.v1.Row
 */
export class Row extends Message<Row> {
  /**
   * The unique key which identifies this row within its table. This is the same
   * key that's used to identify the row in, for example, a MutateRowRequest.
   * May contain any non-empty byte string up to 4KiB in length.
   *
   * @generated from field: bytes key = 1;
   */
  key = new Uint8Array(0);

  /**
   * May be empty, but only if the entire row is empty.
   * The mutual ordering of column families is not specified.
   *
   * @generated from field: repeated google.bigtable.v1.Family families = 2;
   */
  families: Family[] = [];

  constructor(data?: PartialMessage<Row>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.Row";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "families", kind: "message", T: Family, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Row {
    return new Row().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Row {
    return new Row().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Row {
    return new Row().fromJsonString(jsonString, options);
  }

  static equals(a: Row | PlainMessage<Row> | undefined, b: Row | PlainMessage<Row> | undefined): boolean {
    return proto3.util.equals(Row, a, b);
  }
}

/**
 * Specifies (some of) the contents of a single row/column family of a table.
 *
 * @generated from message google.bigtable.v1.Family
 */
export class Family extends Message<Family> {
  /**
   * The unique key which identifies this family within its row. This is the
   * same key that's used to identify the family in, for example, a RowFilter
   * which sets its "family_name_regex_filter" field.
   * Must match [-_.a-zA-Z0-9]+, except that AggregatingRowProcessors may
   * produce cells in a sentinel family with an empty name.
   * Must be no greater than 64 characters in length.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Must not be empty. Sorted in order of increasing "qualifier".
   *
   * @generated from field: repeated google.bigtable.v1.Column columns = 2;
   */
  columns: Column[] = [];

  constructor(data?: PartialMessage<Family>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.Family";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "columns", kind: "message", T: Column, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Family {
    return new Family().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Family {
    return new Family().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Family {
    return new Family().fromJsonString(jsonString, options);
  }

  static equals(a: Family | PlainMessage<Family> | undefined, b: Family | PlainMessage<Family> | undefined): boolean {
    return proto3.util.equals(Family, a, b);
  }
}

/**
 * Specifies (some of) the contents of a single row/column of a table.
 *
 * @generated from message google.bigtable.v1.Column
 */
export class Column extends Message<Column> {
  /**
   * The unique key which identifies this column within its family. This is the
   * same key that's used to identify the column in, for example, a RowFilter
   * which sets its "column_qualifier_regex_filter" field.
   * May contain any byte string, including the empty string, up to 16kiB in
   * length.
   *
   * @generated from field: bytes qualifier = 1;
   */
  qualifier = new Uint8Array(0);

  /**
   * Must not be empty. Sorted in order of decreasing "timestamp_micros".
   *
   * @generated from field: repeated google.bigtable.v1.Cell cells = 2;
   */
  cells: Cell[] = [];

  constructor(data?: PartialMessage<Column>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.Column";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "qualifier", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "cells", kind: "message", T: Cell, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Column {
    return new Column().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Column {
    return new Column().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Column {
    return new Column().fromJsonString(jsonString, options);
  }

  static equals(a: Column | PlainMessage<Column> | undefined, b: Column | PlainMessage<Column> | undefined): boolean {
    return proto3.util.equals(Column, a, b);
  }
}

/**
 * Specifies (some of) the contents of a single row/column/timestamp of a table.
 *
 * @generated from message google.bigtable.v1.Cell
 */
export class Cell extends Message<Cell> {
  /**
   * The cell's stored timestamp, which also uniquely identifies it within
   * its column.
   * Values are always expressed in microseconds, but individual tables may set
   * a coarser "granularity" to further restrict the allowed values. For
   * example, a table which specifies millisecond granularity will only allow
   * values of "timestamp_micros" which are multiples of 1000.
   *
   * @generated from field: int64 timestamp_micros = 1;
   */
  timestampMicros = protoInt64.zero;

  /**
   * The value stored in the cell.
   * May contain any byte string, including the empty string, up to 100MiB in
   * length.
   *
   * @generated from field: bytes value = 2;
   */
  value = new Uint8Array(0);

  /**
   * Labels applied to the cell by a [RowFilter][google.bigtable.v1.RowFilter].
   *
   * @generated from field: repeated string labels = 3;
   */
  labels: string[] = [];

  constructor(data?: PartialMessage<Cell>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.Cell";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp_micros", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "labels", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Cell {
    return new Cell().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Cell {
    return new Cell().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Cell {
    return new Cell().fromJsonString(jsonString, options);
  }

  static equals(a: Cell | PlainMessage<Cell> | undefined, b: Cell | PlainMessage<Cell> | undefined): boolean {
    return proto3.util.equals(Cell, a, b);
  }
}

/**
 * Specifies a contiguous range of rows.
 *
 * @generated from message google.bigtable.v1.RowRange
 */
export class RowRange extends Message<RowRange> {
  /**
   * Inclusive lower bound. If left empty, interpreted as the empty string.
   *
   * @generated from field: bytes start_key = 2;
   */
  startKey = new Uint8Array(0);

  /**
   * Exclusive upper bound. If left empty, interpreted as infinity.
   *
   * @generated from field: bytes end_key = 3;
   */
  endKey = new Uint8Array(0);

  constructor(data?: PartialMessage<RowRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.RowRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "start_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "end_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RowRange {
    return new RowRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RowRange {
    return new RowRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RowRange {
    return new RowRange().fromJsonString(jsonString, options);
  }

  static equals(a: RowRange | PlainMessage<RowRange> | undefined, b: RowRange | PlainMessage<RowRange> | undefined): boolean {
    return proto3.util.equals(RowRange, a, b);
  }
}

/**
 * Specifies a non-contiguous set of rows.
 *
 * @generated from message google.bigtable.v1.RowSet
 */
export class RowSet extends Message<RowSet> {
  /**
   * Single rows included in the set.
   *
   * @generated from field: repeated bytes row_keys = 1;
   */
  rowKeys: Uint8Array[] = [];

  /**
   * Contiguous row ranges included in the set.
   *
   * @generated from field: repeated google.bigtable.v1.RowRange row_ranges = 2;
   */
  rowRanges: RowRange[] = [];

  constructor(data?: PartialMessage<RowSet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.RowSet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "row_keys", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
    { no: 2, name: "row_ranges", kind: "message", T: RowRange, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RowSet {
    return new RowSet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RowSet {
    return new RowSet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RowSet {
    return new RowSet().fromJsonString(jsonString, options);
  }

  static equals(a: RowSet | PlainMessage<RowSet> | undefined, b: RowSet | PlainMessage<RowSet> | undefined): boolean {
    return proto3.util.equals(RowSet, a, b);
  }
}

/**
 * Specifies a contiguous range of columns within a single column family.
 * The range spans from <column_family>:<start_qualifier> to
 * <column_family>:<end_qualifier>, where both bounds can be either inclusive or
 * exclusive.
 *
 * @generated from message google.bigtable.v1.ColumnRange
 */
export class ColumnRange extends Message<ColumnRange> {
  /**
   * The name of the column family within which this range falls.
   *
   * @generated from field: string family_name = 1;
   */
  familyName = "";

  /**
   * The column qualifier at which to start the range (within 'column_family').
   * If neither field is set, interpreted as the empty string, inclusive.
   *
   * @generated from oneof google.bigtable.v1.ColumnRange.start_qualifier
   */
  startQualifier: {
    /**
     * Used when giving an inclusive lower bound for the range.
     *
     * @generated from field: bytes start_qualifier_inclusive = 2;
     */
    value: Uint8Array;
    case: "startQualifierInclusive";
  } | {
    /**
     * Used when giving an exclusive lower bound for the range.
     *
     * @generated from field: bytes start_qualifier_exclusive = 3;
     */
    value: Uint8Array;
    case: "startQualifierExclusive";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The column qualifier at which to end the range (within 'column_family').
   * If neither field is set, interpreted as the infinite string, exclusive.
   *
   * @generated from oneof google.bigtable.v1.ColumnRange.end_qualifier
   */
  endQualifier: {
    /**
     * Used when giving an inclusive upper bound for the range.
     *
     * @generated from field: bytes end_qualifier_inclusive = 4;
     */
    value: Uint8Array;
    case: "endQualifierInclusive";
  } | {
    /**
     * Used when giving an exclusive upper bound for the range.
     *
     * @generated from field: bytes end_qualifier_exclusive = 5;
     */
    value: Uint8Array;
    case: "endQualifierExclusive";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ColumnRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.ColumnRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "family_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "start_qualifier_inclusive", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "start_qualifier" },
    { no: 3, name: "start_qualifier_exclusive", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "start_qualifier" },
    { no: 4, name: "end_qualifier_inclusive", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "end_qualifier" },
    { no: 5, name: "end_qualifier_exclusive", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "end_qualifier" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ColumnRange {
    return new ColumnRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ColumnRange {
    return new ColumnRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ColumnRange {
    return new ColumnRange().fromJsonString(jsonString, options);
  }

  static equals(a: ColumnRange | PlainMessage<ColumnRange> | undefined, b: ColumnRange | PlainMessage<ColumnRange> | undefined): boolean {
    return proto3.util.equals(ColumnRange, a, b);
  }
}

/**
 * Specified a contiguous range of microsecond timestamps.
 *
 * @generated from message google.bigtable.v1.TimestampRange
 */
export class TimestampRange extends Message<TimestampRange> {
  /**
   * Inclusive lower bound. If left empty, interpreted as 0.
   *
   * @generated from field: int64 start_timestamp_micros = 1;
   */
  startTimestampMicros = protoInt64.zero;

  /**
   * Exclusive upper bound. If left empty, interpreted as infinity.
   *
   * @generated from field: int64 end_timestamp_micros = 2;
   */
  endTimestampMicros = protoInt64.zero;

  constructor(data?: PartialMessage<TimestampRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.TimestampRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_timestamp_micros", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "end_timestamp_micros", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimestampRange {
    return new TimestampRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimestampRange {
    return new TimestampRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimestampRange {
    return new TimestampRange().fromJsonString(jsonString, options);
  }

  static equals(a: TimestampRange | PlainMessage<TimestampRange> | undefined, b: TimestampRange | PlainMessage<TimestampRange> | undefined): boolean {
    return proto3.util.equals(TimestampRange, a, b);
  }
}

/**
 * Specifies a contiguous range of raw byte values.
 *
 * @generated from message google.bigtable.v1.ValueRange
 */
export class ValueRange extends Message<ValueRange> {
  /**
   * The value at which to start the range.
   * If neither field is set, interpreted as the empty string, inclusive.
   *
   * @generated from oneof google.bigtable.v1.ValueRange.start_value
   */
  startValue: {
    /**
     * Used when giving an inclusive lower bound for the range.
     *
     * @generated from field: bytes start_value_inclusive = 1;
     */
    value: Uint8Array;
    case: "startValueInclusive";
  } | {
    /**
     * Used when giving an exclusive lower bound for the range.
     *
     * @generated from field: bytes start_value_exclusive = 2;
     */
    value: Uint8Array;
    case: "startValueExclusive";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The value at which to end the range.
   * If neither field is set, interpreted as the infinite string, exclusive.
   *
   * @generated from oneof google.bigtable.v1.ValueRange.end_value
   */
  endValue: {
    /**
     * Used when giving an inclusive upper bound for the range.
     *
     * @generated from field: bytes end_value_inclusive = 3;
     */
    value: Uint8Array;
    case: "endValueInclusive";
  } | {
    /**
     * Used when giving an exclusive upper bound for the range.
     *
     * @generated from field: bytes end_value_exclusive = 4;
     */
    value: Uint8Array;
    case: "endValueExclusive";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ValueRange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.ValueRange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start_value_inclusive", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "start_value" },
    { no: 2, name: "start_value_exclusive", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "start_value" },
    { no: 3, name: "end_value_inclusive", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "end_value" },
    { no: 4, name: "end_value_exclusive", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "end_value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValueRange {
    return new ValueRange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValueRange {
    return new ValueRange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValueRange {
    return new ValueRange().fromJsonString(jsonString, options);
  }

  static equals(a: ValueRange | PlainMessage<ValueRange> | undefined, b: ValueRange | PlainMessage<ValueRange> | undefined): boolean {
    return proto3.util.equals(ValueRange, a, b);
  }
}

/**
 * Takes a row as input and produces an alternate view of the row based on
 * specified rules. For example, a RowFilter might trim down a row to include
 * just the cells from columns matching a given regular expression, or might
 * return all the cells of a row but not their values. More complicated filters
 * can be composed out of these components to express requests such as, "within
 * every column of a particular family, give just the two most recent cells
 * which are older than timestamp X."
 *
 * There are two broad categories of RowFilters (true filters and transformers),
 * as well as two ways to compose simple filters into more complex ones
 * (chains and interleaves). They work as follows:
 *
 * * True filters alter the input row by excluding some of its cells wholesale
 * from the output row. An example of a true filter is the "value_regex_filter",
 * which excludes cells whose values don't match the specified pattern. All
 * regex true filters use RE2 syntax (https://github.com/google/re2/wiki/Syntax)
 * in raw byte mode (RE2::Latin1), and are evaluated as full matches. An
 * important point to keep in mind is that RE2(.) is equivalent by default to
 * RE2([^\n]), meaning that it does not match newlines. When attempting to match
 * an arbitrary byte, you should therefore use the escape sequence '\C', which
 * may need to be further escaped as '\\C' in your client language.
 *
 * * Transformers alter the input row by changing the values of some of its
 * cells in the output, without excluding them completely. Currently, the only
 * supported transformer is the "strip_value_transformer", which replaces every
 * cell's value with the empty string.
 *
 * * Chains and interleaves are described in more detail in the
 * RowFilter.Chain and RowFilter.Interleave documentation.
 *
 * The total serialized size of a RowFilter message must not
 * exceed 4096 bytes, and RowFilters may not be nested within each other
 * (in Chains or Interleaves) to a depth of more than 20.
 *
 * @generated from message google.bigtable.v1.RowFilter
 */
export class RowFilter extends Message<RowFilter> {
  /**
   * Which of the possible RowFilter types to apply. If none are set, this
   * RowFilter returns all cells in the input row.
   *
   * @generated from oneof google.bigtable.v1.RowFilter.filter
   */
  filter: {
    /**
     * Applies several RowFilters to the data in sequence, progressively
     * narrowing the results.
     *
     * @generated from field: google.bigtable.v1.RowFilter.Chain chain = 1;
     */
    value: RowFilter_Chain;
    case: "chain";
  } | {
    /**
     * Applies several RowFilters to the data in parallel and combines the
     * results.
     *
     * @generated from field: google.bigtable.v1.RowFilter.Interleave interleave = 2;
     */
    value: RowFilter_Interleave;
    case: "interleave";
  } | {
    /**
     * Applies one of two possible RowFilters to the data based on the output of
     * a predicate RowFilter.
     *
     * @generated from field: google.bigtable.v1.RowFilter.Condition condition = 3;
     */
    value: RowFilter_Condition;
    case: "condition";
  } | {
    /**
     * ADVANCED USE ONLY.
     * Hook for introspection into the RowFilter. Outputs all cells directly to
     * the output of the read rather than to any parent filter. Consider the
     * following example:
     *
     * Chain(
     *   FamilyRegex("A"),
     *   Interleave(
     *     All(),
     *     Chain(Label("foo"), Sink())
     *   ),
     *   QualifierRegex("B")
     * )
     *
     *                         A,A,1,w
     *                         A,B,2,x
     *                         B,B,4,z
     *                            |
     *                     FamilyRegex("A")
     *                            |
     *                         A,A,1,w
     *                         A,B,2,x
     *                            |
     *               +------------+-------------+
     *               |                          |
     *             All()                    Label(foo)
     *               |                          |
     *            A,A,1,w              A,A,1,w,labels:[foo]
     *            A,B,2,x              A,B,2,x,labels:[foo]
     *               |                          |
     *               |                        Sink() --------------+
     *               |                          |                  |
     *               +------------+      x------+          A,A,1,w,labels:[foo]
     *                            |                        A,B,2,x,labels:[foo]
     *                         A,A,1,w                             |
     *                         A,B,2,x                             |
     *                            |                                |
     *                    QualifierRegex("B")                      |
     *                            |                                |
     *                         A,B,2,x                             |
     *                            |                                |
     *                            +--------------------------------+
     *                            |
     *                         A,A,1,w,labels:[foo]
     *                         A,B,2,x,labels:[foo]  // could be switched
     *                         A,B,2,x               // could be switched
     *
     * Despite being excluded by the qualifier filter, a copy of every cell
     * that reaches the sink is present in the final result.
     *
     * As with an [Interleave][google.bigtable.v1.RowFilter.Interleave],
     * duplicate cells are possible, and appear in an unspecified mutual order.
     * In this case we have a duplicate with column "A:B" and timestamp 2,
     * because one copy passed through the all filter while the other was
     * passed through the label and sink. Note that one copy has label "foo",
     * while the other does not.
     *
     * Cannot be used within the `predicate_filter`, `true_filter`, or
     * `false_filter` of a [Condition][google.bigtable.v1.RowFilter.Condition].
     *
     * @generated from field: bool sink = 16;
     */
    value: boolean;
    case: "sink";
  } | {
    /**
     * Matches all cells, regardless of input. Functionally equivalent to
     * leaving `filter` unset, but included for completeness.
     *
     * @generated from field: bool pass_all_filter = 17;
     */
    value: boolean;
    case: "passAllFilter";
  } | {
    /**
     * Does not match any cells, regardless of input. Useful for temporarily
     * disabling just part of a filter.
     *
     * @generated from field: bool block_all_filter = 18;
     */
    value: boolean;
    case: "blockAllFilter";
  } | {
    /**
     * Matches only cells from rows whose keys satisfy the given RE2 regex. In
     * other words, passes through the entire row when the key matches, and
     * otherwise produces an empty row.
     * Note that, since row keys can contain arbitrary bytes, the '\C' escape
     * sequence must be used if a true wildcard is desired. The '.' character
     * will not match the new line character '\n', which may be present in a
     * binary key.
     *
     * @generated from field: bytes row_key_regex_filter = 4;
     */
    value: Uint8Array;
    case: "rowKeyRegexFilter";
  } | {
    /**
     * Matches all cells from a row with probability p, and matches no cells
     * from the row with probability 1-p.
     *
     * @generated from field: double row_sample_filter = 14;
     */
    value: number;
    case: "rowSampleFilter";
  } | {
    /**
     * Matches only cells from columns whose families satisfy the given RE2
     * regex. For technical reasons, the regex must not contain the ':'
     * character, even if it is not being used as a literal.
     * Note that, since column families cannot contain the new line character
     * '\n', it is sufficient to use '.' as a full wildcard when matching
     * column family names.
     *
     * @generated from field: string family_name_regex_filter = 5;
     */
    value: string;
    case: "familyNameRegexFilter";
  } | {
    /**
     * Matches only cells from columns whose qualifiers satisfy the given RE2
     * regex.
     * Note that, since column qualifiers can contain arbitrary bytes, the '\C'
     * escape sequence must be used if a true wildcard is desired. The '.'
     * character will not match the new line character '\n', which may be
     * present in a binary qualifier.
     *
     * @generated from field: bytes column_qualifier_regex_filter = 6;
     */
    value: Uint8Array;
    case: "columnQualifierRegexFilter";
  } | {
    /**
     * Matches only cells from columns within the given range.
     *
     * @generated from field: google.bigtable.v1.ColumnRange column_range_filter = 7;
     */
    value: ColumnRange;
    case: "columnRangeFilter";
  } | {
    /**
     * Matches only cells with timestamps within the given range.
     *
     * @generated from field: google.bigtable.v1.TimestampRange timestamp_range_filter = 8;
     */
    value: TimestampRange;
    case: "timestampRangeFilter";
  } | {
    /**
     * Matches only cells with values that satisfy the given regular expression.
     * Note that, since cell values can contain arbitrary bytes, the '\C' escape
     * sequence must be used if a true wildcard is desired. The '.' character
     * will not match the new line character '\n', which may be present in a
     * binary value.
     *
     * @generated from field: bytes value_regex_filter = 9;
     */
    value: Uint8Array;
    case: "valueRegexFilter";
  } | {
    /**
     * Matches only cells with values that fall within the given range.
     *
     * @generated from field: google.bigtable.v1.ValueRange value_range_filter = 15;
     */
    value: ValueRange;
    case: "valueRangeFilter";
  } | {
    /**
     * Skips the first N cells of each row, matching all subsequent cells.
     * If duplicate cells are present, as is possible when using an Interleave,
     * each copy of the cell is counted separately.
     *
     * @generated from field: int32 cells_per_row_offset_filter = 10;
     */
    value: number;
    case: "cellsPerRowOffsetFilter";
  } | {
    /**
     * Matches only the first N cells of each row.
     * If duplicate cells are present, as is possible when using an Interleave,
     * each copy of the cell is counted separately.
     *
     * @generated from field: int32 cells_per_row_limit_filter = 11;
     */
    value: number;
    case: "cellsPerRowLimitFilter";
  } | {
    /**
     * Matches only the most recent N cells within each column. For example,
     * if N=2, this filter would match column "foo:bar" at timestamps 10 and 9,
     * skip all earlier cells in "foo:bar", and then begin matching again in
     * column "foo:bar2".
     * If duplicate cells are present, as is possible when using an Interleave,
     * each copy of the cell is counted separately.
     *
     * @generated from field: int32 cells_per_column_limit_filter = 12;
     */
    value: number;
    case: "cellsPerColumnLimitFilter";
  } | {
    /**
     * Replaces each cell's value with the empty string.
     *
     * @generated from field: bool strip_value_transformer = 13;
     */
    value: boolean;
    case: "stripValueTransformer";
  } | {
    /**
     * Applies the given label to all cells in the output row. This allows
     * the client to determine which results were produced from which part of
     * the filter.
     *
     * Values must be at most 15 characters in length, and match the RE2
     * pattern [a-z0-9\\-]+
     *
     * Due to a technical limitation, it is not currently possible to apply
     * multiple labels to a cell. As a result, a Chain may have no more than
     * one sub-filter which contains a apply_label_transformer. It is okay for
     * an Interleave to contain multiple apply_label_transformers, as they will
     * be applied to separate copies of the input. This may be relaxed in the
     * future.
     *
     * @generated from field: string apply_label_transformer = 19;
     */
    value: string;
    case: "applyLabelTransformer";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<RowFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.RowFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chain", kind: "message", T: RowFilter_Chain, oneof: "filter" },
    { no: 2, name: "interleave", kind: "message", T: RowFilter_Interleave, oneof: "filter" },
    { no: 3, name: "condition", kind: "message", T: RowFilter_Condition, oneof: "filter" },
    { no: 16, name: "sink", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "filter" },
    { no: 17, name: "pass_all_filter", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "filter" },
    { no: 18, name: "block_all_filter", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "filter" },
    { no: 4, name: "row_key_regex_filter", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "filter" },
    { no: 14, name: "row_sample_filter", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, oneof: "filter" },
    { no: 5, name: "family_name_regex_filter", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
    { no: 6, name: "column_qualifier_regex_filter", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "filter" },
    { no: 7, name: "column_range_filter", kind: "message", T: ColumnRange, oneof: "filter" },
    { no: 8, name: "timestamp_range_filter", kind: "message", T: TimestampRange, oneof: "filter" },
    { no: 9, name: "value_regex_filter", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "filter" },
    { no: 15, name: "value_range_filter", kind: "message", T: ValueRange, oneof: "filter" },
    { no: 10, name: "cells_per_row_offset_filter", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "filter" },
    { no: 11, name: "cells_per_row_limit_filter", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "filter" },
    { no: 12, name: "cells_per_column_limit_filter", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "filter" },
    { no: 13, name: "strip_value_transformer", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "filter" },
    { no: 19, name: "apply_label_transformer", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "filter" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RowFilter {
    return new RowFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RowFilter {
    return new RowFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RowFilter {
    return new RowFilter().fromJsonString(jsonString, options);
  }

  static equals(a: RowFilter | PlainMessage<RowFilter> | undefined, b: RowFilter | PlainMessage<RowFilter> | undefined): boolean {
    return proto3.util.equals(RowFilter, a, b);
  }
}

/**
 * A RowFilter which sends rows through several RowFilters in sequence.
 *
 * @generated from message google.bigtable.v1.RowFilter.Chain
 */
export class RowFilter_Chain extends Message<RowFilter_Chain> {
  /**
   * The elements of "filters" are chained together to process the input row:
   * in row -> f(0) -> intermediate row -> f(1) -> ... -> f(N) -> out row
   * The full chain is executed atomically.
   *
   * @generated from field: repeated google.bigtable.v1.RowFilter filters = 1;
   */
  filters: RowFilter[] = [];

  constructor(data?: PartialMessage<RowFilter_Chain>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.RowFilter.Chain";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filters", kind: "message", T: RowFilter, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RowFilter_Chain {
    return new RowFilter_Chain().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RowFilter_Chain {
    return new RowFilter_Chain().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RowFilter_Chain {
    return new RowFilter_Chain().fromJsonString(jsonString, options);
  }

  static equals(a: RowFilter_Chain | PlainMessage<RowFilter_Chain> | undefined, b: RowFilter_Chain | PlainMessage<RowFilter_Chain> | undefined): boolean {
    return proto3.util.equals(RowFilter_Chain, a, b);
  }
}

/**
 * A RowFilter which sends each row to each of several component
 * RowFilters and interleaves the results.
 *
 * @generated from message google.bigtable.v1.RowFilter.Interleave
 */
export class RowFilter_Interleave extends Message<RowFilter_Interleave> {
  /**
   * The elements of "filters" all process a copy of the input row, and the
   * results are pooled, sorted, and combined into a single output row.
   * If multiple cells are produced with the same column and timestamp,
   * they will all appear in the output row in an unspecified mutual order.
   * Consider the following example, with three filters:
   *
   *                              input row
   *                                  |
   *        -----------------------------------------------------
   *        |                         |                         |
   *       f(0)                      f(1)                      f(2)
   *        |                         |                         |
   * 1: foo,bar,10,x             foo,bar,10,z              far,bar,7,a
   * 2: foo,blah,11,z            far,blah,5,x              far,blah,5,x
   *        |                         |                         |
   *        -----------------------------------------------------
   *                                  |
   * 1:                        foo,bar,10,z     // could have switched with #2
   * 2:                        foo,bar,10,x     // could have switched with #1
   * 3:                        foo,blah,11,z
   * 4:                        far,bar,7,a
   * 5:                        far,blah,5,x     // identical to #6
   * 6:                        far,blah,5,x     // identical to #5
   * All interleaved filters are executed atomically.
   *
   * @generated from field: repeated google.bigtable.v1.RowFilter filters = 1;
   */
  filters: RowFilter[] = [];

  constructor(data?: PartialMessage<RowFilter_Interleave>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.RowFilter.Interleave";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filters", kind: "message", T: RowFilter, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RowFilter_Interleave {
    return new RowFilter_Interleave().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RowFilter_Interleave {
    return new RowFilter_Interleave().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RowFilter_Interleave {
    return new RowFilter_Interleave().fromJsonString(jsonString, options);
  }

  static equals(a: RowFilter_Interleave | PlainMessage<RowFilter_Interleave> | undefined, b: RowFilter_Interleave | PlainMessage<RowFilter_Interleave> | undefined): boolean {
    return proto3.util.equals(RowFilter_Interleave, a, b);
  }
}

/**
 * A RowFilter which evaluates one of two possible RowFilters, depending on
 * whether or not a predicate RowFilter outputs any cells from the input row.
 *
 * IMPORTANT NOTE: The predicate filter does not execute atomically with the
 * true and false filters, which may lead to inconsistent or unexpected
 * results. Additionally, Condition filters have poor performance, especially
 * when filters are set for the false condition.
 *
 * @generated from message google.bigtable.v1.RowFilter.Condition
 */
export class RowFilter_Condition extends Message<RowFilter_Condition> {
  /**
   * If "predicate_filter" outputs any cells, then "true_filter" will be
   * evaluated on the input row. Otherwise, "false_filter" will be evaluated.
   *
   * @generated from field: google.bigtable.v1.RowFilter predicate_filter = 1;
   */
  predicateFilter?: RowFilter;

  /**
   * The filter to apply to the input row if "predicate_filter" returns any
   * results. If not provided, no results will be returned in the true case.
   *
   * @generated from field: google.bigtable.v1.RowFilter true_filter = 2;
   */
  trueFilter?: RowFilter;

  /**
   * The filter to apply to the input row if "predicate_filter" does not
   * return any results. If not provided, no results will be returned in the
   * false case.
   *
   * @generated from field: google.bigtable.v1.RowFilter false_filter = 3;
   */
  falseFilter?: RowFilter;

  constructor(data?: PartialMessage<RowFilter_Condition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.RowFilter.Condition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "predicate_filter", kind: "message", T: RowFilter },
    { no: 2, name: "true_filter", kind: "message", T: RowFilter },
    { no: 3, name: "false_filter", kind: "message", T: RowFilter },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RowFilter_Condition {
    return new RowFilter_Condition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RowFilter_Condition {
    return new RowFilter_Condition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RowFilter_Condition {
    return new RowFilter_Condition().fromJsonString(jsonString, options);
  }

  static equals(a: RowFilter_Condition | PlainMessage<RowFilter_Condition> | undefined, b: RowFilter_Condition | PlainMessage<RowFilter_Condition> | undefined): boolean {
    return proto3.util.equals(RowFilter_Condition, a, b);
  }
}

/**
 * Specifies a particular change to be made to the contents of a row.
 *
 * @generated from message google.bigtable.v1.Mutation
 */
export class Mutation extends Message<Mutation> {
  /**
   * Which of the possible Mutation types to apply.
   *
   * @generated from oneof google.bigtable.v1.Mutation.mutation
   */
  mutation: {
    /**
     * Set a cell's value.
     *
     * @generated from field: google.bigtable.v1.Mutation.SetCell set_cell = 1;
     */
    value: Mutation_SetCell;
    case: "setCell";
  } | {
    /**
     * Deletes cells from a column.
     *
     * @generated from field: google.bigtable.v1.Mutation.DeleteFromColumn delete_from_column = 2;
     */
    value: Mutation_DeleteFromColumn;
    case: "deleteFromColumn";
  } | {
    /**
     * Deletes cells from a column family.
     *
     * @generated from field: google.bigtable.v1.Mutation.DeleteFromFamily delete_from_family = 3;
     */
    value: Mutation_DeleteFromFamily;
    case: "deleteFromFamily";
  } | {
    /**
     * Deletes cells from the entire row.
     *
     * @generated from field: google.bigtable.v1.Mutation.DeleteFromRow delete_from_row = 4;
     */
    value: Mutation_DeleteFromRow;
    case: "deleteFromRow";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Mutation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.Mutation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "set_cell", kind: "message", T: Mutation_SetCell, oneof: "mutation" },
    { no: 2, name: "delete_from_column", kind: "message", T: Mutation_DeleteFromColumn, oneof: "mutation" },
    { no: 3, name: "delete_from_family", kind: "message", T: Mutation_DeleteFromFamily, oneof: "mutation" },
    { no: 4, name: "delete_from_row", kind: "message", T: Mutation_DeleteFromRow, oneof: "mutation" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Mutation {
    return new Mutation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Mutation {
    return new Mutation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Mutation {
    return new Mutation().fromJsonString(jsonString, options);
  }

  static equals(a: Mutation | PlainMessage<Mutation> | undefined, b: Mutation | PlainMessage<Mutation> | undefined): boolean {
    return proto3.util.equals(Mutation, a, b);
  }
}

/**
 * A Mutation which sets the value of the specified cell.
 *
 * @generated from message google.bigtable.v1.Mutation.SetCell
 */
export class Mutation_SetCell extends Message<Mutation_SetCell> {
  /**
   * The name of the family into which new data should be written.
   * Must match [-_.a-zA-Z0-9]+
   *
   * @generated from field: string family_name = 1;
   */
  familyName = "";

  /**
   * The qualifier of the column into which new data should be written.
   * Can be any byte string, including the empty string.
   *
   * @generated from field: bytes column_qualifier = 2;
   */
  columnQualifier = new Uint8Array(0);

  /**
   * The timestamp of the cell into which new data should be written.
   * Use -1 for current Bigtable server time.
   * Otherwise, the client should set this value itself, noting that the
   * default value is a timestamp of zero if the field is left unspecified.
   * Values must match the "granularity" of the table (e.g. micros, millis).
   *
   * @generated from field: int64 timestamp_micros = 3;
   */
  timestampMicros = protoInt64.zero;

  /**
   * The value to be written into the specified cell.
   *
   * @generated from field: bytes value = 4;
   */
  value = new Uint8Array(0);

  constructor(data?: PartialMessage<Mutation_SetCell>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.Mutation.SetCell";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "family_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "column_qualifier", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "timestamp_micros", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "value", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Mutation_SetCell {
    return new Mutation_SetCell().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Mutation_SetCell {
    return new Mutation_SetCell().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Mutation_SetCell {
    return new Mutation_SetCell().fromJsonString(jsonString, options);
  }

  static equals(a: Mutation_SetCell | PlainMessage<Mutation_SetCell> | undefined, b: Mutation_SetCell | PlainMessage<Mutation_SetCell> | undefined): boolean {
    return proto3.util.equals(Mutation_SetCell, a, b);
  }
}

/**
 * A Mutation which deletes cells from the specified column, optionally
 * restricting the deletions to a given timestamp range.
 *
 * @generated from message google.bigtable.v1.Mutation.DeleteFromColumn
 */
export class Mutation_DeleteFromColumn extends Message<Mutation_DeleteFromColumn> {
  /**
   * The name of the family from which cells should be deleted.
   * Must match [-_.a-zA-Z0-9]+
   *
   * @generated from field: string family_name = 1;
   */
  familyName = "";

  /**
   * The qualifier of the column from which cells should be deleted.
   * Can be any byte string, including the empty string.
   *
   * @generated from field: bytes column_qualifier = 2;
   */
  columnQualifier = new Uint8Array(0);

  /**
   * The range of timestamps within which cells should be deleted.
   *
   * @generated from field: google.bigtable.v1.TimestampRange time_range = 3;
   */
  timeRange?: TimestampRange;

  constructor(data?: PartialMessage<Mutation_DeleteFromColumn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.Mutation.DeleteFromColumn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "family_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "column_qualifier", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "time_range", kind: "message", T: TimestampRange },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Mutation_DeleteFromColumn {
    return new Mutation_DeleteFromColumn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Mutation_DeleteFromColumn {
    return new Mutation_DeleteFromColumn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Mutation_DeleteFromColumn {
    return new Mutation_DeleteFromColumn().fromJsonString(jsonString, options);
  }

  static equals(a: Mutation_DeleteFromColumn | PlainMessage<Mutation_DeleteFromColumn> | undefined, b: Mutation_DeleteFromColumn | PlainMessage<Mutation_DeleteFromColumn> | undefined): boolean {
    return proto3.util.equals(Mutation_DeleteFromColumn, a, b);
  }
}

/**
 * A Mutation which deletes all cells from the specified column family.
 *
 * @generated from message google.bigtable.v1.Mutation.DeleteFromFamily
 */
export class Mutation_DeleteFromFamily extends Message<Mutation_DeleteFromFamily> {
  /**
   * The name of the family from which cells should be deleted.
   * Must match [-_.a-zA-Z0-9]+
   *
   * @generated from field: string family_name = 1;
   */
  familyName = "";

  constructor(data?: PartialMessage<Mutation_DeleteFromFamily>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.Mutation.DeleteFromFamily";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "family_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Mutation_DeleteFromFamily {
    return new Mutation_DeleteFromFamily().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Mutation_DeleteFromFamily {
    return new Mutation_DeleteFromFamily().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Mutation_DeleteFromFamily {
    return new Mutation_DeleteFromFamily().fromJsonString(jsonString, options);
  }

  static equals(a: Mutation_DeleteFromFamily | PlainMessage<Mutation_DeleteFromFamily> | undefined, b: Mutation_DeleteFromFamily | PlainMessage<Mutation_DeleteFromFamily> | undefined): boolean {
    return proto3.util.equals(Mutation_DeleteFromFamily, a, b);
  }
}

/**
 * A Mutation which deletes all cells from the containing row.
 *
 * @generated from message google.bigtable.v1.Mutation.DeleteFromRow
 */
export class Mutation_DeleteFromRow extends Message<Mutation_DeleteFromRow> {
  constructor(data?: PartialMessage<Mutation_DeleteFromRow>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.Mutation.DeleteFromRow";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Mutation_DeleteFromRow {
    return new Mutation_DeleteFromRow().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Mutation_DeleteFromRow {
    return new Mutation_DeleteFromRow().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Mutation_DeleteFromRow {
    return new Mutation_DeleteFromRow().fromJsonString(jsonString, options);
  }

  static equals(a: Mutation_DeleteFromRow | PlainMessage<Mutation_DeleteFromRow> | undefined, b: Mutation_DeleteFromRow | PlainMessage<Mutation_DeleteFromRow> | undefined): boolean {
    return proto3.util.equals(Mutation_DeleteFromRow, a, b);
  }
}

/**
 * Specifies an atomic read/modify/write operation on the latest value of the
 * specified column.
 *
 * @generated from message google.bigtable.v1.ReadModifyWriteRule
 */
export class ReadModifyWriteRule extends Message<ReadModifyWriteRule> {
  /**
   * The name of the family to which the read/modify/write should be applied.
   * Must match [-_.a-zA-Z0-9]+
   *
   * @generated from field: string family_name = 1;
   */
  familyName = "";

  /**
   * The qualifier of the column to which the read/modify/write should be
   * applied.
   * Can be any byte string, including the empty string.
   *
   * @generated from field: bytes column_qualifier = 2;
   */
  columnQualifier = new Uint8Array(0);

  /**
   * The rule used to determine the column's new latest value from its current
   * latest value.
   *
   * @generated from oneof google.bigtable.v1.ReadModifyWriteRule.rule
   */
  rule: {
    /**
     * Rule specifying that "append_value" be appended to the existing value.
     * If the targeted cell is unset, it will be treated as containing the
     * empty string.
     *
     * @generated from field: bytes append_value = 3;
     */
    value: Uint8Array;
    case: "appendValue";
  } | {
    /**
     * Rule specifying that "increment_amount" be added to the existing value.
     * If the targeted cell is unset, it will be treated as containing a zero.
     * Otherwise, the targeted cell must contain an 8-byte value (interpreted
     * as a 64-bit big-endian signed integer), or the entire request will fail.
     *
     * @generated from field: int64 increment_amount = 4;
     */
    value: bigint;
    case: "incrementAmount";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ReadModifyWriteRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.ReadModifyWriteRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "family_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "column_qualifier", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "append_value", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "rule" },
    { no: 4, name: "increment_amount", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "rule" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadModifyWriteRule {
    return new ReadModifyWriteRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadModifyWriteRule {
    return new ReadModifyWriteRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadModifyWriteRule {
    return new ReadModifyWriteRule().fromJsonString(jsonString, options);
  }

  static equals(a: ReadModifyWriteRule | PlainMessage<ReadModifyWriteRule> | undefined, b: ReadModifyWriteRule | PlainMessage<ReadModifyWriteRule> | undefined): boolean {
    return proto3.util.equals(ReadModifyWriteRule, a, b);
  }
}

