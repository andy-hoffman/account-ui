// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/bigtable/v1/bigtable_service_messages.proto (package google.bigtable.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Family, Mutation, ReadModifyWriteRule, RowFilter, RowRange, RowSet } from "./bigtable_data_pb.js";
import { Status } from "../../rpc/status_pb.js";

/**
 * Request message for BigtableServer.ReadRows.
 *
 * @generated from message google.bigtable.v1.ReadRowsRequest
 */
export class ReadRowsRequest extends Message<ReadRowsRequest> {
  /**
   * The unique name of the table from which to read.
   *
   * @generated from field: string table_name = 1;
   */
  tableName = "";

  /**
   * If neither row_key nor row_range is set, reads from all rows.
   *
   * @generated from oneof google.bigtable.v1.ReadRowsRequest.target
   */
  target: {
    /**
     * The key of a single row from which to read.
     *
     * @generated from field: bytes row_key = 2;
     */
    value: Uint8Array;
    case: "rowKey";
  } | {
    /**
     * A range of rows from which to read.
     *
     * @generated from field: google.bigtable.v1.RowRange row_range = 3;
     */
    value: RowRange;
    case: "rowRange";
  } | {
    /**
     * A set of rows from which to read. Entries need not be in order, and will
     * be deduplicated before reading.
     * The total serialized size of the set must not exceed 1MB.
     *
     * @generated from field: google.bigtable.v1.RowSet row_set = 8;
     */
    value: RowSet;
    case: "rowSet";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The filter to apply to the contents of the specified row(s). If unset,
   * reads the entire table.
   *
   * @generated from field: google.bigtable.v1.RowFilter filter = 5;
   */
  filter?: RowFilter;

  /**
   * By default, rows are read sequentially, producing results which are
   * guaranteed to arrive in increasing row order. Setting
   * "allow_row_interleaving" to true allows multiple rows to be interleaved in
   * the response stream, which increases throughput but breaks this guarantee,
   * and may force the client to use more memory to buffer partially-received
   * rows. Cannot be set to true when specifying "num_rows_limit".
   *
   * @generated from field: bool allow_row_interleaving = 6;
   */
  allowRowInterleaving = false;

  /**
   * The read will terminate after committing to N rows' worth of results. The
   * default (zero) is to return all results.
   * Note that "allow_row_interleaving" cannot be set to true when this is set.
   *
   * @generated from field: int64 num_rows_limit = 7;
   */
  numRowsLimit = protoInt64.zero;

  constructor(data?: PartialMessage<ReadRowsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.ReadRowsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "row_key", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "target" },
    { no: 3, name: "row_range", kind: "message", T: RowRange, oneof: "target" },
    { no: 8, name: "row_set", kind: "message", T: RowSet, oneof: "target" },
    { no: 5, name: "filter", kind: "message", T: RowFilter },
    { no: 6, name: "allow_row_interleaving", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "num_rows_limit", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadRowsRequest {
    return new ReadRowsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadRowsRequest {
    return new ReadRowsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadRowsRequest {
    return new ReadRowsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReadRowsRequest | PlainMessage<ReadRowsRequest> | undefined, b: ReadRowsRequest | PlainMessage<ReadRowsRequest> | undefined): boolean {
    return proto3.util.equals(ReadRowsRequest, a, b);
  }
}

/**
 * Response message for BigtableService.ReadRows.
 *
 * @generated from message google.bigtable.v1.ReadRowsResponse
 */
export class ReadRowsResponse extends Message<ReadRowsResponse> {
  /**
   * The key of the row for which we're receiving data.
   * Results will be received in increasing row key order, unless
   * "allow_row_interleaving" was specified in the request.
   *
   * @generated from field: bytes row_key = 1;
   */
  rowKey = new Uint8Array(0);

  /**
   * One or more chunks of the row specified by "row_key".
   *
   * @generated from field: repeated google.bigtable.v1.ReadRowsResponse.Chunk chunks = 2;
   */
  chunks: ReadRowsResponse_Chunk[] = [];

  constructor(data?: PartialMessage<ReadRowsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.ReadRowsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "row_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "chunks", kind: "message", T: ReadRowsResponse_Chunk, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadRowsResponse {
    return new ReadRowsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadRowsResponse {
    return new ReadRowsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadRowsResponse {
    return new ReadRowsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReadRowsResponse | PlainMessage<ReadRowsResponse> | undefined, b: ReadRowsResponse | PlainMessage<ReadRowsResponse> | undefined): boolean {
    return proto3.util.equals(ReadRowsResponse, a, b);
  }
}

/**
 * Specifies a piece of a row's contents returned as part of the read
 * response stream.
 *
 * @generated from message google.bigtable.v1.ReadRowsResponse.Chunk
 */
export class ReadRowsResponse_Chunk extends Message<ReadRowsResponse_Chunk> {
  /**
   * @generated from oneof google.bigtable.v1.ReadRowsResponse.Chunk.chunk
   */
  chunk: {
    /**
     * A subset of the data from a particular row. As long as no "reset_row"
     * is received in between, multiple "row_contents" from the same row are
     * from the same atomic view of that row, and will be received in the
     * expected family/column/timestamp order.
     *
     * @generated from field: google.bigtable.v1.Family row_contents = 1;
     */
    value: Family;
    case: "rowContents";
  } | {
    /**
     * Indicates that the client should drop all previous chunks for
     * "row_key", as it will be re-read from the beginning.
     *
     * @generated from field: bool reset_row = 2;
     */
    value: boolean;
    case: "resetRow";
  } | {
    /**
     * Indicates that the client can safely process all previous chunks for
     * "row_key", as its data has been fully read.
     *
     * @generated from field: bool commit_row = 3;
     */
    value: boolean;
    case: "commitRow";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ReadRowsResponse_Chunk>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.ReadRowsResponse.Chunk";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "row_contents", kind: "message", T: Family, oneof: "chunk" },
    { no: 2, name: "reset_row", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "chunk" },
    { no: 3, name: "commit_row", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "chunk" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadRowsResponse_Chunk {
    return new ReadRowsResponse_Chunk().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadRowsResponse_Chunk {
    return new ReadRowsResponse_Chunk().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadRowsResponse_Chunk {
    return new ReadRowsResponse_Chunk().fromJsonString(jsonString, options);
  }

  static equals(a: ReadRowsResponse_Chunk | PlainMessage<ReadRowsResponse_Chunk> | undefined, b: ReadRowsResponse_Chunk | PlainMessage<ReadRowsResponse_Chunk> | undefined): boolean {
    return proto3.util.equals(ReadRowsResponse_Chunk, a, b);
  }
}

/**
 * Request message for BigtableService.SampleRowKeys.
 *
 * @generated from message google.bigtable.v1.SampleRowKeysRequest
 */
export class SampleRowKeysRequest extends Message<SampleRowKeysRequest> {
  /**
   * The unique name of the table from which to sample row keys.
   *
   * @generated from field: string table_name = 1;
   */
  tableName = "";

  constructor(data?: PartialMessage<SampleRowKeysRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.SampleRowKeysRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SampleRowKeysRequest {
    return new SampleRowKeysRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SampleRowKeysRequest {
    return new SampleRowKeysRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SampleRowKeysRequest {
    return new SampleRowKeysRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SampleRowKeysRequest | PlainMessage<SampleRowKeysRequest> | undefined, b: SampleRowKeysRequest | PlainMessage<SampleRowKeysRequest> | undefined): boolean {
    return proto3.util.equals(SampleRowKeysRequest, a, b);
  }
}

/**
 * Response message for BigtableService.SampleRowKeys.
 *
 * @generated from message google.bigtable.v1.SampleRowKeysResponse
 */
export class SampleRowKeysResponse extends Message<SampleRowKeysResponse> {
  /**
   * Sorted streamed sequence of sample row keys in the table. The table might
   * have contents before the first row key in the list and after the last one,
   * but a key containing the empty string indicates "end of table" and will be
   * the last response given, if present.
   * Note that row keys in this list may not have ever been written to or read
   * from, and users should therefore not make any assumptions about the row key
   * structure that are specific to their use case.
   *
   * @generated from field: bytes row_key = 1;
   */
  rowKey = new Uint8Array(0);

  /**
   * Approximate total storage space used by all rows in the table which precede
   * "row_key". Buffering the contents of all rows between two subsequent
   * samples would require space roughly equal to the difference in their
   * "offset_bytes" fields.
   *
   * @generated from field: int64 offset_bytes = 2;
   */
  offsetBytes = protoInt64.zero;

  constructor(data?: PartialMessage<SampleRowKeysResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.SampleRowKeysResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "row_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "offset_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SampleRowKeysResponse {
    return new SampleRowKeysResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SampleRowKeysResponse {
    return new SampleRowKeysResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SampleRowKeysResponse {
    return new SampleRowKeysResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SampleRowKeysResponse | PlainMessage<SampleRowKeysResponse> | undefined, b: SampleRowKeysResponse | PlainMessage<SampleRowKeysResponse> | undefined): boolean {
    return proto3.util.equals(SampleRowKeysResponse, a, b);
  }
}

/**
 * Request message for BigtableService.MutateRow.
 *
 * @generated from message google.bigtable.v1.MutateRowRequest
 */
export class MutateRowRequest extends Message<MutateRowRequest> {
  /**
   * The unique name of the table to which the mutation should be applied.
   *
   * @generated from field: string table_name = 1;
   */
  tableName = "";

  /**
   * The key of the row to which the mutation should be applied.
   *
   * @generated from field: bytes row_key = 2;
   */
  rowKey = new Uint8Array(0);

  /**
   * Changes to be atomically applied to the specified row. Entries are applied
   * in order, meaning that earlier mutations can be masked by later ones.
   * Must contain at least one entry and at most 100000.
   *
   * @generated from field: repeated google.bigtable.v1.Mutation mutations = 3;
   */
  mutations: Mutation[] = [];

  constructor(data?: PartialMessage<MutateRowRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.MutateRowRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "row_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "mutations", kind: "message", T: Mutation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MutateRowRequest {
    return new MutateRowRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MutateRowRequest {
    return new MutateRowRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MutateRowRequest {
    return new MutateRowRequest().fromJsonString(jsonString, options);
  }

  static equals(a: MutateRowRequest | PlainMessage<MutateRowRequest> | undefined, b: MutateRowRequest | PlainMessage<MutateRowRequest> | undefined): boolean {
    return proto3.util.equals(MutateRowRequest, a, b);
  }
}

/**
 * Request message for BigtableService.MutateRows.
 *
 * @generated from message google.bigtable.v1.MutateRowsRequest
 */
export class MutateRowsRequest extends Message<MutateRowsRequest> {
  /**
   * The unique name of the table to which the mutations should be applied.
   *
   * @generated from field: string table_name = 1;
   */
  tableName = "";

  /**
   * The row keys/mutations to be applied in bulk.
   * Each entry is applied as an atomic mutation, but the entries may be
   * applied in arbitrary order (even between entries for the same row).
   * At least one entry must be specified, and in total the entries may
   * contain at most 100000 mutations.
   *
   * @generated from field: repeated google.bigtable.v1.MutateRowsRequest.Entry entries = 2;
   */
  entries: MutateRowsRequest_Entry[] = [];

  constructor(data?: PartialMessage<MutateRowsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.MutateRowsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "entries", kind: "message", T: MutateRowsRequest_Entry, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MutateRowsRequest {
    return new MutateRowsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MutateRowsRequest {
    return new MutateRowsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MutateRowsRequest {
    return new MutateRowsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: MutateRowsRequest | PlainMessage<MutateRowsRequest> | undefined, b: MutateRowsRequest | PlainMessage<MutateRowsRequest> | undefined): boolean {
    return proto3.util.equals(MutateRowsRequest, a, b);
  }
}

/**
 * @generated from message google.bigtable.v1.MutateRowsRequest.Entry
 */
export class MutateRowsRequest_Entry extends Message<MutateRowsRequest_Entry> {
  /**
   * The key of the row to which the `mutations` should be applied.
   *
   * @generated from field: bytes row_key = 1;
   */
  rowKey = new Uint8Array(0);

  /**
   * Changes to be atomically applied to the specified row. Mutations are
   * applied in order, meaning that earlier mutations can be masked by
   * later ones.
   * At least one mutation must be specified.
   *
   * @generated from field: repeated google.bigtable.v1.Mutation mutations = 2;
   */
  mutations: Mutation[] = [];

  constructor(data?: PartialMessage<MutateRowsRequest_Entry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.MutateRowsRequest.Entry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "row_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "mutations", kind: "message", T: Mutation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MutateRowsRequest_Entry {
    return new MutateRowsRequest_Entry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MutateRowsRequest_Entry {
    return new MutateRowsRequest_Entry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MutateRowsRequest_Entry {
    return new MutateRowsRequest_Entry().fromJsonString(jsonString, options);
  }

  static equals(a: MutateRowsRequest_Entry | PlainMessage<MutateRowsRequest_Entry> | undefined, b: MutateRowsRequest_Entry | PlainMessage<MutateRowsRequest_Entry> | undefined): boolean {
    return proto3.util.equals(MutateRowsRequest_Entry, a, b);
  }
}

/**
 * Response message for BigtableService.MutateRows.
 *
 * @generated from message google.bigtable.v1.MutateRowsResponse
 */
export class MutateRowsResponse extends Message<MutateRowsResponse> {
  /**
   * The results for each Entry from the request, presented in the order
   * in which the entries were originally given.
   * Depending on how requests are batched during execution, it is possible
   * for one Entry to fail due to an error with another Entry. In the event
   * that this occurs, the same error will be reported for both entries.
   *
   * @generated from field: repeated google.rpc.Status statuses = 1;
   */
  statuses: Status[] = [];

  constructor(data?: PartialMessage<MutateRowsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.MutateRowsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "statuses", kind: "message", T: Status, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MutateRowsResponse {
    return new MutateRowsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MutateRowsResponse {
    return new MutateRowsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MutateRowsResponse {
    return new MutateRowsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MutateRowsResponse | PlainMessage<MutateRowsResponse> | undefined, b: MutateRowsResponse | PlainMessage<MutateRowsResponse> | undefined): boolean {
    return proto3.util.equals(MutateRowsResponse, a, b);
  }
}

/**
 * Request message for BigtableService.CheckAndMutateRowRequest
 *
 * @generated from message google.bigtable.v1.CheckAndMutateRowRequest
 */
export class CheckAndMutateRowRequest extends Message<CheckAndMutateRowRequest> {
  /**
   * The unique name of the table to which the conditional mutation should be
   * applied.
   *
   * @generated from field: string table_name = 1;
   */
  tableName = "";

  /**
   * The key of the row to which the conditional mutation should be applied.
   *
   * @generated from field: bytes row_key = 2;
   */
  rowKey = new Uint8Array(0);

  /**
   * The filter to be applied to the contents of the specified row. Depending
   * on whether or not any results are yielded, either "true_mutations" or
   * "false_mutations" will be executed. If unset, checks that the row contains
   * any values at all.
   *
   * @generated from field: google.bigtable.v1.RowFilter predicate_filter = 6;
   */
  predicateFilter?: RowFilter;

  /**
   * Changes to be atomically applied to the specified row if "predicate_filter"
   * yields at least one cell when applied to "row_key". Entries are applied in
   * order, meaning that earlier mutations can be masked by later ones.
   * Must contain at least one entry if "false_mutations" is empty, and at most
   * 100000.
   *
   * @generated from field: repeated google.bigtable.v1.Mutation true_mutations = 4;
   */
  trueMutations: Mutation[] = [];

  /**
   * Changes to be atomically applied to the specified row if "predicate_filter"
   * does not yield any cells when applied to "row_key". Entries are applied in
   * order, meaning that earlier mutations can be masked by later ones.
   * Must contain at least one entry if "true_mutations" is empty, and at most
   * 100000.
   *
   * @generated from field: repeated google.bigtable.v1.Mutation false_mutations = 5;
   */
  falseMutations: Mutation[] = [];

  constructor(data?: PartialMessage<CheckAndMutateRowRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.CheckAndMutateRowRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "row_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "predicate_filter", kind: "message", T: RowFilter },
    { no: 4, name: "true_mutations", kind: "message", T: Mutation, repeated: true },
    { no: 5, name: "false_mutations", kind: "message", T: Mutation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckAndMutateRowRequest {
    return new CheckAndMutateRowRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckAndMutateRowRequest {
    return new CheckAndMutateRowRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckAndMutateRowRequest {
    return new CheckAndMutateRowRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CheckAndMutateRowRequest | PlainMessage<CheckAndMutateRowRequest> | undefined, b: CheckAndMutateRowRequest | PlainMessage<CheckAndMutateRowRequest> | undefined): boolean {
    return proto3.util.equals(CheckAndMutateRowRequest, a, b);
  }
}

/**
 * Response message for BigtableService.CheckAndMutateRowRequest.
 *
 * @generated from message google.bigtable.v1.CheckAndMutateRowResponse
 */
export class CheckAndMutateRowResponse extends Message<CheckAndMutateRowResponse> {
  /**
   * Whether or not the request's "predicate_filter" yielded any results for
   * the specified row.
   *
   * @generated from field: bool predicate_matched = 1;
   */
  predicateMatched = false;

  constructor(data?: PartialMessage<CheckAndMutateRowResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.CheckAndMutateRowResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "predicate_matched", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CheckAndMutateRowResponse {
    return new CheckAndMutateRowResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CheckAndMutateRowResponse {
    return new CheckAndMutateRowResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CheckAndMutateRowResponse {
    return new CheckAndMutateRowResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CheckAndMutateRowResponse | PlainMessage<CheckAndMutateRowResponse> | undefined, b: CheckAndMutateRowResponse | PlainMessage<CheckAndMutateRowResponse> | undefined): boolean {
    return proto3.util.equals(CheckAndMutateRowResponse, a, b);
  }
}

/**
 * Request message for BigtableService.ReadModifyWriteRowRequest.
 *
 * @generated from message google.bigtable.v1.ReadModifyWriteRowRequest
 */
export class ReadModifyWriteRowRequest extends Message<ReadModifyWriteRowRequest> {
  /**
   * The unique name of the table to which the read/modify/write rules should be
   * applied.
   *
   * @generated from field: string table_name = 1;
   */
  tableName = "";

  /**
   * The key of the row to which the read/modify/write rules should be applied.
   *
   * @generated from field: bytes row_key = 2;
   */
  rowKey = new Uint8Array(0);

  /**
   * Rules specifying how the specified row's contents are to be transformed
   * into writes. Entries are applied in order, meaning that earlier rules will
   * affect the results of later ones.
   *
   * @generated from field: repeated google.bigtable.v1.ReadModifyWriteRule rules = 3;
   */
  rules: ReadModifyWriteRule[] = [];

  constructor(data?: PartialMessage<ReadModifyWriteRowRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.bigtable.v1.ReadModifyWriteRowRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "row_key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "rules", kind: "message", T: ReadModifyWriteRule, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadModifyWriteRowRequest {
    return new ReadModifyWriteRowRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadModifyWriteRowRequest {
    return new ReadModifyWriteRowRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadModifyWriteRowRequest {
    return new ReadModifyWriteRowRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReadModifyWriteRowRequest | PlainMessage<ReadModifyWriteRowRequest> | undefined, b: ReadModifyWriteRowRequest | PlainMessage<ReadModifyWriteRowRequest> | undefined): boolean {
    return proto3.util.equals(ReadModifyWriteRowRequest, a, b);
  }
}

