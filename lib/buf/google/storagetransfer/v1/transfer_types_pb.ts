// Copyright 2016 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/storagetransfer/v1/transfer_types.proto (package google.storagetransfer.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { Date } from "../../type/date_pb.js";
import { TimeOfDay } from "../../type/timeofday_pb.js";
import { Code } from "../../rpc/code_pb.js";

/**
 * Google service account
 *
 * @generated from message google.storagetransfer.v1.GoogleServiceAccount
 */
export class GoogleServiceAccount extends Message<GoogleServiceAccount> {
  /**
   * Required.
   *
   * @generated from field: string account_email = 1;
   */
  accountEmail = "";

  constructor(data?: PartialMessage<GoogleServiceAccount>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.storagetransfer.v1.GoogleServiceAccount";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "account_email", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GoogleServiceAccount {
    return new GoogleServiceAccount().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GoogleServiceAccount {
    return new GoogleServiceAccount().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GoogleServiceAccount {
    return new GoogleServiceAccount().fromJsonString(jsonString, options);
  }

  static equals(a: GoogleServiceAccount | PlainMessage<GoogleServiceAccount> | undefined, b: GoogleServiceAccount | PlainMessage<GoogleServiceAccount> | undefined): boolean {
    return proto3.util.equals(GoogleServiceAccount, a, b);
  }
}

/**
 * AWS access key (see
 * [AWS Security Credentials](http://docs.aws.amazon.com/general/latest/gr/aws-security-credentials.html)).
 *
 * @generated from message google.storagetransfer.v1.AwsAccessKey
 */
export class AwsAccessKey extends Message<AwsAccessKey> {
  /**
   * AWS access key ID.
   * Required.
   *
   * @generated from field: string access_key_id = 1;
   */
  accessKeyId = "";

  /**
   * AWS secret access key. This field is not returned in RPC responses.
   * Required.
   *
   * @generated from field: string secret_access_key = 2;
   */
  secretAccessKey = "";

  constructor(data?: PartialMessage<AwsAccessKey>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.storagetransfer.v1.AwsAccessKey";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "access_key_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "secret_access_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AwsAccessKey {
    return new AwsAccessKey().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AwsAccessKey {
    return new AwsAccessKey().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AwsAccessKey {
    return new AwsAccessKey().fromJsonString(jsonString, options);
  }

  static equals(a: AwsAccessKey | PlainMessage<AwsAccessKey> | undefined, b: AwsAccessKey | PlainMessage<AwsAccessKey> | undefined): boolean {
    return proto3.util.equals(AwsAccessKey, a, b);
  }
}

/**
 * Conditions that determine which objects will be transferred.
 *
 * @generated from message google.storagetransfer.v1.ObjectConditions
 */
export class ObjectConditions extends Message<ObjectConditions> {
  /**
   * If unspecified, `minTimeElapsedSinceLastModification` takes a zero value
   * and `maxTimeElapsedSinceLastModification` takes the maximum possible
   * value of Duration. Objects that satisfy the object conditions
   * must either have a `lastModificationTime` greater or equal to
   * `NOW` - `maxTimeElapsedSinceLastModification` and less than
   * `NOW` - `minTimeElapsedSinceLastModification`, or not have a
   * `lastModificationTime`.
   *
   * @generated from field: google.protobuf.Duration min_time_elapsed_since_last_modification = 1;
   */
  minTimeElapsedSinceLastModification?: Duration;

  /**
   * `maxTimeElapsedSinceLastModification` is the complement to
   * `minTimeElapsedSinceLastModification`.
   *
   * @generated from field: google.protobuf.Duration max_time_elapsed_since_last_modification = 2;
   */
  maxTimeElapsedSinceLastModification?: Duration;

  /**
   * If `includePrefixes` is specified, objects that satisfy the object
   * conditions must have names that start with one of the `includePrefixes`
   * and that do not start with any of the `excludePrefixes`. If `includePrefixes`
   * is not specified, all objects except those that have names starting with
   * one of the `excludePrefixes` must satisfy the object conditions.
   *
   * Requirements:
   *
   *   * Each include-prefix and exclude-prefix can contain any sequence of
   *     Unicode characters, of max length 1024 bytes when UTF8-encoded, and
   *     must not contain Carriage Return or Line Feed characters.  Wildcard
   *     matching and regular expression matching are not supported.
   *
   *   * Each include-prefix and exclude-prefix must omit the leading slash.
   *     For example, to include the `requests.gz` object in a transfer from
   *     `s3://my-aws-bucket/logs/y=2015/requests.gz`, specify the include
   *     prefix as `logs/y=2015/requests.gz`.
   *
   *   * None of the include-prefix or the exclude-prefix values can be empty,
   *     if specified.
   *
   *   * Each include-prefix must include a distinct portion of the object
   *     namespace, i.e., no include-prefix may be a prefix of another
   *     include-prefix.
   *
   *   * Each exclude-prefix must exclude a distinct portion of the object
   *     namespace, i.e., no exclude-prefix may be a prefix of another
   *     exclude-prefix.
   *
   *   * If `includePrefixes` is specified, then each exclude-prefix must start
   *     with the value of a path explicitly included by `includePrefixes`.
   *
   * The max size of `includePrefixes` is 20.
   *
   * @generated from field: repeated string include_prefixes = 3;
   */
  includePrefixes: string[] = [];

  /**
   * `excludePrefixes` must follow the requirements described for
   * `includePrefixes`.
   *
   * The max size of `excludePrefixes` is 20.
   *
   * @generated from field: repeated string exclude_prefixes = 4;
   */
  excludePrefixes: string[] = [];

  constructor(data?: PartialMessage<ObjectConditions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.storagetransfer.v1.ObjectConditions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "min_time_elapsed_since_last_modification", kind: "message", T: Duration },
    { no: 2, name: "max_time_elapsed_since_last_modification", kind: "message", T: Duration },
    { no: 3, name: "include_prefixes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "exclude_prefixes", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ObjectConditions {
    return new ObjectConditions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ObjectConditions {
    return new ObjectConditions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ObjectConditions {
    return new ObjectConditions().fromJsonString(jsonString, options);
  }

  static equals(a: ObjectConditions | PlainMessage<ObjectConditions> | undefined, b: ObjectConditions | PlainMessage<ObjectConditions> | undefined): boolean {
    return proto3.util.equals(ObjectConditions, a, b);
  }
}

/**
 * In a GcsData, an object's name is the Google Cloud Storage object's name and
 * its `lastModificationTime` refers to the object's updated time, which changes
 * when the content or the metadata of the object is updated.
 *
 * @generated from message google.storagetransfer.v1.GcsData
 */
export class GcsData extends Message<GcsData> {
  /**
   * Google Cloud Storage bucket name (see
   * [Bucket Name Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
   * Required.
   *
   * @generated from field: string bucket_name = 1;
   */
  bucketName = "";

  constructor(data?: PartialMessage<GcsData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.storagetransfer.v1.GcsData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bucket_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GcsData {
    return new GcsData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GcsData {
    return new GcsData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GcsData {
    return new GcsData().fromJsonString(jsonString, options);
  }

  static equals(a: GcsData | PlainMessage<GcsData> | undefined, b: GcsData | PlainMessage<GcsData> | undefined): boolean {
    return proto3.util.equals(GcsData, a, b);
  }
}

/**
 * An AwsS3Data can be a data source, but not a data sink.
 * In an AwsS3Data, an object's name is the S3 object's key name.
 *
 * @generated from message google.storagetransfer.v1.AwsS3Data
 */
export class AwsS3Data extends Message<AwsS3Data> {
  /**
   * S3 Bucket name (see
   * [Creating a bucket](http://docs.aws.amazon.com/AmazonS3/latest/dev/create-bucket-get-location-example.html)).
   * Required.
   *
   * @generated from field: string bucket_name = 1;
   */
  bucketName = "";

  /**
   * AWS access key used to sign the API requests to the AWS S3 bucket.
   * Permissions on the bucket must be granted to the access ID of the
   * AWS access key.
   * Required.
   *
   * @generated from field: google.storagetransfer.v1.AwsAccessKey aws_access_key = 2;
   */
  awsAccessKey?: AwsAccessKey;

  constructor(data?: PartialMessage<AwsS3Data>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.storagetransfer.v1.AwsS3Data";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bucket_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "aws_access_key", kind: "message", T: AwsAccessKey },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AwsS3Data {
    return new AwsS3Data().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AwsS3Data {
    return new AwsS3Data().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AwsS3Data {
    return new AwsS3Data().fromJsonString(jsonString, options);
  }

  static equals(a: AwsS3Data | PlainMessage<AwsS3Data> | undefined, b: AwsS3Data | PlainMessage<AwsS3Data> | undefined): boolean {
    return proto3.util.equals(AwsS3Data, a, b);
  }
}

/**
 * An HttpData specifies a list of objects on the web to be transferred over
 * HTTP.  The information of the objects to be transferred is contained in a
 * file referenced by a URL. The first line in the file must be
 * "TsvHttpData-1.0", which specifies the format of the file.  Subsequent lines
 * specify the information of the list of objects, one object per list entry.
 * Each entry has the following tab-delimited fields:
 *
 * * HTTP URL - The location of the object.
 *
 * * Length - The size of the object in bytes.
 *
 * * MD5 - The base64-encoded MD5 hash of the object.
 *
 * For an example of a valid TSV file, see
 * [Transferring data from URLs](https://cloud.google.com/storage/transfer/#urls)
 *
 * When transferring data based on a URL list, keep the following in mind:
 *
 * * When an object located at `http(s)://hostname:port/<URL-path>` is transferred
 * to a data sink, the name of the object at the data sink is
 * `<hostname>/<URL-path>`.
 *
 * * If the specified size of an object does not match the actual size of the
 * object fetched, the object will not be transferred.
 *
 * * If the specified MD5 does not match the MD5 computed from the transferred
 * bytes, the object transfer will fail. For more information, see
 * [Generating MD5 hashes](https://cloud.google.com/storage/transfer/#md5)
 *
 * * Ensure that each URL you specify is publicly accessible. For
 * example, in Google Cloud Storage you can
 * [share an object publicly]
 * (https://cloud.google.com/storage/docs/cloud-console#_sharingdata) and get
 * a link to it.
 *
 * * Storage Transfer Service obeys `robots.txt` rules and requires the source
 * HTTP server to support `Range` requests and to return a `Content-Length`
 * header in each response.
 *
 * * [ObjectConditions](#ObjectConditions) have no effect when filtering objects
 * to transfer.
 *
 * @generated from message google.storagetransfer.v1.HttpData
 */
export class HttpData extends Message<HttpData> {
  /**
   * The URL that points to the file that stores the object list entries.
   * This file must allow public access.  Currently, only URLs with HTTP and
   * HTTPS schemes are supported.
   * Required.
   *
   * @generated from field: string list_url = 1;
   */
  listUrl = "";

  constructor(data?: PartialMessage<HttpData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.storagetransfer.v1.HttpData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "list_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HttpData {
    return new HttpData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HttpData {
    return new HttpData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HttpData {
    return new HttpData().fromJsonString(jsonString, options);
  }

  static equals(a: HttpData | PlainMessage<HttpData> | undefined, b: HttpData | PlainMessage<HttpData> | undefined): boolean {
    return proto3.util.equals(HttpData, a, b);
  }
}

/**
 * TransferOptions uses three boolean parameters to define the actions
 * to be performed on objects in a transfer.
 *
 * @generated from message google.storagetransfer.v1.TransferOptions
 */
export class TransferOptions extends Message<TransferOptions> {
  /**
   * Whether overwriting objects that already exist in the sink is allowed.
   *
   * @generated from field: bool overwrite_objects_already_existing_in_sink = 1;
   */
  overwriteObjectsAlreadyExistingInSink = false;

  /**
   * Whether objects that exist only in the sink should be deleted.
   *
   * @generated from field: bool delete_objects_unique_in_sink = 2;
   */
  deleteObjectsUniqueInSink = false;

  /**
   * Whether objects should be deleted from the source after they are
   * transferred to the sink.
   *
   * @generated from field: bool delete_objects_from_source_after_transfer = 3;
   */
  deleteObjectsFromSourceAfterTransfer = false;

  constructor(data?: PartialMessage<TransferOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.storagetransfer.v1.TransferOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "overwrite_objects_already_existing_in_sink", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "delete_objects_unique_in_sink", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "delete_objects_from_source_after_transfer", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransferOptions {
    return new TransferOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransferOptions {
    return new TransferOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransferOptions {
    return new TransferOptions().fromJsonString(jsonString, options);
  }

  static equals(a: TransferOptions | PlainMessage<TransferOptions> | undefined, b: TransferOptions | PlainMessage<TransferOptions> | undefined): boolean {
    return proto3.util.equals(TransferOptions, a, b);
  }
}

/**
 * Configuration for running a transfer.
 *
 * @generated from message google.storagetransfer.v1.TransferSpec
 */
export class TransferSpec extends Message<TransferSpec> {
  /**
   * The read source of the data.
   *
   * @generated from oneof google.storagetransfer.v1.TransferSpec.data_source
   */
  dataSource: {
    /**
     * A Google Cloud Storage data source.
     *
     * @generated from field: google.storagetransfer.v1.GcsData gcs_data_source = 1;
     */
    value: GcsData;
    case: "gcsDataSource";
  } | {
    /**
     * An AWS S3 data source.
     *
     * @generated from field: google.storagetransfer.v1.AwsS3Data aws_s3_data_source = 2;
     */
    value: AwsS3Data;
    case: "awsS3DataSource";
  } | {
    /**
     * An HTTP URL data source.
     *
     * @generated from field: google.storagetransfer.v1.HttpData http_data_source = 3;
     */
    value: HttpData;
    case: "httpDataSource";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The write sink for the data.
   *
   * @generated from oneof google.storagetransfer.v1.TransferSpec.data_sink
   */
  dataSink: {
    /**
     * A Google Cloud Storage data sink.
     *
     * @generated from field: google.storagetransfer.v1.GcsData gcs_data_sink = 4;
     */
    value: GcsData;
    case: "gcsDataSink";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Only objects that satisfy these object conditions are included in the set
   * of data source and data sink objects.  Object conditions based on
   * objects' `lastModificationTime` do not exclude objects in a data sink.
   *
   * @generated from field: google.storagetransfer.v1.ObjectConditions object_conditions = 5;
   */
  objectConditions?: ObjectConditions;

  /**
   * If the option `deleteObjectsUniqueInSink` is `true`, object conditions
   * based on objects' `lastModificationTime` are ignored and do not exclude
   * objects in a data source or a data sink.
   *
   * @generated from field: google.storagetransfer.v1.TransferOptions transfer_options = 6;
   */
  transferOptions?: TransferOptions;

  constructor(data?: PartialMessage<TransferSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.storagetransfer.v1.TransferSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "gcs_data_source", kind: "message", T: GcsData, oneof: "data_source" },
    { no: 2, name: "aws_s3_data_source", kind: "message", T: AwsS3Data, oneof: "data_source" },
    { no: 3, name: "http_data_source", kind: "message", T: HttpData, oneof: "data_source" },
    { no: 4, name: "gcs_data_sink", kind: "message", T: GcsData, oneof: "data_sink" },
    { no: 5, name: "object_conditions", kind: "message", T: ObjectConditions },
    { no: 6, name: "transfer_options", kind: "message", T: TransferOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransferSpec {
    return new TransferSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransferSpec {
    return new TransferSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransferSpec {
    return new TransferSpec().fromJsonString(jsonString, options);
  }

  static equals(a: TransferSpec | PlainMessage<TransferSpec> | undefined, b: TransferSpec | PlainMessage<TransferSpec> | undefined): boolean {
    return proto3.util.equals(TransferSpec, a, b);
  }
}

/**
 * Transfers can be scheduled to recur or to run just once.
 *
 * @generated from message google.storagetransfer.v1.Schedule
 */
export class Schedule extends Message<Schedule> {
  /**
   * The first day the recurring transfer is scheduled to run. If
   * `scheduleStartDate` is in the past, the transfer will run for the first
   * time on the following day.
   * Required.
   *
   * @generated from field: google.type.Date schedule_start_date = 1;
   */
  scheduleStartDate?: Date;

  /**
   * The last day the recurring transfer will be run. If `scheduleEndDate`
   * is the same as `scheduleStartDate`, the transfer will be executed only
   * once.
   *
   * @generated from field: google.type.Date schedule_end_date = 2;
   */
  scheduleEndDate?: Date;

  /**
   * The time in UTC at which the transfer will be scheduled to start in a day.
   * Transfers may start later than this time. If not specified, recurring and
   * one-time transfers that are scheduled to run today will run immediately;
   * recurring transfers that are scheduled to run on a future date will start
   * at approximately midnight UTC on that date. Note that when configuring a
   * transfer with the Cloud Platform Console, the transfer's start time in a
   * day is specified in your local timezone.
   *
   * @generated from field: google.type.TimeOfDay start_time_of_day = 3;
   */
  startTimeOfDay?: TimeOfDay;

  constructor(data?: PartialMessage<Schedule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.storagetransfer.v1.Schedule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "schedule_start_date", kind: "message", T: Date },
    { no: 2, name: "schedule_end_date", kind: "message", T: Date },
    { no: 3, name: "start_time_of_day", kind: "message", T: TimeOfDay },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Schedule {
    return new Schedule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Schedule {
    return new Schedule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Schedule {
    return new Schedule().fromJsonString(jsonString, options);
  }

  static equals(a: Schedule | PlainMessage<Schedule> | undefined, b: Schedule | PlainMessage<Schedule> | undefined): boolean {
    return proto3.util.equals(Schedule, a, b);
  }
}

/**
 * This resource represents the configuration of a transfer job that runs
 * periodically.
 *
 * @generated from message google.storagetransfer.v1.TransferJob
 */
export class TransferJob extends Message<TransferJob> {
  /**
   * A globally unique name assigned by Storage Transfer Service when the
   * job is created. This field should be left empty in requests to create a new
   * transfer job; otherwise, the requests result in an `INVALID_ARGUMENT`
   * error.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * A description provided by the user for the job. Its max length is 1024
   * bytes when Unicode-encoded.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * The ID of the Google Cloud Platform Console project that owns the job.
   * Required.
   *
   * @generated from field: string project_id = 3;
   */
  projectId = "";

  /**
   * Transfer specification.
   * Required.
   *
   * @generated from field: google.storagetransfer.v1.TransferSpec transfer_spec = 4;
   */
  transferSpec?: TransferSpec;

  /**
   * Schedule specification.
   * Required.
   *
   * @generated from field: google.storagetransfer.v1.Schedule schedule = 5;
   */
  schedule?: Schedule;

  /**
   * Status of the job. This value MUST be specified for
   * `CreateTransferJobRequests`.
   *
   * NOTE: The effect of the new job status takes place during a subsequent job
   * run. For example, if you change the job status from `ENABLED` to
   * `DISABLED`, and an operation spawned by the transfer is running, the status
   * change would not affect the current operation.
   *
   * @generated from field: google.storagetransfer.v1.TransferJob.Status status = 6;
   */
  status = TransferJob_Status.STATUS_UNSPECIFIED;

  /**
   * This field cannot be changed by user requests.
   *
   * @generated from field: google.protobuf.Timestamp creation_time = 7;
   */
  creationTime?: Timestamp;

  /**
   * This field cannot be changed by user requests.
   *
   * @generated from field: google.protobuf.Timestamp last_modification_time = 8;
   */
  lastModificationTime?: Timestamp;

  /**
   * This field cannot be changed by user requests.
   *
   * @generated from field: google.protobuf.Timestamp deletion_time = 9;
   */
  deletionTime?: Timestamp;

  constructor(data?: PartialMessage<TransferJob>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.storagetransfer.v1.TransferJob";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "transfer_spec", kind: "message", T: TransferSpec },
    { no: 5, name: "schedule", kind: "message", T: Schedule },
    { no: 6, name: "status", kind: "enum", T: proto3.getEnumType(TransferJob_Status) },
    { no: 7, name: "creation_time", kind: "message", T: Timestamp },
    { no: 8, name: "last_modification_time", kind: "message", T: Timestamp },
    { no: 9, name: "deletion_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransferJob {
    return new TransferJob().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransferJob {
    return new TransferJob().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransferJob {
    return new TransferJob().fromJsonString(jsonString, options);
  }

  static equals(a: TransferJob | PlainMessage<TransferJob> | undefined, b: TransferJob | PlainMessage<TransferJob> | undefined): boolean {
    return proto3.util.equals(TransferJob, a, b);
  }
}

/**
 * The status of the transfer job.
 *
 * @generated from enum google.storagetransfer.v1.TransferJob.Status
 */
export enum TransferJob_Status {
  /**
   * Zero is an illegal value.
   *
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  STATUS_UNSPECIFIED = 0,

  /**
   * New transfers will be performed based on the schedule.
   *
   * @generated from enum value: ENABLED = 1;
   */
  ENABLED = 1,

  /**
   * New transfers will not be scheduled.
   *
   * @generated from enum value: DISABLED = 2;
   */
  DISABLED = 2,

  /**
   * This is a soft delete state. After a transfer job is set to this
   * state, the job and all the transfer executions are subject to
   * garbage collection.
   *
   * @generated from enum value: DELETED = 3;
   */
  DELETED = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(TransferJob_Status)
proto3.util.setEnumType(TransferJob_Status, "google.storagetransfer.v1.TransferJob.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "ENABLED" },
  { no: 2, name: "DISABLED" },
  { no: 3, name: "DELETED" },
]);

/**
 * An entry describing an error that has occurred.
 *
 * @generated from message google.storagetransfer.v1.ErrorLogEntry
 */
export class ErrorLogEntry extends Message<ErrorLogEntry> {
  /**
   * A URL that refers to the target (a data source, a data sink,
   * or an object) with which the error is associated.
   * Required.
   *
   * @generated from field: string url = 1;
   */
  url = "";

  /**
   * A list of messages that carry the error details.
   *
   * @generated from field: repeated string error_details = 3;
   */
  errorDetails: string[] = [];

  constructor(data?: PartialMessage<ErrorLogEntry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.storagetransfer.v1.ErrorLogEntry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "error_details", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ErrorLogEntry {
    return new ErrorLogEntry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ErrorLogEntry {
    return new ErrorLogEntry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ErrorLogEntry {
    return new ErrorLogEntry().fromJsonString(jsonString, options);
  }

  static equals(a: ErrorLogEntry | PlainMessage<ErrorLogEntry> | undefined, b: ErrorLogEntry | PlainMessage<ErrorLogEntry> | undefined): boolean {
    return proto3.util.equals(ErrorLogEntry, a, b);
  }
}

/**
 * A summary of errors by error code, plus a count and sample error log
 * entries.
 *
 * @generated from message google.storagetransfer.v1.ErrorSummary
 */
export class ErrorSummary extends Message<ErrorSummary> {
  /**
   * Required.
   *
   * @generated from field: google.rpc.Code error_code = 1;
   */
  errorCode = Code.OK;

  /**
   * Count of this type of error.
   * Required.
   *
   * @generated from field: int64 error_count = 2;
   */
  errorCount = protoInt64.zero;

  /**
   * Error samples.
   *
   * @generated from field: repeated google.storagetransfer.v1.ErrorLogEntry error_log_entries = 3;
   */
  errorLogEntries: ErrorLogEntry[] = [];

  constructor(data?: PartialMessage<ErrorSummary>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.storagetransfer.v1.ErrorSummary";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "error_code", kind: "enum", T: proto3.getEnumType(Code) },
    { no: 2, name: "error_count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "error_log_entries", kind: "message", T: ErrorLogEntry, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ErrorSummary {
    return new ErrorSummary().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ErrorSummary {
    return new ErrorSummary().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ErrorSummary {
    return new ErrorSummary().fromJsonString(jsonString, options);
  }

  static equals(a: ErrorSummary | PlainMessage<ErrorSummary> | undefined, b: ErrorSummary | PlainMessage<ErrorSummary> | undefined): boolean {
    return proto3.util.equals(ErrorSummary, a, b);
  }
}

/**
 * A collection of counters that report the progress of a transfer operation.
 *
 * @generated from message google.storagetransfer.v1.TransferCounters
 */
export class TransferCounters extends Message<TransferCounters> {
  /**
   * Objects found in the data source that are scheduled to be transferred,
   * which will be copied, excluded based on conditions, or skipped due to
   * failures.
   *
   * @generated from field: int64 objects_found_from_source = 1;
   */
  objectsFoundFromSource = protoInt64.zero;

  /**
   * Bytes found in the data source that are scheduled to be transferred,
   * which will be copied, excluded based on conditions, or skipped due to
   * failures.
   *
   * @generated from field: int64 bytes_found_from_source = 2;
   */
  bytesFoundFromSource = protoInt64.zero;

  /**
   * Objects found only in the data sink that are scheduled to be deleted.
   *
   * @generated from field: int64 objects_found_only_from_sink = 3;
   */
  objectsFoundOnlyFromSink = protoInt64.zero;

  /**
   * Bytes found only in the data sink that are scheduled to be deleted.
   *
   * @generated from field: int64 bytes_found_only_from_sink = 4;
   */
  bytesFoundOnlyFromSink = protoInt64.zero;

  /**
   * Objects in the data source that are not transferred because they already
   * exist in the data sink.
   *
   * @generated from field: int64 objects_from_source_skipped_by_sync = 5;
   */
  objectsFromSourceSkippedBySync = protoInt64.zero;

  /**
   * Bytes in the data source that are not transferred because they already
   * exist in the data sink.
   *
   * @generated from field: int64 bytes_from_source_skipped_by_sync = 6;
   */
  bytesFromSourceSkippedBySync = protoInt64.zero;

  /**
   * Objects that are copied to the data sink.
   *
   * @generated from field: int64 objects_copied_to_sink = 7;
   */
  objectsCopiedToSink = protoInt64.zero;

  /**
   * Bytes that are copied to the data sink.
   *
   * @generated from field: int64 bytes_copied_to_sink = 8;
   */
  bytesCopiedToSink = protoInt64.zero;

  /**
   * Objects that are deleted from the data source.
   *
   * @generated from field: int64 objects_deleted_from_source = 9;
   */
  objectsDeletedFromSource = protoInt64.zero;

  /**
   * Bytes that are deleted from the data source.
   *
   * @generated from field: int64 bytes_deleted_from_source = 10;
   */
  bytesDeletedFromSource = protoInt64.zero;

  /**
   * Objects that are deleted from the data sink.
   *
   * @generated from field: int64 objects_deleted_from_sink = 11;
   */
  objectsDeletedFromSink = protoInt64.zero;

  /**
   * Bytes that are deleted from the data sink.
   *
   * @generated from field: int64 bytes_deleted_from_sink = 12;
   */
  bytesDeletedFromSink = protoInt64.zero;

  /**
   * Objects in the data source that failed during the transfer.
   *
   * @generated from field: int64 objects_from_source_failed = 13;
   */
  objectsFromSourceFailed = protoInt64.zero;

  /**
   * Bytes in the data source that failed during the transfer.
   *
   * @generated from field: int64 bytes_from_source_failed = 14;
   */
  bytesFromSourceFailed = protoInt64.zero;

  /**
   * Objects that failed to be deleted from the data sink.
   *
   * @generated from field: int64 objects_failed_to_delete_from_sink = 15;
   */
  objectsFailedToDeleteFromSink = protoInt64.zero;

  /**
   * Bytes that failed to be deleted from the data sink.
   *
   * @generated from field: int64 bytes_failed_to_delete_from_sink = 16;
   */
  bytesFailedToDeleteFromSink = protoInt64.zero;

  constructor(data?: PartialMessage<TransferCounters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.storagetransfer.v1.TransferCounters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "objects_found_from_source", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "bytes_found_from_source", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "objects_found_only_from_sink", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "bytes_found_only_from_sink", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "objects_from_source_skipped_by_sync", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "bytes_from_source_skipped_by_sync", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "objects_copied_to_sink", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 8, name: "bytes_copied_to_sink", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 9, name: "objects_deleted_from_source", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 10, name: "bytes_deleted_from_source", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 11, name: "objects_deleted_from_sink", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 12, name: "bytes_deleted_from_sink", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 13, name: "objects_from_source_failed", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 14, name: "bytes_from_source_failed", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 15, name: "objects_failed_to_delete_from_sink", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 16, name: "bytes_failed_to_delete_from_sink", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransferCounters {
    return new TransferCounters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransferCounters {
    return new TransferCounters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransferCounters {
    return new TransferCounters().fromJsonString(jsonString, options);
  }

  static equals(a: TransferCounters | PlainMessage<TransferCounters> | undefined, b: TransferCounters | PlainMessage<TransferCounters> | undefined): boolean {
    return proto3.util.equals(TransferCounters, a, b);
  }
}

/**
 * A description of the execution of a transfer.
 *
 * @generated from message google.storagetransfer.v1.TransferOperation
 */
export class TransferOperation extends Message<TransferOperation> {
  /**
   * A globally unique ID assigned by the system.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The ID of the Google Cloud Platform Console project that owns the operation.
   * Required.
   *
   * @generated from field: string project_id = 2;
   */
  projectId = "";

  /**
   * Transfer specification.
   * Required.
   *
   * @generated from field: google.storagetransfer.v1.TransferSpec transfer_spec = 3;
   */
  transferSpec?: TransferSpec;

  /**
   * Start time of this transfer execution.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 4;
   */
  startTime?: Timestamp;

  /**
   * End time of this transfer execution.
   *
   * @generated from field: google.protobuf.Timestamp end_time = 5;
   */
  endTime?: Timestamp;

  /**
   * Status of the transfer operation.
   *
   * @generated from field: google.storagetransfer.v1.TransferOperation.Status status = 6;
   */
  status = TransferOperation_Status.STATUS_UNSPECIFIED;

  /**
   * Information about the progress of the transfer operation.
   *
   * @generated from field: google.storagetransfer.v1.TransferCounters counters = 7;
   */
  counters?: TransferCounters;

  /**
   * Summarizes errors encountered with sample error log entries.
   *
   * @generated from field: repeated google.storagetransfer.v1.ErrorSummary error_breakdowns = 8;
   */
  errorBreakdowns: ErrorSummary[] = [];

  /**
   * The name of the transfer job that triggers this transfer operation.
   *
   * @generated from field: string transfer_job_name = 9;
   */
  transferJobName = "";

  constructor(data?: PartialMessage<TransferOperation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.storagetransfer.v1.TransferOperation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "transfer_spec", kind: "message", T: TransferSpec },
    { no: 4, name: "start_time", kind: "message", T: Timestamp },
    { no: 5, name: "end_time", kind: "message", T: Timestamp },
    { no: 6, name: "status", kind: "enum", T: proto3.getEnumType(TransferOperation_Status) },
    { no: 7, name: "counters", kind: "message", T: TransferCounters },
    { no: 8, name: "error_breakdowns", kind: "message", T: ErrorSummary, repeated: true },
    { no: 9, name: "transfer_job_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransferOperation {
    return new TransferOperation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransferOperation {
    return new TransferOperation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransferOperation {
    return new TransferOperation().fromJsonString(jsonString, options);
  }

  static equals(a: TransferOperation | PlainMessage<TransferOperation> | undefined, b: TransferOperation | PlainMessage<TransferOperation> | undefined): boolean {
    return proto3.util.equals(TransferOperation, a, b);
  }
}

/**
 * The status of a TransferOperation.
 *
 * @generated from enum google.storagetransfer.v1.TransferOperation.Status
 */
export enum TransferOperation_Status {
  /**
   * Zero is an illegal value.
   *
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  STATUS_UNSPECIFIED = 0,

  /**
   * In progress.
   *
   * @generated from enum value: IN_PROGRESS = 1;
   */
  IN_PROGRESS = 1,

  /**
   * Paused.
   *
   * @generated from enum value: PAUSED = 2;
   */
  PAUSED = 2,

  /**
   * Completed successfully.
   *
   * @generated from enum value: SUCCESS = 3;
   */
  SUCCESS = 3,

  /**
   * Terminated due to an unrecoverable failure.
   *
   * @generated from enum value: FAILED = 4;
   */
  FAILED = 4,

  /**
   * Aborted by the user.
   *
   * @generated from enum value: ABORTED = 5;
   */
  ABORTED = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(TransferOperation_Status)
proto3.util.setEnumType(TransferOperation_Status, "google.storagetransfer.v1.TransferOperation.Status", [
  { no: 0, name: "STATUS_UNSPECIFIED" },
  { no: 1, name: "IN_PROGRESS" },
  { no: 2, name: "PAUSED" },
  { no: 3, name: "SUCCESS" },
  { no: 4, name: "FAILED" },
  { no: 5, name: "ABORTED" },
]);

