// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/datastore/v1/datastore.proto (package google.datastore.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Entity, Key, PartitionId } from "./entity_pb.js";
import { EntityResult, GqlQuery, Query, QueryResultBatch } from "./query_pb.js";

/**
 * The request for [Datastore.Lookup][google.datastore.v1.Datastore.Lookup].
 *
 * @generated from message google.datastore.v1.LookupRequest
 */
export class LookupRequest extends Message<LookupRequest> {
  /**
   * The ID of the project against which to make the request.
   *
   * @generated from field: string project_id = 8;
   */
  projectId = "";

  /**
   * The options for this lookup request.
   *
   * @generated from field: google.datastore.v1.ReadOptions read_options = 1;
   */
  readOptions?: ReadOptions;

  /**
   * Keys of entities to look up.
   *
   * @generated from field: repeated google.datastore.v1.Key keys = 3;
   */
  keys: Key[] = [];

  constructor(data?: PartialMessage<LookupRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.LookupRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 8, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 1, name: "read_options", kind: "message", T: ReadOptions },
    { no: 3, name: "keys", kind: "message", T: Key, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LookupRequest {
    return new LookupRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LookupRequest {
    return new LookupRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LookupRequest {
    return new LookupRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LookupRequest | PlainMessage<LookupRequest> | undefined, b: LookupRequest | PlainMessage<LookupRequest> | undefined): boolean {
    return proto3.util.equals(LookupRequest, a, b);
  }
}

/**
 * The response for [Datastore.Lookup][google.datastore.v1.Datastore.Lookup].
 *
 * @generated from message google.datastore.v1.LookupResponse
 */
export class LookupResponse extends Message<LookupResponse> {
  /**
   * Entities found as `ResultType.FULL` entities. The order of results in this
   * field is undefined and has no relation to the order of the keys in the
   * input.
   *
   * @generated from field: repeated google.datastore.v1.EntityResult found = 1;
   */
  found: EntityResult[] = [];

  /**
   * Entities not found as `ResultType.KEY_ONLY` entities. The order of results
   * in this field is undefined and has no relation to the order of the keys
   * in the input.
   *
   * @generated from field: repeated google.datastore.v1.EntityResult missing = 2;
   */
  missing: EntityResult[] = [];

  /**
   * A list of keys that were not looked up due to resource constraints. The
   * order of results in this field is undefined and has no relation to the
   * order of the keys in the input.
   *
   * @generated from field: repeated google.datastore.v1.Key deferred = 3;
   */
  deferred: Key[] = [];

  constructor(data?: PartialMessage<LookupResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.LookupResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "found", kind: "message", T: EntityResult, repeated: true },
    { no: 2, name: "missing", kind: "message", T: EntityResult, repeated: true },
    { no: 3, name: "deferred", kind: "message", T: Key, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LookupResponse {
    return new LookupResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LookupResponse {
    return new LookupResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LookupResponse {
    return new LookupResponse().fromJsonString(jsonString, options);
  }

  static equals(a: LookupResponse | PlainMessage<LookupResponse> | undefined, b: LookupResponse | PlainMessage<LookupResponse> | undefined): boolean {
    return proto3.util.equals(LookupResponse, a, b);
  }
}

/**
 * The request for [Datastore.RunQuery][google.datastore.v1.Datastore.RunQuery].
 *
 * @generated from message google.datastore.v1.RunQueryRequest
 */
export class RunQueryRequest extends Message<RunQueryRequest> {
  /**
   * The ID of the project against which to make the request.
   *
   * @generated from field: string project_id = 8;
   */
  projectId = "";

  /**
   * Entities are partitioned into subsets, identified by a partition ID.
   * Queries are scoped to a single partition.
   * This partition ID is normalized with the standard default context
   * partition ID.
   *
   * @generated from field: google.datastore.v1.PartitionId partition_id = 2;
   */
  partitionId?: PartitionId;

  /**
   * The options for this query.
   *
   * @generated from field: google.datastore.v1.ReadOptions read_options = 1;
   */
  readOptions?: ReadOptions;

  /**
   * The type of query.
   *
   * @generated from oneof google.datastore.v1.RunQueryRequest.query_type
   */
  queryType: {
    /**
     * The query to run.
     *
     * @generated from field: google.datastore.v1.Query query = 3;
     */
    value: Query;
    case: "query";
  } | {
    /**
     * The GQL query to run.
     *
     * @generated from field: google.datastore.v1.GqlQuery gql_query = 7;
     */
    value: GqlQuery;
    case: "gqlQuery";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<RunQueryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.RunQueryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 8, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "partition_id", kind: "message", T: PartitionId },
    { no: 1, name: "read_options", kind: "message", T: ReadOptions },
    { no: 3, name: "query", kind: "message", T: Query, oneof: "query_type" },
    { no: 7, name: "gql_query", kind: "message", T: GqlQuery, oneof: "query_type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RunQueryRequest {
    return new RunQueryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RunQueryRequest {
    return new RunQueryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RunQueryRequest {
    return new RunQueryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RunQueryRequest | PlainMessage<RunQueryRequest> | undefined, b: RunQueryRequest | PlainMessage<RunQueryRequest> | undefined): boolean {
    return proto3.util.equals(RunQueryRequest, a, b);
  }
}

/**
 * The response for [Datastore.RunQuery][google.datastore.v1.Datastore.RunQuery].
 *
 * @generated from message google.datastore.v1.RunQueryResponse
 */
export class RunQueryResponse extends Message<RunQueryResponse> {
  /**
   * A batch of query results (always present).
   *
   * @generated from field: google.datastore.v1.QueryResultBatch batch = 1;
   */
  batch?: QueryResultBatch;

  /**
   * The parsed form of the `GqlQuery` from the request, if it was set.
   *
   * @generated from field: google.datastore.v1.Query query = 2;
   */
  query?: Query;

  constructor(data?: PartialMessage<RunQueryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.RunQueryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "batch", kind: "message", T: QueryResultBatch },
    { no: 2, name: "query", kind: "message", T: Query },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RunQueryResponse {
    return new RunQueryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RunQueryResponse {
    return new RunQueryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RunQueryResponse {
    return new RunQueryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RunQueryResponse | PlainMessage<RunQueryResponse> | undefined, b: RunQueryResponse | PlainMessage<RunQueryResponse> | undefined): boolean {
    return proto3.util.equals(RunQueryResponse, a, b);
  }
}

/**
 * The request for [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
 *
 * @generated from message google.datastore.v1.BeginTransactionRequest
 */
export class BeginTransactionRequest extends Message<BeginTransactionRequest> {
  /**
   * The ID of the project against which to make the request.
   *
   * @generated from field: string project_id = 8;
   */
  projectId = "";

  /**
   * Options for a new transaction.
   *
   * @generated from field: google.datastore.v1.TransactionOptions transaction_options = 10;
   */
  transactionOptions?: TransactionOptions;

  constructor(data?: PartialMessage<BeginTransactionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.BeginTransactionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 8, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "transaction_options", kind: "message", T: TransactionOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BeginTransactionRequest {
    return new BeginTransactionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BeginTransactionRequest {
    return new BeginTransactionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BeginTransactionRequest {
    return new BeginTransactionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: BeginTransactionRequest | PlainMessage<BeginTransactionRequest> | undefined, b: BeginTransactionRequest | PlainMessage<BeginTransactionRequest> | undefined): boolean {
    return proto3.util.equals(BeginTransactionRequest, a, b);
  }
}

/**
 * The response for [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
 *
 * @generated from message google.datastore.v1.BeginTransactionResponse
 */
export class BeginTransactionResponse extends Message<BeginTransactionResponse> {
  /**
   * The transaction identifier (always present).
   *
   * @generated from field: bytes transaction = 1;
   */
  transaction = new Uint8Array(0);

  constructor(data?: PartialMessage<BeginTransactionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.BeginTransactionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transaction", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BeginTransactionResponse {
    return new BeginTransactionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BeginTransactionResponse {
    return new BeginTransactionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BeginTransactionResponse {
    return new BeginTransactionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: BeginTransactionResponse | PlainMessage<BeginTransactionResponse> | undefined, b: BeginTransactionResponse | PlainMessage<BeginTransactionResponse> | undefined): boolean {
    return proto3.util.equals(BeginTransactionResponse, a, b);
  }
}

/**
 * The request for [Datastore.Rollback][google.datastore.v1.Datastore.Rollback].
 *
 * @generated from message google.datastore.v1.RollbackRequest
 */
export class RollbackRequest extends Message<RollbackRequest> {
  /**
   * The ID of the project against which to make the request.
   *
   * @generated from field: string project_id = 8;
   */
  projectId = "";

  /**
   * The transaction identifier, returned by a call to
   * [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
   *
   * @generated from field: bytes transaction = 1;
   */
  transaction = new Uint8Array(0);

  constructor(data?: PartialMessage<RollbackRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.RollbackRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 8, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 1, name: "transaction", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RollbackRequest {
    return new RollbackRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RollbackRequest {
    return new RollbackRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RollbackRequest {
    return new RollbackRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RollbackRequest | PlainMessage<RollbackRequest> | undefined, b: RollbackRequest | PlainMessage<RollbackRequest> | undefined): boolean {
    return proto3.util.equals(RollbackRequest, a, b);
  }
}

/**
 * The response for [Datastore.Rollback][google.datastore.v1.Datastore.Rollback].
 * (an empty message).
 *
 * @generated from message google.datastore.v1.RollbackResponse
 */
export class RollbackResponse extends Message<RollbackResponse> {
  constructor(data?: PartialMessage<RollbackResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.RollbackResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RollbackResponse {
    return new RollbackResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RollbackResponse {
    return new RollbackResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RollbackResponse {
    return new RollbackResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RollbackResponse | PlainMessage<RollbackResponse> | undefined, b: RollbackResponse | PlainMessage<RollbackResponse> | undefined): boolean {
    return proto3.util.equals(RollbackResponse, a, b);
  }
}

/**
 * The request for [Datastore.Commit][google.datastore.v1.Datastore.Commit].
 *
 * @generated from message google.datastore.v1.CommitRequest
 */
export class CommitRequest extends Message<CommitRequest> {
  /**
   * The ID of the project against which to make the request.
   *
   * @generated from field: string project_id = 8;
   */
  projectId = "";

  /**
   * The type of commit to perform. Defaults to `TRANSACTIONAL`.
   *
   * @generated from field: google.datastore.v1.CommitRequest.Mode mode = 5;
   */
  mode = CommitRequest_Mode.MODE_UNSPECIFIED;

  /**
   * Must be set when mode is `TRANSACTIONAL`.
   *
   * @generated from oneof google.datastore.v1.CommitRequest.transaction_selector
   */
  transactionSelector: {
    /**
     * The identifier of the transaction associated with the commit. A
     * transaction identifier is returned by a call to
     * [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
     *
     * @generated from field: bytes transaction = 1;
     */
    value: Uint8Array;
    case: "transaction";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The mutations to perform.
   *
   * When mode is `TRANSACTIONAL`, mutations affecting a single entity are
   * applied in order. The following sequences of mutations affecting a single
   * entity are not permitted in a single `Commit` request:
   *
   * - `insert` followed by `insert`
   * - `update` followed by `insert`
   * - `upsert` followed by `insert`
   * - `delete` followed by `update`
   *
   * When mode is `NON_TRANSACTIONAL`, no two mutations may affect a single
   * entity.
   *
   * @generated from field: repeated google.datastore.v1.Mutation mutations = 6;
   */
  mutations: Mutation[] = [];

  constructor(data?: PartialMessage<CommitRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.CommitRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 8, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "mode", kind: "enum", T: proto3.getEnumType(CommitRequest_Mode) },
    { no: 1, name: "transaction", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "transaction_selector" },
    { no: 6, name: "mutations", kind: "message", T: Mutation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommitRequest {
    return new CommitRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommitRequest {
    return new CommitRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommitRequest {
    return new CommitRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CommitRequest | PlainMessage<CommitRequest> | undefined, b: CommitRequest | PlainMessage<CommitRequest> | undefined): boolean {
    return proto3.util.equals(CommitRequest, a, b);
  }
}

/**
 * The modes available for commits.
 *
 * @generated from enum google.datastore.v1.CommitRequest.Mode
 */
export enum CommitRequest_Mode {
  /**
   * Unspecified. This value must not be used.
   *
   * @generated from enum value: MODE_UNSPECIFIED = 0;
   */
  MODE_UNSPECIFIED = 0,

  /**
   * Transactional: The mutations are either all applied, or none are applied.
   * Learn about transactions [here](https://cloud.google.com/datastore/docs/concepts/transactions).
   *
   * @generated from enum value: TRANSACTIONAL = 1;
   */
  TRANSACTIONAL = 1,

  /**
   * Non-transactional: The mutations may not apply as all or none.
   *
   * @generated from enum value: NON_TRANSACTIONAL = 2;
   */
  NON_TRANSACTIONAL = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(CommitRequest_Mode)
proto3.util.setEnumType(CommitRequest_Mode, "google.datastore.v1.CommitRequest.Mode", [
  { no: 0, name: "MODE_UNSPECIFIED" },
  { no: 1, name: "TRANSACTIONAL" },
  { no: 2, name: "NON_TRANSACTIONAL" },
]);

/**
 * The response for [Datastore.Commit][google.datastore.v1.Datastore.Commit].
 *
 * @generated from message google.datastore.v1.CommitResponse
 */
export class CommitResponse extends Message<CommitResponse> {
  /**
   * The result of performing the mutations.
   * The i-th mutation result corresponds to the i-th mutation in the request.
   *
   * @generated from field: repeated google.datastore.v1.MutationResult mutation_results = 3;
   */
  mutationResults: MutationResult[] = [];

  /**
   * The number of index entries updated during the commit, or zero if none were
   * updated.
   *
   * @generated from field: int32 index_updates = 4;
   */
  indexUpdates = 0;

  constructor(data?: PartialMessage<CommitResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.CommitResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "mutation_results", kind: "message", T: MutationResult, repeated: true },
    { no: 4, name: "index_updates", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommitResponse {
    return new CommitResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommitResponse {
    return new CommitResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommitResponse {
    return new CommitResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CommitResponse | PlainMessage<CommitResponse> | undefined, b: CommitResponse | PlainMessage<CommitResponse> | undefined): boolean {
    return proto3.util.equals(CommitResponse, a, b);
  }
}

/**
 * The request for [Datastore.AllocateIds][google.datastore.v1.Datastore.AllocateIds].
 *
 * @generated from message google.datastore.v1.AllocateIdsRequest
 */
export class AllocateIdsRequest extends Message<AllocateIdsRequest> {
  /**
   * The ID of the project against which to make the request.
   *
   * @generated from field: string project_id = 8;
   */
  projectId = "";

  /**
   * A list of keys with incomplete key paths for which to allocate IDs.
   * No key may be reserved/read-only.
   *
   * @generated from field: repeated google.datastore.v1.Key keys = 1;
   */
  keys: Key[] = [];

  constructor(data?: PartialMessage<AllocateIdsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.AllocateIdsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 8, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 1, name: "keys", kind: "message", T: Key, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AllocateIdsRequest {
    return new AllocateIdsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AllocateIdsRequest {
    return new AllocateIdsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AllocateIdsRequest {
    return new AllocateIdsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AllocateIdsRequest | PlainMessage<AllocateIdsRequest> | undefined, b: AllocateIdsRequest | PlainMessage<AllocateIdsRequest> | undefined): boolean {
    return proto3.util.equals(AllocateIdsRequest, a, b);
  }
}

/**
 * The response for [Datastore.AllocateIds][google.datastore.v1.Datastore.AllocateIds].
 *
 * @generated from message google.datastore.v1.AllocateIdsResponse
 */
export class AllocateIdsResponse extends Message<AllocateIdsResponse> {
  /**
   * The keys specified in the request (in the same order), each with
   * its key path completed with a newly allocated ID.
   *
   * @generated from field: repeated google.datastore.v1.Key keys = 1;
   */
  keys: Key[] = [];

  constructor(data?: PartialMessage<AllocateIdsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.AllocateIdsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "keys", kind: "message", T: Key, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AllocateIdsResponse {
    return new AllocateIdsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AllocateIdsResponse {
    return new AllocateIdsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AllocateIdsResponse {
    return new AllocateIdsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AllocateIdsResponse | PlainMessage<AllocateIdsResponse> | undefined, b: AllocateIdsResponse | PlainMessage<AllocateIdsResponse> | undefined): boolean {
    return proto3.util.equals(AllocateIdsResponse, a, b);
  }
}

/**
 * The request for [Datastore.ReserveIds][google.datastore.v1.Datastore.ReserveIds].
 *
 * @generated from message google.datastore.v1.ReserveIdsRequest
 */
export class ReserveIdsRequest extends Message<ReserveIdsRequest> {
  /**
   * The ID of the project against which to make the request.
   *
   * @generated from field: string project_id = 8;
   */
  projectId = "";

  /**
   * If not empty, the ID of the database against which to make the request.
   *
   * @generated from field: string database_id = 9;
   */
  databaseId = "";

  /**
   * A list of keys with complete key paths whose numeric IDs should not be
   * auto-allocated.
   *
   * @generated from field: repeated google.datastore.v1.Key keys = 1;
   */
  keys: Key[] = [];

  constructor(data?: PartialMessage<ReserveIdsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.ReserveIdsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 8, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "database_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 1, name: "keys", kind: "message", T: Key, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReserveIdsRequest {
    return new ReserveIdsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReserveIdsRequest {
    return new ReserveIdsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReserveIdsRequest {
    return new ReserveIdsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReserveIdsRequest | PlainMessage<ReserveIdsRequest> | undefined, b: ReserveIdsRequest | PlainMessage<ReserveIdsRequest> | undefined): boolean {
    return proto3.util.equals(ReserveIdsRequest, a, b);
  }
}

/**
 * The response for [Datastore.ReserveIds][google.datastore.v1.Datastore.ReserveIds].
 *
 * @generated from message google.datastore.v1.ReserveIdsResponse
 */
export class ReserveIdsResponse extends Message<ReserveIdsResponse> {
  constructor(data?: PartialMessage<ReserveIdsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.ReserveIdsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReserveIdsResponse {
    return new ReserveIdsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReserveIdsResponse {
    return new ReserveIdsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReserveIdsResponse {
    return new ReserveIdsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReserveIdsResponse | PlainMessage<ReserveIdsResponse> | undefined, b: ReserveIdsResponse | PlainMessage<ReserveIdsResponse> | undefined): boolean {
    return proto3.util.equals(ReserveIdsResponse, a, b);
  }
}

/**
 * A mutation to apply to an entity.
 *
 * @generated from message google.datastore.v1.Mutation
 */
export class Mutation extends Message<Mutation> {
  /**
   * The mutation operation.
   *
   * For `insert`, `update`, and `upsert`:
   * - The entity's key must not be reserved/read-only.
   * - No property in the entity may have a reserved name,
   *   not even a property in an entity in a value.
   * - No value in the entity may have meaning 18,
   *   not even a value in an entity in another value.
   *
   * @generated from oneof google.datastore.v1.Mutation.operation
   */
  operation: {
    /**
     * The entity to insert. The entity must not already exist.
     * The entity key's final path element may be incomplete.
     *
     * @generated from field: google.datastore.v1.Entity insert = 4;
     */
    value: Entity;
    case: "insert";
  } | {
    /**
     * The entity to update. The entity must already exist.
     * Must have a complete key path.
     *
     * @generated from field: google.datastore.v1.Entity update = 5;
     */
    value: Entity;
    case: "update";
  } | {
    /**
     * The entity to upsert. The entity may or may not already exist.
     * The entity key's final path element may be incomplete.
     *
     * @generated from field: google.datastore.v1.Entity upsert = 6;
     */
    value: Entity;
    case: "upsert";
  } | {
    /**
     * The key of the entity to delete. The entity may or may not already exist.
     * Must have a complete key path and must not be reserved/read-only.
     *
     * @generated from field: google.datastore.v1.Key delete = 7;
     */
    value: Key;
    case: "delete";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * When set, the server will detect whether or not this mutation conflicts
   * with the current version of the entity on the server. Conflicting mutations
   * are not applied, and are marked as such in MutationResult.
   *
   * @generated from oneof google.datastore.v1.Mutation.conflict_detection_strategy
   */
  conflictDetectionStrategy: {
    /**
     * The version of the entity that this mutation is being applied to. If this
     * does not match the current version on the server, the mutation conflicts.
     *
     * @generated from field: int64 base_version = 8;
     */
    value: bigint;
    case: "baseVersion";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Mutation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.Mutation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 4, name: "insert", kind: "message", T: Entity, oneof: "operation" },
    { no: 5, name: "update", kind: "message", T: Entity, oneof: "operation" },
    { no: 6, name: "upsert", kind: "message", T: Entity, oneof: "operation" },
    { no: 7, name: "delete", kind: "message", T: Key, oneof: "operation" },
    { no: 8, name: "base_version", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "conflict_detection_strategy" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Mutation {
    return new Mutation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Mutation {
    return new Mutation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Mutation {
    return new Mutation().fromJsonString(jsonString, options);
  }

  static equals(a: Mutation | PlainMessage<Mutation> | undefined, b: Mutation | PlainMessage<Mutation> | undefined): boolean {
    return proto3.util.equals(Mutation, a, b);
  }
}

/**
 * The result of applying a mutation.
 *
 * @generated from message google.datastore.v1.MutationResult
 */
export class MutationResult extends Message<MutationResult> {
  /**
   * The automatically allocated key.
   * Set only when the mutation allocated a key.
   *
   * @generated from field: google.datastore.v1.Key key = 3;
   */
  key?: Key;

  /**
   * The version of the entity on the server after processing the mutation. If
   * the mutation doesn't change anything on the server, then the version will
   * be the version of the current entity or, if no entity is present, a version
   * that is strictly greater than the version of any previous entity and less
   * than the version of any possible future entity.
   *
   * @generated from field: int64 version = 4;
   */
  version = protoInt64.zero;

  /**
   * Whether a conflict was detected for this mutation. Always false when a
   * conflict detection strategy field is not set in the mutation.
   *
   * @generated from field: bool conflict_detected = 5;
   */
  conflictDetected = false;

  constructor(data?: PartialMessage<MutationResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.MutationResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "key", kind: "message", T: Key },
    { no: 4, name: "version", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "conflict_detected", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MutationResult {
    return new MutationResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MutationResult {
    return new MutationResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MutationResult {
    return new MutationResult().fromJsonString(jsonString, options);
  }

  static equals(a: MutationResult | PlainMessage<MutationResult> | undefined, b: MutationResult | PlainMessage<MutationResult> | undefined): boolean {
    return proto3.util.equals(MutationResult, a, b);
  }
}

/**
 * The options shared by read requests.
 *
 * @generated from message google.datastore.v1.ReadOptions
 */
export class ReadOptions extends Message<ReadOptions> {
  /**
   * If not specified, lookups and ancestor queries default to
   * `read_consistency`=`STRONG`, global queries default to
   * `read_consistency`=`EVENTUAL`.
   *
   * @generated from oneof google.datastore.v1.ReadOptions.consistency_type
   */
  consistencyType: {
    /**
     * The non-transactional read consistency to use.
     * Cannot be set to `STRONG` for global queries.
     *
     * @generated from field: google.datastore.v1.ReadOptions.ReadConsistency read_consistency = 1;
     */
    value: ReadOptions_ReadConsistency;
    case: "readConsistency";
  } | {
    /**
     * The identifier of the transaction in which to read. A
     * transaction identifier is returned by a call to
     * [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction].
     *
     * @generated from field: bytes transaction = 2;
     */
    value: Uint8Array;
    case: "transaction";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ReadOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.ReadOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "read_consistency", kind: "enum", T: proto3.getEnumType(ReadOptions_ReadConsistency), oneof: "consistency_type" },
    { no: 2, name: "transaction", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "consistency_type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadOptions {
    return new ReadOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadOptions {
    return new ReadOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadOptions {
    return new ReadOptions().fromJsonString(jsonString, options);
  }

  static equals(a: ReadOptions | PlainMessage<ReadOptions> | undefined, b: ReadOptions | PlainMessage<ReadOptions> | undefined): boolean {
    return proto3.util.equals(ReadOptions, a, b);
  }
}

/**
 * The possible values for read consistencies.
 *
 * @generated from enum google.datastore.v1.ReadOptions.ReadConsistency
 */
export enum ReadOptions_ReadConsistency {
  /**
   * Unspecified. This value must not be used.
   *
   * @generated from enum value: READ_CONSISTENCY_UNSPECIFIED = 0;
   */
  READ_CONSISTENCY_UNSPECIFIED = 0,

  /**
   * Strong consistency.
   *
   * @generated from enum value: STRONG = 1;
   */
  STRONG = 1,

  /**
   * Eventual consistency.
   *
   * @generated from enum value: EVENTUAL = 2;
   */
  EVENTUAL = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ReadOptions_ReadConsistency)
proto3.util.setEnumType(ReadOptions_ReadConsistency, "google.datastore.v1.ReadOptions.ReadConsistency", [
  { no: 0, name: "READ_CONSISTENCY_UNSPECIFIED" },
  { no: 1, name: "STRONG" },
  { no: 2, name: "EVENTUAL" },
]);

/**
 * Options for beginning a new transaction.
 *
 * Transactions can be created explicitly with calls to
 * [Datastore.BeginTransaction][google.datastore.v1.Datastore.BeginTransaction] or implicitly by setting
 * [ReadOptions.new_transaction][google.datastore.v1.ReadOptions.new_transaction] in read requests.
 *
 * @generated from message google.datastore.v1.TransactionOptions
 */
export class TransactionOptions extends Message<TransactionOptions> {
  /**
   * The `mode` of the transaction, indicating whether write operations are
   * supported.
   *
   * @generated from oneof google.datastore.v1.TransactionOptions.mode
   */
  mode: {
    /**
     * The transaction should allow both reads and writes.
     *
     * @generated from field: google.datastore.v1.TransactionOptions.ReadWrite read_write = 1;
     */
    value: TransactionOptions_ReadWrite;
    case: "readWrite";
  } | {
    /**
     * The transaction should only allow reads.
     *
     * @generated from field: google.datastore.v1.TransactionOptions.ReadOnly read_only = 2;
     */
    value: TransactionOptions_ReadOnly;
    case: "readOnly";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<TransactionOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.TransactionOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "read_write", kind: "message", T: TransactionOptions_ReadWrite, oneof: "mode" },
    { no: 2, name: "read_only", kind: "message", T: TransactionOptions_ReadOnly, oneof: "mode" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionOptions {
    return new TransactionOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionOptions {
    return new TransactionOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionOptions {
    return new TransactionOptions().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionOptions | PlainMessage<TransactionOptions> | undefined, b: TransactionOptions | PlainMessage<TransactionOptions> | undefined): boolean {
    return proto3.util.equals(TransactionOptions, a, b);
  }
}

/**
 * Options specific to read / write transactions.
 *
 * @generated from message google.datastore.v1.TransactionOptions.ReadWrite
 */
export class TransactionOptions_ReadWrite extends Message<TransactionOptions_ReadWrite> {
  /**
   * The transaction identifier of the transaction being retried.
   *
   * @generated from field: bytes previous_transaction = 1;
   */
  previousTransaction = new Uint8Array(0);

  constructor(data?: PartialMessage<TransactionOptions_ReadWrite>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.TransactionOptions.ReadWrite";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "previous_transaction", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionOptions_ReadWrite {
    return new TransactionOptions_ReadWrite().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionOptions_ReadWrite {
    return new TransactionOptions_ReadWrite().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionOptions_ReadWrite {
    return new TransactionOptions_ReadWrite().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionOptions_ReadWrite | PlainMessage<TransactionOptions_ReadWrite> | undefined, b: TransactionOptions_ReadWrite | PlainMessage<TransactionOptions_ReadWrite> | undefined): boolean {
    return proto3.util.equals(TransactionOptions_ReadWrite, a, b);
  }
}

/**
 * Options specific to read-only transactions.
 *
 * @generated from message google.datastore.v1.TransactionOptions.ReadOnly
 */
export class TransactionOptions_ReadOnly extends Message<TransactionOptions_ReadOnly> {
  constructor(data?: PartialMessage<TransactionOptions_ReadOnly>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.TransactionOptions.ReadOnly";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionOptions_ReadOnly {
    return new TransactionOptions_ReadOnly().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionOptions_ReadOnly {
    return new TransactionOptions_ReadOnly().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionOptions_ReadOnly {
    return new TransactionOptions_ReadOnly().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionOptions_ReadOnly | PlainMessage<TransactionOptions_ReadOnly> | undefined, b: TransactionOptions_ReadOnly | PlainMessage<TransactionOptions_ReadOnly> | undefined): boolean {
    return proto3.util.equals(TransactionOptions_ReadOnly, a, b);
  }
}

