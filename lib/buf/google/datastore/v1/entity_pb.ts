// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/datastore/v1/entity.proto (package google.datastore.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, NullValue, proto3, Timestamp } from "@bufbuild/protobuf";
import { LatLng } from "../../type/latlng_pb.js";

/**
 * A partition ID identifies a grouping of entities. The grouping is always
 * by project and namespace, however the namespace ID may be empty.
 *
 * A partition ID contains several dimensions:
 * project ID and namespace ID.
 *
 * Partition dimensions:
 *
 * - May be `""`.
 * - Must be valid UTF-8 bytes.
 * - Must have values that match regex `[A-Za-z\d\.\-_]{1,100}`
 * If the value of any dimension matches regex `__.*__`, the partition is
 * reserved/read-only.
 * A reserved/read-only partition ID is forbidden in certain documented
 * contexts.
 *
 * Foreign partition IDs (in which the project ID does
 * not match the context project ID ) are discouraged.
 * Reads and writes of foreign partition IDs may fail if the project is not in an active state.
 *
 * @generated from message google.datastore.v1.PartitionId
 */
export class PartitionId extends Message<PartitionId> {
  /**
   * The ID of the project to which the entities belong.
   *
   * @generated from field: string project_id = 2;
   */
  projectId = "";

  /**
   * If not empty, the ID of the namespace to which the entities belong.
   *
   * @generated from field: string namespace_id = 4;
   */
  namespaceId = "";

  constructor(data?: PartialMessage<PartitionId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.PartitionId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "namespace_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PartitionId {
    return new PartitionId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PartitionId {
    return new PartitionId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PartitionId {
    return new PartitionId().fromJsonString(jsonString, options);
  }

  static equals(a: PartitionId | PlainMessage<PartitionId> | undefined, b: PartitionId | PlainMessage<PartitionId> | undefined): boolean {
    return proto3.util.equals(PartitionId, a, b);
  }
}

/**
 * A unique identifier for an entity.
 * If a key's partition ID or any of its path kinds or names are
 * reserved/read-only, the key is reserved/read-only.
 * A reserved/read-only key is forbidden in certain documented contexts.
 *
 * @generated from message google.datastore.v1.Key
 */
export class Key extends Message<Key> {
  /**
   * Entities are partitioned into subsets, currently identified by a project
   * ID and namespace ID.
   * Queries are scoped to a single partition.
   *
   * @generated from field: google.datastore.v1.PartitionId partition_id = 1;
   */
  partitionId?: PartitionId;

  /**
   * The entity path.
   * An entity path consists of one or more elements composed of a kind and a
   * string or numerical identifier, which identify entities. The first
   * element identifies a _root entity_, the second element identifies
   * a _child_ of the root entity, the third element identifies a child of the
   * second entity, and so forth. The entities identified by all prefixes of
   * the path are called the element's _ancestors_.
   *
   * An entity path is always fully complete: *all* of the entity's ancestors
   * are required to be in the path along with the entity identifier itself.
   * The only exception is that in some documented cases, the identifier in the
   * last path element (for the entity) itself may be omitted. For example,
   * the last path element of the key of `Mutation.insert` may have no
   * identifier.
   *
   * A path can never be empty, and a path can have at most 100 elements.
   *
   * @generated from field: repeated google.datastore.v1.Key.PathElement path = 2;
   */
  path: Key_PathElement[] = [];

  constructor(data?: PartialMessage<Key>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.Key";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "partition_id", kind: "message", T: PartitionId },
    { no: 2, name: "path", kind: "message", T: Key_PathElement, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Key {
    return new Key().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Key {
    return new Key().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Key {
    return new Key().fromJsonString(jsonString, options);
  }

  static equals(a: Key | PlainMessage<Key> | undefined, b: Key | PlainMessage<Key> | undefined): boolean {
    return proto3.util.equals(Key, a, b);
  }
}

/**
 * A (kind, ID/name) pair used to construct a key path.
 *
 * If either name or ID is set, the element is complete.
 * If neither is set, the element is incomplete.
 *
 * @generated from message google.datastore.v1.Key.PathElement
 */
export class Key_PathElement extends Message<Key_PathElement> {
  /**
   * The kind of the entity.
   * A kind matching regex `__.*__` is reserved/read-only.
   * A kind must not contain more than 1500 bytes when UTF-8 encoded.
   * Cannot be `""`.
   *
   * @generated from field: string kind = 1;
   */
  kind = "";

  /**
   * The type of ID.
   *
   * @generated from oneof google.datastore.v1.Key.PathElement.id_type
   */
  idType: {
    /**
     * The auto-allocated ID of the entity.
     * Never equal to zero. Values less than zero are discouraged and may not
     * be supported in the future.
     *
     * @generated from field: int64 id = 2;
     */
    value: bigint;
    case: "id";
  } | {
    /**
     * The name of the entity.
     * A name matching regex `__.*__` is reserved/read-only.
     * A name must not be more than 1500 bytes when UTF-8 encoded.
     * Cannot be `""`.
     *
     * @generated from field: string name = 3;
     */
    value: string;
    case: "name";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Key_PathElement>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.Key.PathElement";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "kind", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "id", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "id_type" },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "id_type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Key_PathElement {
    return new Key_PathElement().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Key_PathElement {
    return new Key_PathElement().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Key_PathElement {
    return new Key_PathElement().fromJsonString(jsonString, options);
  }

  static equals(a: Key_PathElement | PlainMessage<Key_PathElement> | undefined, b: Key_PathElement | PlainMessage<Key_PathElement> | undefined): boolean {
    return proto3.util.equals(Key_PathElement, a, b);
  }
}

/**
 * An array value.
 *
 * @generated from message google.datastore.v1.ArrayValue
 */
export class ArrayValue extends Message<ArrayValue> {
  /**
   * Values in the array.
   * The order of this array may not be preserved if it contains a mix of
   * indexed and unindexed values.
   *
   * @generated from field: repeated google.datastore.v1.Value values = 1;
   */
  values: Value[] = [];

  constructor(data?: PartialMessage<ArrayValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.ArrayValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "message", T: Value, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ArrayValue {
    return new ArrayValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ArrayValue {
    return new ArrayValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ArrayValue {
    return new ArrayValue().fromJsonString(jsonString, options);
  }

  static equals(a: ArrayValue | PlainMessage<ArrayValue> | undefined, b: ArrayValue | PlainMessage<ArrayValue> | undefined): boolean {
    return proto3.util.equals(ArrayValue, a, b);
  }
}

/**
 * A message that can hold any of the supported value types and associated
 * metadata.
 *
 * @generated from message google.datastore.v1.Value
 */
export class Value extends Message<Value> {
  /**
   * Must have a value set.
   *
   * @generated from oneof google.datastore.v1.Value.value_type
   */
  valueType: {
    /**
     * A null value.
     *
     * @generated from field: google.protobuf.NullValue null_value = 11;
     */
    value: NullValue;
    case: "nullValue";
  } | {
    /**
     * A boolean value.
     *
     * @generated from field: bool boolean_value = 1;
     */
    value: boolean;
    case: "booleanValue";
  } | {
    /**
     * An integer value.
     *
     * @generated from field: int64 integer_value = 2;
     */
    value: bigint;
    case: "integerValue";
  } | {
    /**
     * A double value.
     *
     * @generated from field: double double_value = 3;
     */
    value: number;
    case: "doubleValue";
  } | {
    /**
     * A timestamp value.
     * When stored in the Datastore, precise only to microseconds;
     * any additional precision is rounded down.
     *
     * @generated from field: google.protobuf.Timestamp timestamp_value = 10;
     */
    value: Timestamp;
    case: "timestampValue";
  } | {
    /**
     * A key value.
     *
     * @generated from field: google.datastore.v1.Key key_value = 5;
     */
    value: Key;
    case: "keyValue";
  } | {
    /**
     * A UTF-8 encoded string value.
     * When `exclude_from_indexes` is false (it is indexed) , may have at most 1500 bytes.
     * Otherwise, may be set to at least 1,000,000 bytes.
     *
     * @generated from field: string string_value = 17;
     */
    value: string;
    case: "stringValue";
  } | {
    /**
     * A blob value.
     * May have at most 1,000,000 bytes.
     * When `exclude_from_indexes` is false, may have at most 1500 bytes.
     * In JSON requests, must be base64-encoded.
     *
     * @generated from field: bytes blob_value = 18;
     */
    value: Uint8Array;
    case: "blobValue";
  } | {
    /**
     * A geo point value representing a point on the surface of Earth.
     *
     * @generated from field: google.type.LatLng geo_point_value = 8;
     */
    value: LatLng;
    case: "geoPointValue";
  } | {
    /**
     * An entity value.
     *
     * - May have no key.
     * - May have a key with an incomplete key path.
     * - May have a reserved/read-only key.
     *
     * @generated from field: google.datastore.v1.Entity entity_value = 6;
     */
    value: Entity;
    case: "entityValue";
  } | {
    /**
     * An array value.
     * Cannot contain another array value.
     * A `Value` instance that sets field `array_value` must not set fields
     * `meaning` or `exclude_from_indexes`.
     *
     * @generated from field: google.datastore.v1.ArrayValue array_value = 9;
     */
    value: ArrayValue;
    case: "arrayValue";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The `meaning` field should only be populated for backwards compatibility.
   *
   * @generated from field: int32 meaning = 14;
   */
  meaning = 0;

  /**
   * If the value should be excluded from all indexes including those defined
   * explicitly.
   *
   * @generated from field: bool exclude_from_indexes = 19;
   */
  excludeFromIndexes = false;

  constructor(data?: PartialMessage<Value>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.Value";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 11, name: "null_value", kind: "enum", T: proto3.getEnumType(NullValue), oneof: "value_type" },
    { no: 1, name: "boolean_value", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "value_type" },
    { no: 2, name: "integer_value", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "value_type" },
    { no: 3, name: "double_value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, oneof: "value_type" },
    { no: 10, name: "timestamp_value", kind: "message", T: Timestamp, oneof: "value_type" },
    { no: 5, name: "key_value", kind: "message", T: Key, oneof: "value_type" },
    { no: 17, name: "string_value", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "value_type" },
    { no: 18, name: "blob_value", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "value_type" },
    { no: 8, name: "geo_point_value", kind: "message", T: LatLng, oneof: "value_type" },
    { no: 6, name: "entity_value", kind: "message", T: Entity, oneof: "value_type" },
    { no: 9, name: "array_value", kind: "message", T: ArrayValue, oneof: "value_type" },
    { no: 14, name: "meaning", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 19, name: "exclude_from_indexes", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Value {
    return new Value().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Value {
    return new Value().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Value {
    return new Value().fromJsonString(jsonString, options);
  }

  static equals(a: Value | PlainMessage<Value> | undefined, b: Value | PlainMessage<Value> | undefined): boolean {
    return proto3.util.equals(Value, a, b);
  }
}

/**
 * A Datastore data object.
 *
 * An entity is limited to 1 megabyte when stored. That _roughly_
 * corresponds to a limit of 1 megabyte for the serialized form of this
 * message.
 *
 * @generated from message google.datastore.v1.Entity
 */
export class Entity extends Message<Entity> {
  /**
   * The entity's key.
   *
   * An entity must have a key, unless otherwise documented (for example,
   * an entity in `Value.entity_value` may have no key).
   * An entity's kind is its key path's last element's kind,
   * or null if it has no key.
   *
   * @generated from field: google.datastore.v1.Key key = 1;
   */
  key?: Key;

  /**
   * The entity's properties.
   * The map's keys are property names.
   * A property name matching regex `__.*__` is reserved.
   * A reserved property name is forbidden in certain documented contexts.
   * The name must not contain more than 500 characters.
   * The name cannot be `""`.
   *
   * @generated from field: map<string, google.datastore.v1.Value> properties = 3;
   */
  properties: { [key: string]: Value } = {};

  constructor(data?: PartialMessage<Entity>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.datastore.v1.Entity";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "message", T: Key },
    { no: 3, name: "properties", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Value} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Entity {
    return new Entity().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Entity {
    return new Entity().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Entity {
    return new Entity().fromJsonString(jsonString, options);
  }

  static equals(a: Entity | PlainMessage<Entity> | undefined, b: Entity | PlainMessage<Entity> | undefined): boolean {
    return proto3.util.equals(Entity, a, b);
  }
}

