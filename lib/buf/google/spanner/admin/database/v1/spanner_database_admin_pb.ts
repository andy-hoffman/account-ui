// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/spanner/admin/database/v1/spanner_database_admin.proto (package google.spanner.admin.database.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";

/**
 * A Cloud Spanner database.
 *
 * @generated from message google.spanner.admin.database.v1.Database
 */
export class Database extends Message<Database> {
  /**
   * Required. The name of the database. Values are of the form
   * `projects/<project>/instances/<instance>/databases/<database>`,
   * where `<database>` is as specified in the `CREATE DATABASE`
   * statement. This name can be passed to other API methods to
   * identify the database.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Output only. The current database state.
   *
   * @generated from field: google.spanner.admin.database.v1.Database.State state = 2;
   */
  state = Database_State.STATE_UNSPECIFIED;

  constructor(data?: PartialMessage<Database>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.admin.database.v1.Database";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "state", kind: "enum", T: proto3.getEnumType(Database_State) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Database {
    return new Database().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Database {
    return new Database().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Database {
    return new Database().fromJsonString(jsonString, options);
  }

  static equals(a: Database | PlainMessage<Database> | undefined, b: Database | PlainMessage<Database> | undefined): boolean {
    return proto3.util.equals(Database, a, b);
  }
}

/**
 * Indicates the current state of the database.
 *
 * @generated from enum google.spanner.admin.database.v1.Database.State
 */
export enum Database_State {
  /**
   * Not specified.
   *
   * @generated from enum value: STATE_UNSPECIFIED = 0;
   */
  STATE_UNSPECIFIED = 0,

  /**
   * The database is still being created. Operations on the database may fail
   * with `FAILED_PRECONDITION` in this state.
   *
   * @generated from enum value: CREATING = 1;
   */
  CREATING = 1,

  /**
   * The database is fully created and ready for use.
   *
   * @generated from enum value: READY = 2;
   */
  READY = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(Database_State)
proto3.util.setEnumType(Database_State, "google.spanner.admin.database.v1.Database.State", [
  { no: 0, name: "STATE_UNSPECIFIED" },
  { no: 1, name: "CREATING" },
  { no: 2, name: "READY" },
]);

/**
 * The request for [ListDatabases][google.spanner.admin.database.v1.DatabaseAdmin.ListDatabases].
 *
 * @generated from message google.spanner.admin.database.v1.ListDatabasesRequest
 */
export class ListDatabasesRequest extends Message<ListDatabasesRequest> {
  /**
   * Required. The instance whose databases should be listed.
   * Values are of the form `projects/<project>/instances/<instance>`.
   *
   * @generated from field: string parent = 1;
   */
  parent = "";

  /**
   * Number of databases to be returned in the response. If 0 or less,
   * defaults to the server's maximum allowed page size.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize = 0;

  /**
   * If non-empty, `page_token` should contain a
   * [next_page_token][google.spanner.admin.database.v1.ListDatabasesResponse.next_page_token] from a
   * previous [ListDatabasesResponse][google.spanner.admin.database.v1.ListDatabasesResponse].
   *
   * @generated from field: string page_token = 4;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListDatabasesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.admin.database.v1.ListDatabasesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListDatabasesRequest {
    return new ListDatabasesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListDatabasesRequest {
    return new ListDatabasesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListDatabasesRequest {
    return new ListDatabasesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListDatabasesRequest | PlainMessage<ListDatabasesRequest> | undefined, b: ListDatabasesRequest | PlainMessage<ListDatabasesRequest> | undefined): boolean {
    return proto3.util.equals(ListDatabasesRequest, a, b);
  }
}

/**
 * The response for [ListDatabases][google.spanner.admin.database.v1.DatabaseAdmin.ListDatabases].
 *
 * @generated from message google.spanner.admin.database.v1.ListDatabasesResponse
 */
export class ListDatabasesResponse extends Message<ListDatabasesResponse> {
  /**
   * Databases that matched the request.
   *
   * @generated from field: repeated google.spanner.admin.database.v1.Database databases = 1;
   */
  databases: Database[] = [];

  /**
   * `next_page_token` can be sent in a subsequent
   * [ListDatabases][google.spanner.admin.database.v1.DatabaseAdmin.ListDatabases] call to fetch more
   * of the matching databases.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListDatabasesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.admin.database.v1.ListDatabasesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "databases", kind: "message", T: Database, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListDatabasesResponse {
    return new ListDatabasesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListDatabasesResponse {
    return new ListDatabasesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListDatabasesResponse {
    return new ListDatabasesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListDatabasesResponse | PlainMessage<ListDatabasesResponse> | undefined, b: ListDatabasesResponse | PlainMessage<ListDatabasesResponse> | undefined): boolean {
    return proto3.util.equals(ListDatabasesResponse, a, b);
  }
}

/**
 * The request for [CreateDatabase][google.spanner.admin.database.v1.DatabaseAdmin.CreateDatabase].
 *
 * @generated from message google.spanner.admin.database.v1.CreateDatabaseRequest
 */
export class CreateDatabaseRequest extends Message<CreateDatabaseRequest> {
  /**
   * Required. The name of the instance that will serve the new database.
   * Values are of the form `projects/<project>/instances/<instance>`.
   *
   * @generated from field: string parent = 1;
   */
  parent = "";

  /**
   * Required. A `CREATE DATABASE` statement, which specifies the ID of the
   * new database.  The database ID must conform to the regular expression
   * `[a-z][a-z0-9_\-]*[a-z0-9]` and be between 2 and 30 characters in length.
   * If the database ID is a reserved word or if it contains a hyphen, the
   * database ID must be enclosed in backticks (`` ` ``).
   *
   * @generated from field: string create_statement = 2;
   */
  createStatement = "";

  /**
   * An optional list of DDL statements to run inside the newly created
   * database. Statements can create tables, indexes, etc. These
   * statements execute atomically with the creation of the database:
   * if there is an error in any statement, the database is not created.
   *
   * @generated from field: repeated string extra_statements = 3;
   */
  extraStatements: string[] = [];

  constructor(data?: PartialMessage<CreateDatabaseRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.admin.database.v1.CreateDatabaseRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "create_statement", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "extra_statements", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateDatabaseRequest {
    return new CreateDatabaseRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateDatabaseRequest {
    return new CreateDatabaseRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateDatabaseRequest {
    return new CreateDatabaseRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateDatabaseRequest | PlainMessage<CreateDatabaseRequest> | undefined, b: CreateDatabaseRequest | PlainMessage<CreateDatabaseRequest> | undefined): boolean {
    return proto3.util.equals(CreateDatabaseRequest, a, b);
  }
}

/**
 * Metadata type for the operation returned by
 * [CreateDatabase][google.spanner.admin.database.v1.DatabaseAdmin.CreateDatabase].
 *
 * @generated from message google.spanner.admin.database.v1.CreateDatabaseMetadata
 */
export class CreateDatabaseMetadata extends Message<CreateDatabaseMetadata> {
  /**
   * The database being created.
   *
   * @generated from field: string database = 1;
   */
  database = "";

  constructor(data?: PartialMessage<CreateDatabaseMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.admin.database.v1.CreateDatabaseMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "database", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateDatabaseMetadata {
    return new CreateDatabaseMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateDatabaseMetadata {
    return new CreateDatabaseMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateDatabaseMetadata {
    return new CreateDatabaseMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: CreateDatabaseMetadata | PlainMessage<CreateDatabaseMetadata> | undefined, b: CreateDatabaseMetadata | PlainMessage<CreateDatabaseMetadata> | undefined): boolean {
    return proto3.util.equals(CreateDatabaseMetadata, a, b);
  }
}

/**
 * The request for [GetDatabase][google.spanner.admin.database.v1.DatabaseAdmin.GetDatabase].
 *
 * @generated from message google.spanner.admin.database.v1.GetDatabaseRequest
 */
export class GetDatabaseRequest extends Message<GetDatabaseRequest> {
  /**
   * Required. The name of the requested database. Values are of the form
   * `projects/<project>/instances/<instance>/databases/<database>`.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<GetDatabaseRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.admin.database.v1.GetDatabaseRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetDatabaseRequest {
    return new GetDatabaseRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetDatabaseRequest {
    return new GetDatabaseRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetDatabaseRequest {
    return new GetDatabaseRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetDatabaseRequest | PlainMessage<GetDatabaseRequest> | undefined, b: GetDatabaseRequest | PlainMessage<GetDatabaseRequest> | undefined): boolean {
    return proto3.util.equals(GetDatabaseRequest, a, b);
  }
}

/**
 * Enqueues the given DDL statements to be applied, in order but not
 * necessarily all at once, to the database schema at some point (or
 * points) in the future. The server checks that the statements
 * are executable (syntactically valid, name tables that exist, etc.)
 * before enqueueing them, but they may still fail upon
 * later execution (e.g., if a statement from another batch of
 * statements is applied first and it conflicts in some way, or if
 * there is some data-related problem like a `NULL` value in a column to
 * which `NOT NULL` would be added). If a statement fails, all
 * subsequent statements in the batch are automatically cancelled.
 *
 * Each batch of statements is assigned a name which can be used with
 * the [Operations][google.longrunning.Operations] API to monitor
 * progress. See the
 * [operation_id][google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.operation_id] field for more
 * details.
 *
 * @generated from message google.spanner.admin.database.v1.UpdateDatabaseDdlRequest
 */
export class UpdateDatabaseDdlRequest extends Message<UpdateDatabaseDdlRequest> {
  /**
   * Required. The database to update.
   *
   * @generated from field: string database = 1;
   */
  database = "";

  /**
   * DDL statements to be applied to the database.
   *
   * @generated from field: repeated string statements = 2;
   */
  statements: string[] = [];

  /**
   * If empty, the new update request is assigned an
   * automatically-generated operation ID. Otherwise, `operation_id`
   * is used to construct the name of the resulting
   * [Operation][google.longrunning.Operation].
   *
   * Specifying an explicit operation ID simplifies determining
   * whether the statements were executed in the event that the
   * [UpdateDatabaseDdl][google.spanner.admin.database.v1.DatabaseAdmin.UpdateDatabaseDdl] call is replayed,
   * or the return value is otherwise lost: the [database][google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.database] and
   * `operation_id` fields can be combined to form the
   * [name][google.longrunning.Operation.name] of the resulting
   * [longrunning.Operation][google.longrunning.Operation]: `<database>/operations/<operation_id>`.
   *
   * `operation_id` should be unique within the database, and must be
   * a valid identifier: `[a-z][a-z0-9_]*`. Note that
   * automatically-generated operation IDs always begin with an
   * underscore. If the named operation already exists,
   * [UpdateDatabaseDdl][google.spanner.admin.database.v1.DatabaseAdmin.UpdateDatabaseDdl] returns
   * `ALREADY_EXISTS`.
   *
   * @generated from field: string operation_id = 3;
   */
  operationId = "";

  constructor(data?: PartialMessage<UpdateDatabaseDdlRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.admin.database.v1.UpdateDatabaseDdlRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "database", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "statements", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "operation_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateDatabaseDdlRequest {
    return new UpdateDatabaseDdlRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateDatabaseDdlRequest {
    return new UpdateDatabaseDdlRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateDatabaseDdlRequest {
    return new UpdateDatabaseDdlRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateDatabaseDdlRequest | PlainMessage<UpdateDatabaseDdlRequest> | undefined, b: UpdateDatabaseDdlRequest | PlainMessage<UpdateDatabaseDdlRequest> | undefined): boolean {
    return proto3.util.equals(UpdateDatabaseDdlRequest, a, b);
  }
}

/**
 * Metadata type for the operation returned by
 * [UpdateDatabaseDdl][google.spanner.admin.database.v1.DatabaseAdmin.UpdateDatabaseDdl].
 *
 * @generated from message google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata
 */
export class UpdateDatabaseDdlMetadata extends Message<UpdateDatabaseDdlMetadata> {
  /**
   * The database being modified.
   *
   * @generated from field: string database = 1;
   */
  database = "";

  /**
   * For an update this list contains all the statements. For an
   * individual statement, this list contains only that statement.
   *
   * @generated from field: repeated string statements = 2;
   */
  statements: string[] = [];

  /**
   * Reports the commit timestamps of all statements that have
   * succeeded so far, where `commit_timestamps[i]` is the commit
   * timestamp for the statement `statements[i]`.
   *
   * @generated from field: repeated google.protobuf.Timestamp commit_timestamps = 3;
   */
  commitTimestamps: Timestamp[] = [];

  constructor(data?: PartialMessage<UpdateDatabaseDdlMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.admin.database.v1.UpdateDatabaseDdlMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "database", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "statements", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "commit_timestamps", kind: "message", T: Timestamp, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateDatabaseDdlMetadata {
    return new UpdateDatabaseDdlMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateDatabaseDdlMetadata {
    return new UpdateDatabaseDdlMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateDatabaseDdlMetadata {
    return new UpdateDatabaseDdlMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateDatabaseDdlMetadata | PlainMessage<UpdateDatabaseDdlMetadata> | undefined, b: UpdateDatabaseDdlMetadata | PlainMessage<UpdateDatabaseDdlMetadata> | undefined): boolean {
    return proto3.util.equals(UpdateDatabaseDdlMetadata, a, b);
  }
}

/**
 * The request for [DropDatabase][google.spanner.admin.database.v1.DatabaseAdmin.DropDatabase].
 *
 * @generated from message google.spanner.admin.database.v1.DropDatabaseRequest
 */
export class DropDatabaseRequest extends Message<DropDatabaseRequest> {
  /**
   * Required. The database to be dropped.
   *
   * @generated from field: string database = 1;
   */
  database = "";

  constructor(data?: PartialMessage<DropDatabaseRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.admin.database.v1.DropDatabaseRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "database", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DropDatabaseRequest {
    return new DropDatabaseRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DropDatabaseRequest {
    return new DropDatabaseRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DropDatabaseRequest {
    return new DropDatabaseRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DropDatabaseRequest | PlainMessage<DropDatabaseRequest> | undefined, b: DropDatabaseRequest | PlainMessage<DropDatabaseRequest> | undefined): boolean {
    return proto3.util.equals(DropDatabaseRequest, a, b);
  }
}

/**
 * The request for [GetDatabaseDdl][google.spanner.admin.database.v1.DatabaseAdmin.GetDatabaseDdl].
 *
 * @generated from message google.spanner.admin.database.v1.GetDatabaseDdlRequest
 */
export class GetDatabaseDdlRequest extends Message<GetDatabaseDdlRequest> {
  /**
   * Required. The database whose schema we wish to get.
   *
   * @generated from field: string database = 1;
   */
  database = "";

  constructor(data?: PartialMessage<GetDatabaseDdlRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.admin.database.v1.GetDatabaseDdlRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "database", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetDatabaseDdlRequest {
    return new GetDatabaseDdlRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetDatabaseDdlRequest {
    return new GetDatabaseDdlRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetDatabaseDdlRequest {
    return new GetDatabaseDdlRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetDatabaseDdlRequest | PlainMessage<GetDatabaseDdlRequest> | undefined, b: GetDatabaseDdlRequest | PlainMessage<GetDatabaseDdlRequest> | undefined): boolean {
    return proto3.util.equals(GetDatabaseDdlRequest, a, b);
  }
}

/**
 * The response for [GetDatabaseDdl][google.spanner.admin.database.v1.DatabaseAdmin.GetDatabaseDdl].
 *
 * @generated from message google.spanner.admin.database.v1.GetDatabaseDdlResponse
 */
export class GetDatabaseDdlResponse extends Message<GetDatabaseDdlResponse> {
  /**
   * A list of formatted DDL statements defining the schema of the database
   * specified in the request.
   *
   * @generated from field: repeated string statements = 1;
   */
  statements: string[] = [];

  constructor(data?: PartialMessage<GetDatabaseDdlResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.admin.database.v1.GetDatabaseDdlResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "statements", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetDatabaseDdlResponse {
    return new GetDatabaseDdlResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetDatabaseDdlResponse {
    return new GetDatabaseDdlResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetDatabaseDdlResponse {
    return new GetDatabaseDdlResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetDatabaseDdlResponse | PlainMessage<GetDatabaseDdlResponse> | undefined, b: GetDatabaseDdlResponse | PlainMessage<GetDatabaseDdlResponse> | undefined): boolean {
    return proto3.util.equals(GetDatabaseDdlResponse, a, b);
  }
}

