// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/spanner/v1/spanner.proto (package google.spanner.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Struct, Timestamp } from "@bufbuild/protobuf";
import { TransactionOptions, TransactionSelector } from "./transaction_pb.js";
import { Type } from "./type_pb.js";
import { KeySet } from "./keys_pb.js";
import { Mutation } from "./mutation_pb.js";

/**
 * The request for [CreateSession][google.spanner.v1.Spanner.CreateSession].
 *
 * @generated from message google.spanner.v1.CreateSessionRequest
 */
export class CreateSessionRequest extends Message<CreateSessionRequest> {
  /**
   * Required. The database in which the new session is created.
   *
   * @generated from field: string database = 1;
   */
  database = "";

  /**
   * The session to create.
   *
   * @generated from field: google.spanner.v1.Session session = 2;
   */
  session?: Session;

  constructor(data?: PartialMessage<CreateSessionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.v1.CreateSessionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "database", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "session", kind: "message", T: Session },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateSessionRequest {
    return new CreateSessionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateSessionRequest {
    return new CreateSessionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateSessionRequest {
    return new CreateSessionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateSessionRequest | PlainMessage<CreateSessionRequest> | undefined, b: CreateSessionRequest | PlainMessage<CreateSessionRequest> | undefined): boolean {
    return proto3.util.equals(CreateSessionRequest, a, b);
  }
}

/**
 * A session in the Cloud Spanner API.
 *
 * @generated from message google.spanner.v1.Session
 */
export class Session extends Message<Session> {
  /**
   * The name of the session. This is always system-assigned; values provided
   * when creating a session are ignored.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The labels for the session.
   *
   *  * Label keys must be between 1 and 63 characters long and must conform to
   *    the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
   *  * Label values must be between 0 and 63 characters long and must conform
   *    to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
   *  * No more than 64 labels can be associated with a given session.
   *
   * See https://goo.gl/xmQnxf for more information on and examples of labels.
   *
   * @generated from field: map<string, string> labels = 2;
   */
  labels: { [key: string]: string } = {};

  /**
   * Output only. The timestamp when the session is created.
   *
   * @generated from field: google.protobuf.Timestamp create_time = 3;
   */
  createTime?: Timestamp;

  /**
   * Output only. The approximate timestamp when the session is last used. It is
   * typically earlier than the actual last use time.
   *
   * @generated from field: google.protobuf.Timestamp approximate_last_use_time = 4;
   */
  approximateLastUseTime?: Timestamp;

  constructor(data?: PartialMessage<Session>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.v1.Session";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 3, name: "create_time", kind: "message", T: Timestamp },
    { no: 4, name: "approximate_last_use_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Session {
    return new Session().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Session {
    return new Session().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Session {
    return new Session().fromJsonString(jsonString, options);
  }

  static equals(a: Session | PlainMessage<Session> | undefined, b: Session | PlainMessage<Session> | undefined): boolean {
    return proto3.util.equals(Session, a, b);
  }
}

/**
 * The request for [GetSession][google.spanner.v1.Spanner.GetSession].
 *
 * @generated from message google.spanner.v1.GetSessionRequest
 */
export class GetSessionRequest extends Message<GetSessionRequest> {
  /**
   * Required. The name of the session to retrieve.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<GetSessionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.v1.GetSessionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSessionRequest {
    return new GetSessionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSessionRequest {
    return new GetSessionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSessionRequest {
    return new GetSessionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSessionRequest | PlainMessage<GetSessionRequest> | undefined, b: GetSessionRequest | PlainMessage<GetSessionRequest> | undefined): boolean {
    return proto3.util.equals(GetSessionRequest, a, b);
  }
}

/**
 * The request for [ListSessions][google.spanner.v1.Spanner.ListSessions].
 *
 * @generated from message google.spanner.v1.ListSessionsRequest
 */
export class ListSessionsRequest extends Message<ListSessionsRequest> {
  /**
   * Required. The database in which to list sessions.
   *
   * @generated from field: string database = 1;
   */
  database = "";

  /**
   * Number of sessions to be returned in the response. If 0 or less, defaults
   * to the server's maximum allowed page size.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * If non-empty, `page_token` should contain a
   * [next_page_token][google.spanner.v1.ListSessionsResponse.next_page_token] from a previous
   * [ListSessionsResponse][google.spanner.v1.ListSessionsResponse].
   *
   * @generated from field: string page_token = 3;
   */
  pageToken = "";

  /**
   * An expression for filtering the results of the request. Filter rules are
   * case insensitive. The fields eligible for filtering are:
   *
   *   * `labels.key` where key is the name of a label
   *
   * Some examples of using filters are:
   *
   *   * `labels.env:*` --> The session has the label "env".
   *   * `labels.env:dev` --> The session has the label "env" and the value of
   *                        the label contains the string "dev".
   *
   * @generated from field: string filter = 4;
   */
  filter = "";

  constructor(data?: PartialMessage<ListSessionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.v1.ListSessionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "database", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSessionsRequest {
    return new ListSessionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSessionsRequest {
    return new ListSessionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSessionsRequest {
    return new ListSessionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListSessionsRequest | PlainMessage<ListSessionsRequest> | undefined, b: ListSessionsRequest | PlainMessage<ListSessionsRequest> | undefined): boolean {
    return proto3.util.equals(ListSessionsRequest, a, b);
  }
}

/**
 * The response for [ListSessions][google.spanner.v1.Spanner.ListSessions].
 *
 * @generated from message google.spanner.v1.ListSessionsResponse
 */
export class ListSessionsResponse extends Message<ListSessionsResponse> {
  /**
   * The list of requested sessions.
   *
   * @generated from field: repeated google.spanner.v1.Session sessions = 1;
   */
  sessions: Session[] = [];

  /**
   * `next_page_token` can be sent in a subsequent
   * [ListSessions][google.spanner.v1.Spanner.ListSessions] call to fetch more of the matching
   * sessions.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListSessionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.v1.ListSessionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sessions", kind: "message", T: Session, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSessionsResponse {
    return new ListSessionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSessionsResponse {
    return new ListSessionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSessionsResponse {
    return new ListSessionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListSessionsResponse | PlainMessage<ListSessionsResponse> | undefined, b: ListSessionsResponse | PlainMessage<ListSessionsResponse> | undefined): boolean {
    return proto3.util.equals(ListSessionsResponse, a, b);
  }
}

/**
 * The request for [DeleteSession][google.spanner.v1.Spanner.DeleteSession].
 *
 * @generated from message google.spanner.v1.DeleteSessionRequest
 */
export class DeleteSessionRequest extends Message<DeleteSessionRequest> {
  /**
   * Required. The name of the session to delete.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<DeleteSessionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.v1.DeleteSessionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteSessionRequest {
    return new DeleteSessionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteSessionRequest {
    return new DeleteSessionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteSessionRequest {
    return new DeleteSessionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteSessionRequest | PlainMessage<DeleteSessionRequest> | undefined, b: DeleteSessionRequest | PlainMessage<DeleteSessionRequest> | undefined): boolean {
    return proto3.util.equals(DeleteSessionRequest, a, b);
  }
}

/**
 * The request for [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql] and
 * [ExecuteStreamingSql][google.spanner.v1.Spanner.ExecuteStreamingSql].
 *
 * @generated from message google.spanner.v1.ExecuteSqlRequest
 */
export class ExecuteSqlRequest extends Message<ExecuteSqlRequest> {
  /**
   * Required. The session in which the SQL query should be performed.
   *
   * @generated from field: string session = 1;
   */
  session = "";

  /**
   * The transaction to use. If none is provided, the default is a
   * temporary read-only transaction with strong concurrency.
   *
   * @generated from field: google.spanner.v1.TransactionSelector transaction = 2;
   */
  transaction?: TransactionSelector;

  /**
   * Required. The SQL query string.
   *
   * @generated from field: string sql = 3;
   */
  sql = "";

  /**
   * The SQL query string can contain parameter placeholders. A parameter
   * placeholder consists of `'@'` followed by the parameter
   * name. Parameter names consist of any combination of letters,
   * numbers, and underscores.
   *
   * Parameters can appear anywhere that a literal value is expected.  The same
   * parameter name can be used more than once, for example:
   *   `"WHERE id > @msg_id AND id < @msg_id + 100"`
   *
   * It is an error to execute an SQL query with unbound parameters.
   *
   * Parameter values are specified using `params`, which is a JSON
   * object whose keys are parameter names, and whose values are the
   * corresponding parameter values.
   *
   * @generated from field: google.protobuf.Struct params = 4;
   */
  params?: Struct;

  /**
   * It is not always possible for Cloud Spanner to infer the right SQL type
   * from a JSON value.  For example, values of type `BYTES` and values
   * of type `STRING` both appear in [params][google.spanner.v1.ExecuteSqlRequest.params] as JSON strings.
   *
   * In these cases, `param_types` can be used to specify the exact
   * SQL type for some or all of the SQL query parameters. See the
   * definition of [Type][google.spanner.v1.Type] for more information
   * about SQL types.
   *
   * @generated from field: map<string, google.spanner.v1.Type> param_types = 5;
   */
  paramTypes: { [key: string]: Type } = {};

  /**
   * If this request is resuming a previously interrupted SQL query
   * execution, `resume_token` should be copied from the last
   * [PartialResultSet][google.spanner.v1.PartialResultSet] yielded before the interruption. Doing this
   * enables the new SQL query execution to resume where the last one left
   * off. The rest of the request parameters must exactly match the
   * request that yielded this token.
   *
   * @generated from field: bytes resume_token = 6;
   */
  resumeToken = new Uint8Array(0);

  /**
   * Used to control the amount of debugging information returned in
   * [ResultSetStats][google.spanner.v1.ResultSetStats].
   *
   * @generated from field: google.spanner.v1.ExecuteSqlRequest.QueryMode query_mode = 7;
   */
  queryMode = ExecuteSqlRequest_QueryMode.NORMAL;

  constructor(data?: PartialMessage<ExecuteSqlRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.v1.ExecuteSqlRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "session", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "transaction", kind: "message", T: TransactionSelector },
    { no: 3, name: "sql", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "params", kind: "message", T: Struct },
    { no: 5, name: "param_types", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Type} },
    { no: 6, name: "resume_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "query_mode", kind: "enum", T: proto3.getEnumType(ExecuteSqlRequest_QueryMode) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecuteSqlRequest {
    return new ExecuteSqlRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecuteSqlRequest {
    return new ExecuteSqlRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecuteSqlRequest {
    return new ExecuteSqlRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExecuteSqlRequest | PlainMessage<ExecuteSqlRequest> | undefined, b: ExecuteSqlRequest | PlainMessage<ExecuteSqlRequest> | undefined): boolean {
    return proto3.util.equals(ExecuteSqlRequest, a, b);
  }
}

/**
 * Mode in which the query must be processed.
 *
 * @generated from enum google.spanner.v1.ExecuteSqlRequest.QueryMode
 */
export enum ExecuteSqlRequest_QueryMode {
  /**
   * The default mode where only the query result, without any information
   * about the query plan is returned.
   *
   * @generated from enum value: NORMAL = 0;
   */
  NORMAL = 0,

  /**
   * This mode returns only the query plan, without any result rows or
   * execution statistics information.
   *
   * @generated from enum value: PLAN = 1;
   */
  PLAN = 1,

  /**
   * This mode returns both the query plan and the execution statistics along
   * with the result rows.
   *
   * @generated from enum value: PROFILE = 2;
   */
  PROFILE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ExecuteSqlRequest_QueryMode)
proto3.util.setEnumType(ExecuteSqlRequest_QueryMode, "google.spanner.v1.ExecuteSqlRequest.QueryMode", [
  { no: 0, name: "NORMAL" },
  { no: 1, name: "PLAN" },
  { no: 2, name: "PROFILE" },
]);

/**
 * The request for [Read][google.spanner.v1.Spanner.Read] and
 * [StreamingRead][google.spanner.v1.Spanner.StreamingRead].
 *
 * @generated from message google.spanner.v1.ReadRequest
 */
export class ReadRequest extends Message<ReadRequest> {
  /**
   * Required. The session in which the read should be performed.
   *
   * @generated from field: string session = 1;
   */
  session = "";

  /**
   * The transaction to use. If none is provided, the default is a
   * temporary read-only transaction with strong concurrency.
   *
   * @generated from field: google.spanner.v1.TransactionSelector transaction = 2;
   */
  transaction?: TransactionSelector;

  /**
   * Required. The name of the table in the database to be read.
   *
   * @generated from field: string table = 3;
   */
  table = "";

  /**
   * If non-empty, the name of an index on [table][google.spanner.v1.ReadRequest.table]. This index is
   * used instead of the table primary key when interpreting [key_set][google.spanner.v1.ReadRequest.key_set]
   * and sorting result rows. See [key_set][google.spanner.v1.ReadRequest.key_set] for further information.
   *
   * @generated from field: string index = 4;
   */
  index = "";

  /**
   * The columns of [table][google.spanner.v1.ReadRequest.table] to be returned for each row matching
   * this request.
   *
   * @generated from field: repeated string columns = 5;
   */
  columns: string[] = [];

  /**
   * Required. `key_set` identifies the rows to be yielded. `key_set` names the
   * primary keys of the rows in [table][google.spanner.v1.ReadRequest.table] to be yielded, unless [index][google.spanner.v1.ReadRequest.index]
   * is present. If [index][google.spanner.v1.ReadRequest.index] is present, then [key_set][google.spanner.v1.ReadRequest.key_set] instead names
   * index keys in [index][google.spanner.v1.ReadRequest.index].
   *
   * Rows are yielded in table primary key order (if [index][google.spanner.v1.ReadRequest.index] is empty)
   * or index key order (if [index][google.spanner.v1.ReadRequest.index] is non-empty).
   *
   * It is not an error for the `key_set` to name rows that do not
   * exist in the database. Read yields nothing for nonexistent rows.
   *
   * @generated from field: google.spanner.v1.KeySet key_set = 6;
   */
  keySet?: KeySet;

  /**
   * If greater than zero, only the first `limit` rows are yielded. If `limit`
   * is zero, the default is no limit.
   *
   * @generated from field: int64 limit = 8;
   */
  limit = protoInt64.zero;

  /**
   * If this request is resuming a previously interrupted read,
   * `resume_token` should be copied from the last
   * [PartialResultSet][google.spanner.v1.PartialResultSet] yielded before the interruption. Doing this
   * enables the new read to resume where the last read left off. The
   * rest of the request parameters must exactly match the request
   * that yielded this token.
   *
   * @generated from field: bytes resume_token = 9;
   */
  resumeToken = new Uint8Array(0);

  constructor(data?: PartialMessage<ReadRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.v1.ReadRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "session", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "transaction", kind: "message", T: TransactionSelector },
    { no: 3, name: "table", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "index", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "columns", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "key_set", kind: "message", T: KeySet },
    { no: 8, name: "limit", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 9, name: "resume_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadRequest {
    return new ReadRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadRequest {
    return new ReadRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadRequest {
    return new ReadRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReadRequest | PlainMessage<ReadRequest> | undefined, b: ReadRequest | PlainMessage<ReadRequest> | undefined): boolean {
    return proto3.util.equals(ReadRequest, a, b);
  }
}

/**
 * The request for [BeginTransaction][google.spanner.v1.Spanner.BeginTransaction].
 *
 * @generated from message google.spanner.v1.BeginTransactionRequest
 */
export class BeginTransactionRequest extends Message<BeginTransactionRequest> {
  /**
   * Required. The session in which the transaction runs.
   *
   * @generated from field: string session = 1;
   */
  session = "";

  /**
   * Required. Options for the new transaction.
   *
   * @generated from field: google.spanner.v1.TransactionOptions options = 2;
   */
  options?: TransactionOptions;

  constructor(data?: PartialMessage<BeginTransactionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.v1.BeginTransactionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "session", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "options", kind: "message", T: TransactionOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BeginTransactionRequest {
    return new BeginTransactionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BeginTransactionRequest {
    return new BeginTransactionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BeginTransactionRequest {
    return new BeginTransactionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: BeginTransactionRequest | PlainMessage<BeginTransactionRequest> | undefined, b: BeginTransactionRequest | PlainMessage<BeginTransactionRequest> | undefined): boolean {
    return proto3.util.equals(BeginTransactionRequest, a, b);
  }
}

/**
 * The request for [Commit][google.spanner.v1.Spanner.Commit].
 *
 * @generated from message google.spanner.v1.CommitRequest
 */
export class CommitRequest extends Message<CommitRequest> {
  /**
   * Required. The session in which the transaction to be committed is running.
   *
   * @generated from field: string session = 1;
   */
  session = "";

  /**
   * Required. The transaction in which to commit.
   *
   * @generated from oneof google.spanner.v1.CommitRequest.transaction
   */
  transaction: {
    /**
     * Commit a previously-started transaction.
     *
     * @generated from field: bytes transaction_id = 2;
     */
    value: Uint8Array;
    case: "transactionId";
  } | {
    /**
     * Execute mutations in a temporary transaction. Note that unlike
     * commit of a previously-started transaction, commit with a
     * temporary transaction is non-idempotent. That is, if the
     * `CommitRequest` is sent to Cloud Spanner more than once (for
     * instance, due to retries in the application, or in the
     * transport library), it is possible that the mutations are
     * executed more than once. If this is undesirable, use
     * [BeginTransaction][google.spanner.v1.Spanner.BeginTransaction] and
     * [Commit][google.spanner.v1.Spanner.Commit] instead.
     *
     * @generated from field: google.spanner.v1.TransactionOptions single_use_transaction = 3;
     */
    value: TransactionOptions;
    case: "singleUseTransaction";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The mutations to be executed when this transaction commits. All
   * mutations are applied atomically, in the order they appear in
   * this list.
   *
   * @generated from field: repeated google.spanner.v1.Mutation mutations = 4;
   */
  mutations: Mutation[] = [];

  constructor(data?: PartialMessage<CommitRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.v1.CommitRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "session", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "transaction_id", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "transaction" },
    { no: 3, name: "single_use_transaction", kind: "message", T: TransactionOptions, oneof: "transaction" },
    { no: 4, name: "mutations", kind: "message", T: Mutation, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommitRequest {
    return new CommitRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommitRequest {
    return new CommitRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommitRequest {
    return new CommitRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CommitRequest | PlainMessage<CommitRequest> | undefined, b: CommitRequest | PlainMessage<CommitRequest> | undefined): boolean {
    return proto3.util.equals(CommitRequest, a, b);
  }
}

/**
 * The response for [Commit][google.spanner.v1.Spanner.Commit].
 *
 * @generated from message google.spanner.v1.CommitResponse
 */
export class CommitResponse extends Message<CommitResponse> {
  /**
   * The Cloud Spanner timestamp at which the transaction committed.
   *
   * @generated from field: google.protobuf.Timestamp commit_timestamp = 1;
   */
  commitTimestamp?: Timestamp;

  constructor(data?: PartialMessage<CommitResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.v1.CommitResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "commit_timestamp", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommitResponse {
    return new CommitResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommitResponse {
    return new CommitResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommitResponse {
    return new CommitResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CommitResponse | PlainMessage<CommitResponse> | undefined, b: CommitResponse | PlainMessage<CommitResponse> | undefined): boolean {
    return proto3.util.equals(CommitResponse, a, b);
  }
}

/**
 * The request for [Rollback][google.spanner.v1.Spanner.Rollback].
 *
 * @generated from message google.spanner.v1.RollbackRequest
 */
export class RollbackRequest extends Message<RollbackRequest> {
  /**
   * Required. The session in which the transaction to roll back is running.
   *
   * @generated from field: string session = 1;
   */
  session = "";

  /**
   * Required. The transaction to roll back.
   *
   * @generated from field: bytes transaction_id = 2;
   */
  transactionId = new Uint8Array(0);

  constructor(data?: PartialMessage<RollbackRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.spanner.v1.RollbackRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "session", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "transaction_id", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RollbackRequest {
    return new RollbackRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RollbackRequest {
    return new RollbackRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RollbackRequest {
    return new RollbackRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RollbackRequest | PlainMessage<RollbackRequest> | undefined, b: RollbackRequest | PlainMessage<RollbackRequest> | undefined): boolean {
    return proto3.util.equals(RollbackRequest, a, b);
  }
}

