// Copyright 2016 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/monitoring/v3/common.proto (package google.monitoring.v3, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { Distribution } from "../../api/distribution_pb.js";

/**
 * A single strongly-typed value.
 *
 * @generated from message google.monitoring.v3.TypedValue
 */
export class TypedValue extends Message<TypedValue> {
  /**
   * The typed value field.
   *
   * @generated from oneof google.monitoring.v3.TypedValue.value
   */
  value: {
    /**
     * A Boolean value: `true` or `false`.
     *
     * @generated from field: bool bool_value = 1;
     */
    value: boolean;
    case: "boolValue";
  } | {
    /**
     * A 64-bit integer. Its range is approximately &plusmn;9.2x10<sup>18</sup>.
     *
     * @generated from field: int64 int64_value = 2;
     */
    value: bigint;
    case: "int64Value";
  } | {
    /**
     * A 64-bit double-precision floating-point number. Its magnitude
     * is approximately &plusmn;10<sup>&plusmn;300</sup> and it has 16
     * significant digits of precision.
     *
     * @generated from field: double double_value = 3;
     */
    value: number;
    case: "doubleValue";
  } | {
    /**
     * A variable-length string value.
     *
     * @generated from field: string string_value = 4;
     */
    value: string;
    case: "stringValue";
  } | {
    /**
     * A distribution value.
     *
     * @generated from field: google.api.Distribution distribution_value = 5;
     */
    value: Distribution;
    case: "distributionValue";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<TypedValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.TypedValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bool_value", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "value" },
    { no: 2, name: "int64_value", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "value" },
    { no: 3, name: "double_value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, oneof: "value" },
    { no: 4, name: "string_value", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "value" },
    { no: 5, name: "distribution_value", kind: "message", T: Distribution, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TypedValue {
    return new TypedValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TypedValue {
    return new TypedValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TypedValue {
    return new TypedValue().fromJsonString(jsonString, options);
  }

  static equals(a: TypedValue | PlainMessage<TypedValue> | undefined, b: TypedValue | PlainMessage<TypedValue> | undefined): boolean {
    return proto3.util.equals(TypedValue, a, b);
  }
}

/**
 * A time interval extending just after a start time through an end time.
 * If the start time is the same as the end time, then the interval
 * represents a single point in time.
 *
 * @generated from message google.monitoring.v3.TimeInterval
 */
export class TimeInterval extends Message<TimeInterval> {
  /**
   * Required. The end of the time interval.
   *
   * @generated from field: google.protobuf.Timestamp end_time = 2;
   */
  endTime?: Timestamp;

  /**
   * Optional. The beginning of the time interval.  The default value
   * for the start time is the end time. The start time must not be
   * later than the end time.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 1;
   */
  startTime?: Timestamp;

  constructor(data?: PartialMessage<TimeInterval>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.TimeInterval";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "end_time", kind: "message", T: Timestamp },
    { no: 1, name: "start_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TimeInterval {
    return new TimeInterval().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TimeInterval {
    return new TimeInterval().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TimeInterval {
    return new TimeInterval().fromJsonString(jsonString, options);
  }

  static equals(a: TimeInterval | PlainMessage<TimeInterval> | undefined, b: TimeInterval | PlainMessage<TimeInterval> | undefined): boolean {
    return proto3.util.equals(TimeInterval, a, b);
  }
}

/**
 * Describes how to combine multiple time series to provide different views of
 * the data.  Aggregation consists of an alignment step on individual time
 * series (`per_series_aligner`) followed by an optional reduction of the data
 * across different time series (`cross_series_reducer`).  For more details, see
 * [Aggregation](/monitoring/api/learn_more#aggregation).
 *
 * @generated from message google.monitoring.v3.Aggregation
 */
export class Aggregation extends Message<Aggregation> {
  /**
   * The alignment period for per-[time series][google.monitoring.v3.TimeSeries]
   * alignment. If present, `alignmentPeriod` must be at least 60
   * seconds.  After per-time series alignment, each time series will
   * contain data points only on the period boundaries. If
   * `perSeriesAligner` is not specified or equals `ALIGN_NONE`, then
   * this field is ignored. If `perSeriesAligner` is specified and
   * does not equal `ALIGN_NONE`, then this field must be defined;
   * otherwise an error is returned.
   *
   * @generated from field: google.protobuf.Duration alignment_period = 1;
   */
  alignmentPeriod?: Duration;

  /**
   * The approach to be used to align individual time series. Not all
   * alignment functions may be applied to all time series, depending
   * on the metric type and value type of the original time
   * series. Alignment may change the metric type or the value type of
   * the time series.
   *
   * Time series data must be aligned in order to perform cross-time
   * series reduction. If `crossSeriesReducer` is specified, then
   * `perSeriesAligner` must be specified and not equal `ALIGN_NONE`
   * and `alignmentPeriod` must be specified; otherwise, an error is
   * returned.
   *
   * @generated from field: google.monitoring.v3.Aggregation.Aligner per_series_aligner = 2;
   */
  perSeriesAligner = Aggregation_Aligner.ALIGN_NONE;

  /**
   * The approach to be used to combine time series. Not all reducer
   * functions may be applied to all time series, depending on the
   * metric type and the value type of the original time
   * series. Reduction may change the metric type of value type of the
   * time series.
   *
   * Time series data must be aligned in order to perform cross-time
   * series reduction. If `crossSeriesReducer` is specified, then
   * `perSeriesAligner` must be specified and not equal `ALIGN_NONE`
   * and `alignmentPeriod` must be specified; otherwise, an error is
   * returned.
   *
   * @generated from field: google.monitoring.v3.Aggregation.Reducer cross_series_reducer = 4;
   */
  crossSeriesReducer = Aggregation_Reducer.REDUCE_NONE;

  /**
   * The set of fields to preserve when `crossSeriesReducer` is
   * specified. The `groupByFields` determine how the time series are
   * partitioned into subsets prior to applying the aggregation
   * function. Each subset contains time series that have the same
   * value for each of the grouping fields. Each individual time
   * series is a member of exactly one subset. The
   * `crossSeriesReducer` is applied to each subset of time series.
   * It is not possible to reduce across different resource types, so
   * this field implicitly contains `resource.type`.  Fields not
   * specified in `groupByFields` are aggregated away.  If
   * `groupByFields` is not specified and all the time series have
   * the same resource type, then the time series are aggregated into
   * a single output time series. If `crossSeriesReducer` is not
   * defined, this field is ignored.
   *
   * @generated from field: repeated string group_by_fields = 5;
   */
  groupByFields: string[] = [];

  constructor(data?: PartialMessage<Aggregation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.monitoring.v3.Aggregation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "alignment_period", kind: "message", T: Duration },
    { no: 2, name: "per_series_aligner", kind: "enum", T: proto3.getEnumType(Aggregation_Aligner) },
    { no: 4, name: "cross_series_reducer", kind: "enum", T: proto3.getEnumType(Aggregation_Reducer) },
    { no: 5, name: "group_by_fields", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Aggregation {
    return new Aggregation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Aggregation {
    return new Aggregation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Aggregation {
    return new Aggregation().fromJsonString(jsonString, options);
  }

  static equals(a: Aggregation | PlainMessage<Aggregation> | undefined, b: Aggregation | PlainMessage<Aggregation> | undefined): boolean {
    return proto3.util.equals(Aggregation, a, b);
  }
}

/**
 * The Aligner describes how to bring the data points in a single
 * time series into temporal alignment.
 *
 * @generated from enum google.monitoring.v3.Aggregation.Aligner
 */
export enum Aggregation_Aligner {
  /**
   * No alignment. Raw data is returned. Not valid if cross-time
   * series reduction is requested. The value type of the result is
   * the same as the value type of the input.
   *
   * @generated from enum value: ALIGN_NONE = 0;
   */
  ALIGN_NONE = 0,

  /**
   * Align and convert to delta metric type. This alignment is valid
   * for cumulative metrics and delta metrics. Aligning an existing
   * delta metric to a delta metric requires that the alignment
   * period be increased. The value type of the result is the same
   * as the value type of the input.
   *
   * @generated from enum value: ALIGN_DELTA = 1;
   */
  ALIGN_DELTA = 1,

  /**
   * Align and convert to a rate. This alignment is valid for
   * cumulative metrics and delta metrics with numeric values. The output is a
   * gauge metric with value type
   * [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
   *
   * @generated from enum value: ALIGN_RATE = 2;
   */
  ALIGN_RATE = 2,

  /**
   * Align by interpolating between adjacent points around the
   * period boundary. This alignment is valid for gauge
   * metrics with numeric values. The value type of the result is the same
   * as the value type of the input.
   *
   * @generated from enum value: ALIGN_INTERPOLATE = 3;
   */
  ALIGN_INTERPOLATE = 3,

  /**
   * Align by shifting the oldest data point before the period
   * boundary to the boundary. This alignment is valid for gauge
   * metrics. The value type of the result is the same as the
   * value type of the input.
   *
   * @generated from enum value: ALIGN_NEXT_OLDER = 4;
   */
  ALIGN_NEXT_OLDER = 4,

  /**
   * Align time series via aggregation. The resulting data point in
   * the alignment period is the minimum of all data points in the
   * period. This alignment is valid for gauge and delta metrics with numeric
   * values. The value type of the result is the same as the value
   * type of the input.
   *
   * @generated from enum value: ALIGN_MIN = 10;
   */
  ALIGN_MIN = 10,

  /**
   * Align time series via aggregation. The resulting data point in
   * the alignment period is the maximum of all data points in the
   * period. This alignment is valid for gauge and delta metrics with numeric
   * values. The value type of the result is the same as the value
   * type of the input.
   *
   * @generated from enum value: ALIGN_MAX = 11;
   */
  ALIGN_MAX = 11,

  /**
   * Align time series via aggregation. The resulting data point in
   * the alignment period is the average or arithmetic mean of all
   * data points in the period. This alignment is valid for gauge and delta
   * metrics with numeric values. The value type of the output is
   * [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
   *
   * @generated from enum value: ALIGN_MEAN = 12;
   */
  ALIGN_MEAN = 12,

  /**
   * Align time series via aggregation. The resulting data point in
   * the alignment period is the count of all data points in the
   * period. This alignment is valid for gauge and delta metrics with numeric
   * or Boolean values. The value type of the output is
   * [INT64][google.api.MetricDescriptor.ValueType.INT64].
   *
   * @generated from enum value: ALIGN_COUNT = 13;
   */
  ALIGN_COUNT = 13,

  /**
   * Align time series via aggregation. The resulting data point in
   * the alignment period is the sum of all data points in the
   * period. This alignment is valid for gauge and delta metrics with numeric
   * and distribution values. The value type of the output is the
   * same as the value type of the input.
   *
   * @generated from enum value: ALIGN_SUM = 14;
   */
  ALIGN_SUM = 14,

  /**
   * Align time series via aggregation. The resulting data point in
   * the alignment period is the standard deviation of all data
   * points in the period. This alignment is valid for gauge and delta metrics
   * with numeric values. The value type of the output is
   * [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
   *
   * @generated from enum value: ALIGN_STDDEV = 15;
   */
  ALIGN_STDDEV = 15,

  /**
   * Align time series via aggregation. The resulting data point in
   * the alignment period is the count of True-valued data points in the
   * period. This alignment is valid for gauge metrics with
   * Boolean values. The value type of the output is
   * [INT64][google.api.MetricDescriptor.ValueType.INT64].
   *
   * @generated from enum value: ALIGN_COUNT_TRUE = 16;
   */
  ALIGN_COUNT_TRUE = 16,

  /**
   * Align time series via aggregation. The resulting data point in
   * the alignment period is the fraction of True-valued data points in the
   * period. This alignment is valid for gauge metrics with Boolean values.
   * The output value is in the range [0, 1] and has value type
   * [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
   *
   * @generated from enum value: ALIGN_FRACTION_TRUE = 17;
   */
  ALIGN_FRACTION_TRUE = 17,

  /**
   * Align time series via aggregation. The resulting data point in
   * the alignment period is the 99th percentile of all data
   * points in the period. This alignment is valid for gauge and delta metrics
   * with distribution values. The output is a gauge metric with value type
   * [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
   *
   * @generated from enum value: ALIGN_PERCENTILE_99 = 18;
   */
  ALIGN_PERCENTILE_99 = 18,

  /**
   * Align time series via aggregation. The resulting data point in
   * the alignment period is the 95th percentile of all data
   * points in the period. This alignment is valid for gauge and delta metrics
   * with distribution values. The output is a gauge metric with value type
   * [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
   *
   * @generated from enum value: ALIGN_PERCENTILE_95 = 19;
   */
  ALIGN_PERCENTILE_95 = 19,

  /**
   * Align time series via aggregation. The resulting data point in
   * the alignment period is the 50th percentile of all data
   * points in the period. This alignment is valid for gauge and delta metrics
   * with distribution values. The output is a gauge metric with value type
   * [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
   *
   * @generated from enum value: ALIGN_PERCENTILE_50 = 20;
   */
  ALIGN_PERCENTILE_50 = 20,

  /**
   * Align time series via aggregation. The resulting data point in
   * the alignment period is the 5th percentile of all data
   * points in the period. This alignment is valid for gauge and delta metrics
   * with distribution values. The output is a gauge metric with value type
   * [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
   *
   * @generated from enum value: ALIGN_PERCENTILE_05 = 21;
   */
  ALIGN_PERCENTILE_05 = 21,
}
// Retrieve enum metadata with: proto3.getEnumType(Aggregation_Aligner)
proto3.util.setEnumType(Aggregation_Aligner, "google.monitoring.v3.Aggregation.Aligner", [
  { no: 0, name: "ALIGN_NONE" },
  { no: 1, name: "ALIGN_DELTA" },
  { no: 2, name: "ALIGN_RATE" },
  { no: 3, name: "ALIGN_INTERPOLATE" },
  { no: 4, name: "ALIGN_NEXT_OLDER" },
  { no: 10, name: "ALIGN_MIN" },
  { no: 11, name: "ALIGN_MAX" },
  { no: 12, name: "ALIGN_MEAN" },
  { no: 13, name: "ALIGN_COUNT" },
  { no: 14, name: "ALIGN_SUM" },
  { no: 15, name: "ALIGN_STDDEV" },
  { no: 16, name: "ALIGN_COUNT_TRUE" },
  { no: 17, name: "ALIGN_FRACTION_TRUE" },
  { no: 18, name: "ALIGN_PERCENTILE_99" },
  { no: 19, name: "ALIGN_PERCENTILE_95" },
  { no: 20, name: "ALIGN_PERCENTILE_50" },
  { no: 21, name: "ALIGN_PERCENTILE_05" },
]);

/**
 * A Reducer describes how to aggregate data points from multiple
 * time series into a single time series.
 *
 * @generated from enum google.monitoring.v3.Aggregation.Reducer
 */
export enum Aggregation_Reducer {
  /**
   * No cross-time series reduction. The output of the aligner is
   * returned.
   *
   * @generated from enum value: REDUCE_NONE = 0;
   */
  REDUCE_NONE = 0,

  /**
   * Reduce by computing the mean across time series for each
   * alignment period. This reducer is valid for delta and
   * gauge metrics with numeric or distribution values. The value type of the
   * output is [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
   *
   * @generated from enum value: REDUCE_MEAN = 1;
   */
  REDUCE_MEAN = 1,

  /**
   * Reduce by computing the minimum across time series for each
   * alignment period. This reducer is valid for delta and
   * gauge metrics with numeric values. The value type of the output
   * is the same as the value type of the input.
   *
   * @generated from enum value: REDUCE_MIN = 2;
   */
  REDUCE_MIN = 2,

  /**
   * Reduce by computing the maximum across time series for each
   * alignment period. This reducer is valid for delta and
   * gauge metrics with numeric values. The value type of the output
   * is the same as the value type of the input.
   *
   * @generated from enum value: REDUCE_MAX = 3;
   */
  REDUCE_MAX = 3,

  /**
   * Reduce by computing the sum across time series for each
   * alignment period. This reducer is valid for delta and
   * gauge metrics with numeric and distribution values. The value type of
   * the output is the same as the value type of the input.
   *
   * @generated from enum value: REDUCE_SUM = 4;
   */
  REDUCE_SUM = 4,

  /**
   * Reduce by computing the standard deviation across time series
   * for each alignment period. This reducer is valid for delta
   * and gauge metrics with numeric or distribution values. The value type of
   * the output is [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
   *
   * @generated from enum value: REDUCE_STDDEV = 5;
   */
  REDUCE_STDDEV = 5,

  /**
   * Reduce by computing the count of data points across time series
   * for each alignment period. This reducer is valid for delta
   * and gauge metrics of numeric, Boolean, distribution, and string value
   * type. The value type of the output is
   * [INT64][google.api.MetricDescriptor.ValueType.INT64].
   *
   * @generated from enum value: REDUCE_COUNT = 6;
   */
  REDUCE_COUNT = 6,

  /**
   * Reduce by computing the count of True-valued data points across time
   * series for each alignment period. This reducer is valid for delta
   * and gauge metrics of Boolean value type. The value type of
   * the output is [INT64][google.api.MetricDescriptor.ValueType.INT64].
   *
   * @generated from enum value: REDUCE_COUNT_TRUE = 7;
   */
  REDUCE_COUNT_TRUE = 7,

  /**
   * Reduce by computing the fraction of True-valued data points across time
   * series for each alignment period. This reducer is valid for delta
   * and gauge metrics of Boolean value type. The output value is in the
   * range [0, 1] and has value type
   * [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
   *
   * @generated from enum value: REDUCE_FRACTION_TRUE = 8;
   */
  REDUCE_FRACTION_TRUE = 8,

  /**
   * Reduce by computing 99th percentile of data points across time series
   * for each alignment period. This reducer is valid for gauge and delta
   * metrics of numeric and distribution type. The value of the output is
   * [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE]
   *
   * @generated from enum value: REDUCE_PERCENTILE_99 = 9;
   */
  REDUCE_PERCENTILE_99 = 9,

  /**
   * Reduce by computing 95th percentile of data points across time series
   * for each alignment period. This reducer is valid for gauge and delta
   * metrics of numeric and distribution type. The value of the output is
   * [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE]
   *
   * @generated from enum value: REDUCE_PERCENTILE_95 = 10;
   */
  REDUCE_PERCENTILE_95 = 10,

  /**
   * Reduce by computing 50th percentile of data points across time series
   * for each alignment period. This reducer is valid for gauge and delta
   * metrics of numeric and distribution type. The value of the output is
   * [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE]
   *
   * @generated from enum value: REDUCE_PERCENTILE_50 = 11;
   */
  REDUCE_PERCENTILE_50 = 11,

  /**
   * Reduce by computing 5th percentile of data points across time series
   * for each alignment period. This reducer is valid for gauge and delta
   * metrics of numeric and distribution type. The value of the output is
   * [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE]
   *
   * @generated from enum value: REDUCE_PERCENTILE_05 = 12;
   */
  REDUCE_PERCENTILE_05 = 12,
}
// Retrieve enum metadata with: proto3.getEnumType(Aggregation_Reducer)
proto3.util.setEnumType(Aggregation_Reducer, "google.monitoring.v3.Aggregation.Reducer", [
  { no: 0, name: "REDUCE_NONE" },
  { no: 1, name: "REDUCE_MEAN" },
  { no: 2, name: "REDUCE_MIN" },
  { no: 3, name: "REDUCE_MAX" },
  { no: 4, name: "REDUCE_SUM" },
  { no: 5, name: "REDUCE_STDDEV" },
  { no: 6, name: "REDUCE_COUNT" },
  { no: 7, name: "REDUCE_COUNT_TRUE" },
  { no: 8, name: "REDUCE_FRACTION_TRUE" },
  { no: 9, name: "REDUCE_PERCENTILE_99" },
  { no: 10, name: "REDUCE_PERCENTILE_95" },
  { no: 11, name: "REDUCE_PERCENTILE_50" },
  { no: 12, name: "REDUCE_PERCENTILE_05" },
]);

