// Copyright 2016 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/genomics/v1/annotations.proto (package google.genomics.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { FieldMask, Int32Value, ListValue, Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Status } from "../../rpc/status_pb.js";

/**
 * When an [Annotation][google.genomics.v1.Annotation] or
 * [AnnotationSet][google.genomics.v1.AnnotationSet] is created, if `type` is
 * not specified it will be set to `GENERIC`.
 *
 * @generated from enum google.genomics.v1.AnnotationType
 */
export enum AnnotationType {
  /**
   * @generated from enum value: ANNOTATION_TYPE_UNSPECIFIED = 0;
   */
  ANNOTATION_TYPE_UNSPECIFIED = 0,

  /**
   * A `GENERIC` annotation type should be used when no other annotation
   * type will suffice. This represents an untyped annotation of the reference
   * genome.
   *
   * @generated from enum value: GENERIC = 1;
   */
  GENERIC = 1,

  /**
   * A `VARIANT` annotation type.
   *
   * @generated from enum value: VARIANT = 2;
   */
  VARIANT = 2,

  /**
   * A `GENE` annotation type represents the existence of a gene at the
   * associated reference coordinates. The start coordinate is typically the
   * gene's transcription start site and the end is typically the end of the
   * gene's last exon.
   *
   * @generated from enum value: GENE = 3;
   */
  GENE = 3,

  /**
   * A `TRANSCRIPT` annotation type represents the assertion that a
   * particular region of the reference genome may be transcribed as RNA.
   *
   * @generated from enum value: TRANSCRIPT = 4;
   */
  TRANSCRIPT = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(AnnotationType)
proto3.util.setEnumType(AnnotationType, "google.genomics.v1.AnnotationType", [
  { no: 0, name: "ANNOTATION_TYPE_UNSPECIFIED" },
  { no: 1, name: "GENERIC" },
  { no: 2, name: "VARIANT" },
  { no: 3, name: "GENE" },
  { no: 4, name: "TRANSCRIPT" },
]);

/**
 * An annotation set is a logical grouping of annotations that share consistent
 * type information and provenance. Examples of annotation sets include 'all
 * genes from refseq', and 'all variant annotations from ClinVar'.
 *
 * @generated from message google.genomics.v1.AnnotationSet
 */
export class AnnotationSet extends Message<AnnotationSet> {
  /**
   * The server-generated annotation set ID, unique across all annotation sets.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The dataset to which this annotation set belongs.
   *
   * @generated from field: string dataset_id = 2;
   */
  datasetId = "";

  /**
   * The ID of the reference set that defines the coordinate space for this
   * set's annotations.
   *
   * @generated from field: string reference_set_id = 3;
   */
  referenceSetId = "";

  /**
   * The display name for this annotation set.
   *
   * @generated from field: string name = 4;
   */
  name = "";

  /**
   * The source URI describing the file from which this annotation set was
   * generated, if any.
   *
   * @generated from field: string source_uri = 5;
   */
  sourceUri = "";

  /**
   * The type of annotations contained within this set.
   *
   * @generated from field: google.genomics.v1.AnnotationType type = 6;
   */
  type = AnnotationType.ANNOTATION_TYPE_UNSPECIFIED;

  /**
   * A map of additional read alignment information. This must be of the form
   * map<string, string[]> (string key mapping to a list of string values).
   *
   * @generated from field: map<string, google.protobuf.ListValue> info = 17;
   */
  info: { [key: string]: ListValue } = {};

  constructor(data?: PartialMessage<AnnotationSet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.AnnotationSet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "dataset_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "reference_set_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "source_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "type", kind: "enum", T: proto3.getEnumType(AnnotationType) },
    { no: 17, name: "info", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: ListValue} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnnotationSet {
    return new AnnotationSet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnnotationSet {
    return new AnnotationSet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnnotationSet {
    return new AnnotationSet().fromJsonString(jsonString, options);
  }

  static equals(a: AnnotationSet | PlainMessage<AnnotationSet> | undefined, b: AnnotationSet | PlainMessage<AnnotationSet> | undefined): boolean {
    return proto3.util.equals(AnnotationSet, a, b);
  }
}

/**
 * An annotation describes a region of reference genome. The value of an
 * annotation may be one of several canonical types, supplemented by arbitrary
 * info tags. An annotation is not inherently associated with a specific
 * sample or individual (though a client could choose to use annotations in
 * this way). Example canonical annotation types are `GENE` and
 * `VARIANT`.
 *
 * @generated from message google.genomics.v1.Annotation
 */
export class Annotation extends Message<Annotation> {
  /**
   * The server-generated annotation ID, unique across all annotations.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * The annotation set to which this annotation belongs.
   *
   * @generated from field: string annotation_set_id = 2;
   */
  annotationSetId = "";

  /**
   * The display name of this annotation.
   *
   * @generated from field: string name = 3;
   */
  name = "";

  /**
   * The ID of the Google Genomics reference associated with this range.
   *
   * @generated from field: string reference_id = 4;
   */
  referenceId = "";

  /**
   * The display name corresponding to the reference specified by
   * `referenceId`, for example `chr1`, `1`, or `chrX`.
   *
   * @generated from field: string reference_name = 5;
   */
  referenceName = "";

  /**
   * The start position of the range on the reference, 0-based inclusive.
   *
   * @generated from field: int64 start = 6;
   */
  start = protoInt64.zero;

  /**
   * The end position of the range on the reference, 0-based exclusive.
   *
   * @generated from field: int64 end = 7;
   */
  end = protoInt64.zero;

  /**
   * Whether this range refers to the reverse strand, as opposed to the forward
   * strand. Note that regardless of this field, the start/end position of the
   * range always refer to the forward strand.
   *
   * @generated from field: bool reverse_strand = 8;
   */
  reverseStrand = false;

  /**
   * The data type for this annotation. Must match the containing annotation
   * set's type.
   *
   * @generated from field: google.genomics.v1.AnnotationType type = 9;
   */
  type = AnnotationType.ANNOTATION_TYPE_UNSPECIFIED;

  /**
   * @generated from oneof google.genomics.v1.Annotation.value
   */
  value: {
    /**
     * A variant annotation, which describes the effect of a variant on the
     * genome, the coding sequence, and/or higher level consequences at the
     * organism level e.g. pathogenicity. This field is only set for annotations
     * of type `VARIANT`.
     *
     * @generated from field: google.genomics.v1.VariantAnnotation variant = 10;
     */
    value: VariantAnnotation;
    case: "variant";
  } | {
    /**
     * A transcript value represents the assertion that a particular region of
     * the reference genome may be transcribed as RNA. An alternative splicing
     * pattern would be represented as a separate transcript object. This field
     * is only set for annotations of type `TRANSCRIPT`.
     *
     * @generated from field: google.genomics.v1.Transcript transcript = 11;
     */
    value: Transcript;
    case: "transcript";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * A map of additional read alignment information. This must be of the form
   * map<string, string[]> (string key mapping to a list of string values).
   *
   * @generated from field: map<string, google.protobuf.ListValue> info = 12;
   */
  info: { [key: string]: ListValue } = {};

  constructor(data?: PartialMessage<Annotation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.Annotation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "annotation_set_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "reference_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "reference_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "start", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "end", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 8, name: "reverse_strand", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "type", kind: "enum", T: proto3.getEnumType(AnnotationType) },
    { no: 10, name: "variant", kind: "message", T: VariantAnnotation, oneof: "value" },
    { no: 11, name: "transcript", kind: "message", T: Transcript, oneof: "value" },
    { no: 12, name: "info", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: ListValue} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Annotation {
    return new Annotation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Annotation {
    return new Annotation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Annotation {
    return new Annotation().fromJsonString(jsonString, options);
  }

  static equals(a: Annotation | PlainMessage<Annotation> | undefined, b: Annotation | PlainMessage<Annotation> | undefined): boolean {
    return proto3.util.equals(Annotation, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.VariantAnnotation
 */
export class VariantAnnotation extends Message<VariantAnnotation> {
  /**
   * Type has been adapted from ClinVar's list of variant types.
   *
   * @generated from field: google.genomics.v1.VariantAnnotation.Type type = 1;
   */
  type = VariantAnnotation_Type.TYPE_UNSPECIFIED;

  /**
   * Effect of the variant on the coding sequence.
   *
   * @generated from field: google.genomics.v1.VariantAnnotation.Effect effect = 2;
   */
  effect = VariantAnnotation_Effect.EFFECT_UNSPECIFIED;

  /**
   * The alternate allele for this variant. If multiple alternate alleles
   * exist at this location, create a separate variant for each one, as they
   * may represent distinct conditions.
   *
   * @generated from field: string alternate_bases = 3;
   */
  alternateBases = "";

  /**
   * Google annotation ID of the gene affected by this variant. This should
   * be provided when the variant is created.
   *
   * @generated from field: string gene_id = 4;
   */
  geneId = "";

  /**
   * Google annotation IDs of the transcripts affected by this variant. These
   * should be provided when the variant is created.
   *
   * @generated from field: repeated string transcript_ids = 5;
   */
  transcriptIds: string[] = [];

  /**
   * The set of conditions associated with this variant.
   * A condition describes the way a variant influences human health.
   *
   * @generated from field: repeated google.genomics.v1.VariantAnnotation.ClinicalCondition conditions = 6;
   */
  conditions: VariantAnnotation_ClinicalCondition[] = [];

  /**
   * Describes the clinical significance of a variant.
   * It is adapted from the ClinVar controlled vocabulary for clinical
   * significance described at:
   * http://www.ncbi.nlm.nih.gov/clinvar/docs/clinsig/
   *
   * @generated from field: google.genomics.v1.VariantAnnotation.ClinicalSignificance clinical_significance = 7;
   */
  clinicalSignificance = VariantAnnotation_ClinicalSignificance.CLINICAL_SIGNIFICANCE_UNSPECIFIED;

  constructor(data?: PartialMessage<VariantAnnotation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.VariantAnnotation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(VariantAnnotation_Type) },
    { no: 2, name: "effect", kind: "enum", T: proto3.getEnumType(VariantAnnotation_Effect) },
    { no: 3, name: "alternate_bases", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "gene_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "transcript_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "conditions", kind: "message", T: VariantAnnotation_ClinicalCondition, repeated: true },
    { no: 7, name: "clinical_significance", kind: "enum", T: proto3.getEnumType(VariantAnnotation_ClinicalSignificance) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VariantAnnotation {
    return new VariantAnnotation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VariantAnnotation {
    return new VariantAnnotation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VariantAnnotation {
    return new VariantAnnotation().fromJsonString(jsonString, options);
  }

  static equals(a: VariantAnnotation | PlainMessage<VariantAnnotation> | undefined, b: VariantAnnotation | PlainMessage<VariantAnnotation> | undefined): boolean {
    return proto3.util.equals(VariantAnnotation, a, b);
  }
}

/**
 * @generated from enum google.genomics.v1.VariantAnnotation.Type
 */
export enum VariantAnnotation_Type {
  /**
   * @generated from enum value: TYPE_UNSPECIFIED = 0;
   */
  TYPE_UNSPECIFIED = 0,

  /**
   * `TYPE_OTHER` should be used when no other Type will suffice.
   * Further explanation of the variant type may be included in the
   * [info][google.genomics.v1.Annotation.info] field.
   *
   * @generated from enum value: TYPE_OTHER = 1;
   */
  TYPE_OTHER = 1,

  /**
   * `INSERTION` indicates an insertion.
   *
   * @generated from enum value: INSERTION = 2;
   */
  INSERTION = 2,

  /**
   * `DELETION` indicates a deletion.
   *
   * @generated from enum value: DELETION = 3;
   */
  DELETION = 3,

  /**
   * `SUBSTITUTION` indicates a block substitution of
   * two or more nucleotides.
   *
   * @generated from enum value: SUBSTITUTION = 4;
   */
  SUBSTITUTION = 4,

  /**
   * `SNP` indicates a single nucleotide polymorphism.
   *
   * @generated from enum value: SNP = 5;
   */
  SNP = 5,

  /**
   * `STRUCTURAL` indicates a large structural variant,
   * including chromosomal fusions, inversions, etc.
   *
   * @generated from enum value: STRUCTURAL = 6;
   */
  STRUCTURAL = 6,

  /**
   * `CNV` indicates a variation in copy number.
   *
   * @generated from enum value: CNV = 7;
   */
  CNV = 7,
}
// Retrieve enum metadata with: proto3.getEnumType(VariantAnnotation_Type)
proto3.util.setEnumType(VariantAnnotation_Type, "google.genomics.v1.VariantAnnotation.Type", [
  { no: 0, name: "TYPE_UNSPECIFIED" },
  { no: 1, name: "TYPE_OTHER" },
  { no: 2, name: "INSERTION" },
  { no: 3, name: "DELETION" },
  { no: 4, name: "SUBSTITUTION" },
  { no: 5, name: "SNP" },
  { no: 6, name: "STRUCTURAL" },
  { no: 7, name: "CNV" },
]);

/**
 * @generated from enum google.genomics.v1.VariantAnnotation.Effect
 */
export enum VariantAnnotation_Effect {
  /**
   * @generated from enum value: EFFECT_UNSPECIFIED = 0;
   */
  EFFECT_UNSPECIFIED = 0,

  /**
   * `EFFECT_OTHER` should be used when no other Effect
   * will suffice.
   *
   * @generated from enum value: EFFECT_OTHER = 1;
   */
  EFFECT_OTHER = 1,

  /**
   * `FRAMESHIFT` indicates a mutation in which the insertion or
   * deletion of nucleotides resulted in a frameshift change.
   *
   * @generated from enum value: FRAMESHIFT = 2;
   */
  FRAMESHIFT = 2,

  /**
   * `FRAME_PRESERVING_INDEL` indicates a mutation in which a
   * multiple of three nucleotides has been inserted or deleted, resulting
   * in no change to the reading frame of the coding sequence.
   *
   * @generated from enum value: FRAME_PRESERVING_INDEL = 3;
   */
  FRAME_PRESERVING_INDEL = 3,

  /**
   * `SYNONYMOUS_SNP` indicates a single nucleotide polymorphism
   * mutation that results in no amino acid change.
   *
   * @generated from enum value: SYNONYMOUS_SNP = 4;
   */
  SYNONYMOUS_SNP = 4,

  /**
   * `NONSYNONYMOUS_SNP` indicates a single nucleotide
   * polymorphism mutation that results in an amino acid change.
   *
   * @generated from enum value: NONSYNONYMOUS_SNP = 5;
   */
  NONSYNONYMOUS_SNP = 5,

  /**
   * `STOP_GAIN` indicates a mutation that leads to the creation
   * of a stop codon at the variant site. Frameshift mutations creating
   * downstream stop codons do not count as `STOP_GAIN`.
   *
   * @generated from enum value: STOP_GAIN = 6;
   */
  STOP_GAIN = 6,

  /**
   * `STOP_LOSS` indicates a mutation that eliminates a
   * stop codon at the variant site.
   *
   * @generated from enum value: STOP_LOSS = 7;
   */
  STOP_LOSS = 7,

  /**
   * `SPLICE_SITE_DISRUPTION` indicates that this variant is
   * found in a splice site for the associated transcript, and alters the
   * normal splicing pattern.
   *
   * @generated from enum value: SPLICE_SITE_DISRUPTION = 8;
   */
  SPLICE_SITE_DISRUPTION = 8,
}
// Retrieve enum metadata with: proto3.getEnumType(VariantAnnotation_Effect)
proto3.util.setEnumType(VariantAnnotation_Effect, "google.genomics.v1.VariantAnnotation.Effect", [
  { no: 0, name: "EFFECT_UNSPECIFIED" },
  { no: 1, name: "EFFECT_OTHER" },
  { no: 2, name: "FRAMESHIFT" },
  { no: 3, name: "FRAME_PRESERVING_INDEL" },
  { no: 4, name: "SYNONYMOUS_SNP" },
  { no: 5, name: "NONSYNONYMOUS_SNP" },
  { no: 6, name: "STOP_GAIN" },
  { no: 7, name: "STOP_LOSS" },
  { no: 8, name: "SPLICE_SITE_DISRUPTION" },
]);

/**
 * @generated from enum google.genomics.v1.VariantAnnotation.ClinicalSignificance
 */
export enum VariantAnnotation_ClinicalSignificance {
  /**
   * @generated from enum value: CLINICAL_SIGNIFICANCE_UNSPECIFIED = 0;
   */
  CLINICAL_SIGNIFICANCE_UNSPECIFIED = 0,

  /**
   * `OTHER` should be used when no other clinical significance
   * value will suffice.
   *
   * @generated from enum value: CLINICAL_SIGNIFICANCE_OTHER = 1;
   */
  CLINICAL_SIGNIFICANCE_OTHER = 1,

  /**
   * @generated from enum value: UNCERTAIN = 2;
   */
  UNCERTAIN = 2,

  /**
   * @generated from enum value: BENIGN = 3;
   */
  BENIGN = 3,

  /**
   * @generated from enum value: LIKELY_BENIGN = 4;
   */
  LIKELY_BENIGN = 4,

  /**
   * @generated from enum value: LIKELY_PATHOGENIC = 5;
   */
  LIKELY_PATHOGENIC = 5,

  /**
   * @generated from enum value: PATHOGENIC = 6;
   */
  PATHOGENIC = 6,

  /**
   * @generated from enum value: DRUG_RESPONSE = 7;
   */
  DRUG_RESPONSE = 7,

  /**
   * @generated from enum value: HISTOCOMPATIBILITY = 8;
   */
  HISTOCOMPATIBILITY = 8,

  /**
   * @generated from enum value: CONFERS_SENSITIVITY = 9;
   */
  CONFERS_SENSITIVITY = 9,

  /**
   * @generated from enum value: RISK_FACTOR = 10;
   */
  RISK_FACTOR = 10,

  /**
   * @generated from enum value: ASSOCIATION = 11;
   */
  ASSOCIATION = 11,

  /**
   * @generated from enum value: PROTECTIVE = 12;
   */
  PROTECTIVE = 12,

  /**
   * `MULTIPLE_REPORTED` should be used when multiple clinical
   * signficances are reported for a variant. The original clinical
   * significance values may be provided in the `info` field.
   *
   * @generated from enum value: MULTIPLE_REPORTED = 13;
   */
  MULTIPLE_REPORTED = 13,
}
// Retrieve enum metadata with: proto3.getEnumType(VariantAnnotation_ClinicalSignificance)
proto3.util.setEnumType(VariantAnnotation_ClinicalSignificance, "google.genomics.v1.VariantAnnotation.ClinicalSignificance", [
  { no: 0, name: "CLINICAL_SIGNIFICANCE_UNSPECIFIED" },
  { no: 1, name: "CLINICAL_SIGNIFICANCE_OTHER" },
  { no: 2, name: "UNCERTAIN" },
  { no: 3, name: "BENIGN" },
  { no: 4, name: "LIKELY_BENIGN" },
  { no: 5, name: "LIKELY_PATHOGENIC" },
  { no: 6, name: "PATHOGENIC" },
  { no: 7, name: "DRUG_RESPONSE" },
  { no: 8, name: "HISTOCOMPATIBILITY" },
  { no: 9, name: "CONFERS_SENSITIVITY" },
  { no: 10, name: "RISK_FACTOR" },
  { no: 11, name: "ASSOCIATION" },
  { no: 12, name: "PROTECTIVE" },
  { no: 13, name: "MULTIPLE_REPORTED" },
]);

/**
 * @generated from message google.genomics.v1.VariantAnnotation.ClinicalCondition
 */
export class VariantAnnotation_ClinicalCondition extends Message<VariantAnnotation_ClinicalCondition> {
  /**
   * A set of names for the condition.
   *
   * @generated from field: repeated string names = 1;
   */
  names: string[] = [];

  /**
   * The set of external IDs for this condition.
   *
   * @generated from field: repeated google.genomics.v1.ExternalId external_ids = 2;
   */
  externalIds: ExternalId[] = [];

  /**
   * The MedGen concept id associated with this gene.
   * Search for these IDs at http://www.ncbi.nlm.nih.gov/medgen/
   *
   * @generated from field: string concept_id = 3;
   */
  conceptId = "";

  /**
   * The OMIM id for this condition.
   * Search for these IDs at http://omim.org/
   *
   * @generated from field: string omim_id = 4;
   */
  omimId = "";

  constructor(data?: PartialMessage<VariantAnnotation_ClinicalCondition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.VariantAnnotation.ClinicalCondition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "external_ids", kind: "message", T: ExternalId, repeated: true },
    { no: 3, name: "concept_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "omim_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VariantAnnotation_ClinicalCondition {
    return new VariantAnnotation_ClinicalCondition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VariantAnnotation_ClinicalCondition {
    return new VariantAnnotation_ClinicalCondition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VariantAnnotation_ClinicalCondition {
    return new VariantAnnotation_ClinicalCondition().fromJsonString(jsonString, options);
  }

  static equals(a: VariantAnnotation_ClinicalCondition | PlainMessage<VariantAnnotation_ClinicalCondition> | undefined, b: VariantAnnotation_ClinicalCondition | PlainMessage<VariantAnnotation_ClinicalCondition> | undefined): boolean {
    return proto3.util.equals(VariantAnnotation_ClinicalCondition, a, b);
  }
}

/**
 * A transcript represents the assertion that a particular region of the
 * reference genome may be transcribed as RNA.
 *
 * @generated from message google.genomics.v1.Transcript
 */
export class Transcript extends Message<Transcript> {
  /**
   * The annotation ID of the gene from which this transcript is transcribed.
   *
   * @generated from field: string gene_id = 1;
   */
  geneId = "";

  /**
   * The <a href="http://en.wikipedia.org/wiki/Exon">exons</a> that compose
   * this transcript. This field should be unset for genomes where transcript
   * splicing does not occur, for example prokaryotes.
   *
   * Introns are regions of the transcript that are not included in the
   * spliced RNA product. Though not explicitly modeled here, intron ranges can
   * be deduced; all regions of this transcript that are not exons are introns.
   *
   * Exonic sequences do not necessarily code for a translational product
   * (amino acids). Only the regions of exons bounded by the
   * [codingSequence][google.genomics.v1.Transcript.coding_sequence] correspond
   * to coding DNA sequence.
   *
   * Exons are ordered by start position and may not overlap.
   *
   * @generated from field: repeated google.genomics.v1.Transcript.Exon exons = 2;
   */
  exons: Transcript_Exon[] = [];

  /**
   * The range of the coding sequence for this transcript, if any. To determine
   * the exact ranges of coding sequence, intersect this range with those of the
   * [exons][google.genomics.v1.Transcript.exons], if any. If there are any
   * [exons][google.genomics.v1.Transcript.exons], the
   * [codingSequence][google.genomics.v1.Transcript.coding_sequence] must start
   * and end within them.
   *
   * Note that in some cases, the reference genome will not exactly match the
   * observed mRNA transcript e.g. due to variance in the source genome from
   * reference. In these cases,
   * [exon.frame][google.genomics.v1.Transcript.Exon.frame] will not necessarily
   * match the expected reference reading frame and coding exon reference bases
   * cannot necessarily be concatenated to produce the original transcript mRNA.
   *
   * @generated from field: google.genomics.v1.Transcript.CodingSequence coding_sequence = 3;
   */
  codingSequence?: Transcript_CodingSequence;

  constructor(data?: PartialMessage<Transcript>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.Transcript";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "gene_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "exons", kind: "message", T: Transcript_Exon, repeated: true },
    { no: 3, name: "coding_sequence", kind: "message", T: Transcript_CodingSequence },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Transcript {
    return new Transcript().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Transcript {
    return new Transcript().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Transcript {
    return new Transcript().fromJsonString(jsonString, options);
  }

  static equals(a: Transcript | PlainMessage<Transcript> | undefined, b: Transcript | PlainMessage<Transcript> | undefined): boolean {
    return proto3.util.equals(Transcript, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.Transcript.Exon
 */
export class Transcript_Exon extends Message<Transcript_Exon> {
  /**
   * The start position of the exon on this annotation's reference sequence,
   * 0-based inclusive. Note that this is relative to the reference start, and
   * **not** the containing annotation start.
   *
   * @generated from field: int64 start = 1;
   */
  start = protoInt64.zero;

  /**
   * The end position of the exon on this annotation's reference sequence,
   * 0-based exclusive. Note that this is relative to the reference start, and
   * *not* the containing annotation start.
   *
   * @generated from field: int64 end = 2;
   */
  end = protoInt64.zero;

  /**
   * The frame of this exon. Contains a value of 0, 1, or 2, which indicates
   * the offset of the first coding base of the exon within the reading frame
   * of the coding DNA sequence, if any. This field is dependent on the
   * strandedness of this annotation (see
   * [Annotation.reverse_strand][google.genomics.v1.Annotation.reverse_strand]).
   * For forward stranded annotations, this offset is relative to the
   * [exon.start][google.genomics.v1.Transcript.Exon.start]. For reverse
   * strand annotations, this offset is relative to the
   * [exon.end][google.genomics.v1.Transcript.Exon.end] `- 1`.
   *
   * Unset if this exon does not intersect the coding sequence. Upon creation
   * of a transcript, the frame must be populated for all or none of the
   * coding exons.
   *
   * @generated from field: google.protobuf.Int32Value frame = 3;
   */
  frame?: number;

  constructor(data?: PartialMessage<Transcript_Exon>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.Transcript.Exon";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "end", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "frame", kind: "message", T: Int32Value },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Transcript_Exon {
    return new Transcript_Exon().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Transcript_Exon {
    return new Transcript_Exon().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Transcript_Exon {
    return new Transcript_Exon().fromJsonString(jsonString, options);
  }

  static equals(a: Transcript_Exon | PlainMessage<Transcript_Exon> | undefined, b: Transcript_Exon | PlainMessage<Transcript_Exon> | undefined): boolean {
    return proto3.util.equals(Transcript_Exon, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.Transcript.CodingSequence
 */
export class Transcript_CodingSequence extends Message<Transcript_CodingSequence> {
  /**
   * The start of the coding sequence on this annotation's reference sequence,
   * 0-based inclusive. Note that this position is relative to the reference
   * start, and *not* the containing annotation start.
   *
   * @generated from field: int64 start = 1;
   */
  start = protoInt64.zero;

  /**
   * The end of the coding sequence on this annotation's reference sequence,
   * 0-based exclusive. Note that this position is relative to the reference
   * start, and *not* the containing annotation start.
   *
   * @generated from field: int64 end = 2;
   */
  end = protoInt64.zero;

  constructor(data?: PartialMessage<Transcript_CodingSequence>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.Transcript.CodingSequence";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "start", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "end", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Transcript_CodingSequence {
    return new Transcript_CodingSequence().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Transcript_CodingSequence {
    return new Transcript_CodingSequence().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Transcript_CodingSequence {
    return new Transcript_CodingSequence().fromJsonString(jsonString, options);
  }

  static equals(a: Transcript_CodingSequence | PlainMessage<Transcript_CodingSequence> | undefined, b: Transcript_CodingSequence | PlainMessage<Transcript_CodingSequence> | undefined): boolean {
    return proto3.util.equals(Transcript_CodingSequence, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.ExternalId
 */
export class ExternalId extends Message<ExternalId> {
  /**
   * The name of the source of this data.
   *
   * @generated from field: string source_name = 1;
   */
  sourceName = "";

  /**
   * The id used by the source of this data.
   *
   * @generated from field: string id = 2;
   */
  id = "";

  constructor(data?: PartialMessage<ExternalId>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.ExternalId";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExternalId {
    return new ExternalId().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExternalId {
    return new ExternalId().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExternalId {
    return new ExternalId().fromJsonString(jsonString, options);
  }

  static equals(a: ExternalId | PlainMessage<ExternalId> | undefined, b: ExternalId | PlainMessage<ExternalId> | undefined): boolean {
    return proto3.util.equals(ExternalId, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.CreateAnnotationSetRequest
 */
export class CreateAnnotationSetRequest extends Message<CreateAnnotationSetRequest> {
  /**
   * The annotation set to create.
   *
   * @generated from field: google.genomics.v1.AnnotationSet annotation_set = 1;
   */
  annotationSet?: AnnotationSet;

  constructor(data?: PartialMessage<CreateAnnotationSetRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.CreateAnnotationSetRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "annotation_set", kind: "message", T: AnnotationSet },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateAnnotationSetRequest {
    return new CreateAnnotationSetRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateAnnotationSetRequest {
    return new CreateAnnotationSetRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateAnnotationSetRequest {
    return new CreateAnnotationSetRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateAnnotationSetRequest | PlainMessage<CreateAnnotationSetRequest> | undefined, b: CreateAnnotationSetRequest | PlainMessage<CreateAnnotationSetRequest> | undefined): boolean {
    return proto3.util.equals(CreateAnnotationSetRequest, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.GetAnnotationSetRequest
 */
export class GetAnnotationSetRequest extends Message<GetAnnotationSetRequest> {
  /**
   * The ID of the annotation set to be retrieved.
   *
   * @generated from field: string annotation_set_id = 1;
   */
  annotationSetId = "";

  constructor(data?: PartialMessage<GetAnnotationSetRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.GetAnnotationSetRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "annotation_set_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAnnotationSetRequest {
    return new GetAnnotationSetRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAnnotationSetRequest {
    return new GetAnnotationSetRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAnnotationSetRequest {
    return new GetAnnotationSetRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAnnotationSetRequest | PlainMessage<GetAnnotationSetRequest> | undefined, b: GetAnnotationSetRequest | PlainMessage<GetAnnotationSetRequest> | undefined): boolean {
    return proto3.util.equals(GetAnnotationSetRequest, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.UpdateAnnotationSetRequest
 */
export class UpdateAnnotationSetRequest extends Message<UpdateAnnotationSetRequest> {
  /**
   * The ID of the annotation set to be updated.
   *
   * @generated from field: string annotation_set_id = 1;
   */
  annotationSetId = "";

  /**
   * The new annotation set.
   *
   * @generated from field: google.genomics.v1.AnnotationSet annotation_set = 2;
   */
  annotationSet?: AnnotationSet;

  /**
   * An optional mask specifying which fields to update. Mutable fields are
   * [name][google.genomics.v1.AnnotationSet.name],
   * [source_uri][google.genomics.v1.AnnotationSet.source_uri], and
   * [info][google.genomics.v1.AnnotationSet.info]. If unspecified, all
   * mutable fields will be updated.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 3;
   */
  updateMask?: FieldMask;

  constructor(data?: PartialMessage<UpdateAnnotationSetRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.UpdateAnnotationSetRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "annotation_set_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "annotation_set", kind: "message", T: AnnotationSet },
    { no: 3, name: "update_mask", kind: "message", T: FieldMask },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateAnnotationSetRequest {
    return new UpdateAnnotationSetRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateAnnotationSetRequest {
    return new UpdateAnnotationSetRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateAnnotationSetRequest {
    return new UpdateAnnotationSetRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateAnnotationSetRequest | PlainMessage<UpdateAnnotationSetRequest> | undefined, b: UpdateAnnotationSetRequest | PlainMessage<UpdateAnnotationSetRequest> | undefined): boolean {
    return proto3.util.equals(UpdateAnnotationSetRequest, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.DeleteAnnotationSetRequest
 */
export class DeleteAnnotationSetRequest extends Message<DeleteAnnotationSetRequest> {
  /**
   * The ID of the annotation set to be deleted.
   *
   * @generated from field: string annotation_set_id = 1;
   */
  annotationSetId = "";

  constructor(data?: PartialMessage<DeleteAnnotationSetRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.DeleteAnnotationSetRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "annotation_set_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteAnnotationSetRequest {
    return new DeleteAnnotationSetRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteAnnotationSetRequest {
    return new DeleteAnnotationSetRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteAnnotationSetRequest {
    return new DeleteAnnotationSetRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteAnnotationSetRequest | PlainMessage<DeleteAnnotationSetRequest> | undefined, b: DeleteAnnotationSetRequest | PlainMessage<DeleteAnnotationSetRequest> | undefined): boolean {
    return proto3.util.equals(DeleteAnnotationSetRequest, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.SearchAnnotationSetsRequest
 */
export class SearchAnnotationSetsRequest extends Message<SearchAnnotationSetsRequest> {
  /**
   * Required. The dataset IDs to search within. Caller must have `READ` access
   * to these datasets.
   *
   * @generated from field: repeated string dataset_ids = 1;
   */
  datasetIds: string[] = [];

  /**
   * If specified, only annotation sets associated with the given reference set
   * are returned.
   *
   * @generated from field: string reference_set_id = 2;
   */
  referenceSetId = "";

  /**
   * Only return annotations sets for which a substring of the name matches this
   * string (case insensitive).
   *
   * @generated from field: string name = 3;
   */
  name = "";

  /**
   * If specified, only annotation sets that have any of these types are
   * returned.
   *
   * @generated from field: repeated google.genomics.v1.AnnotationType types = 4;
   */
  types: AnnotationType[] = [];

  /**
   * The continuation token, which is used to page through large result sets.
   * To get the next page of results, set this parameter to the value of
   * `nextPageToken` from the previous response.
   *
   * @generated from field: string page_token = 5;
   */
  pageToken = "";

  /**
   * The maximum number of results to return in a single page. If unspecified,
   * defaults to 128. The maximum value is 1024.
   *
   * @generated from field: int32 page_size = 6;
   */
  pageSize = 0;

  constructor(data?: PartialMessage<SearchAnnotationSetsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.SearchAnnotationSetsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "dataset_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "reference_set_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "types", kind: "enum", T: proto3.getEnumType(AnnotationType), repeated: true },
    { no: 5, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchAnnotationSetsRequest {
    return new SearchAnnotationSetsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchAnnotationSetsRequest {
    return new SearchAnnotationSetsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchAnnotationSetsRequest {
    return new SearchAnnotationSetsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SearchAnnotationSetsRequest | PlainMessage<SearchAnnotationSetsRequest> | undefined, b: SearchAnnotationSetsRequest | PlainMessage<SearchAnnotationSetsRequest> | undefined): boolean {
    return proto3.util.equals(SearchAnnotationSetsRequest, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.SearchAnnotationSetsResponse
 */
export class SearchAnnotationSetsResponse extends Message<SearchAnnotationSetsResponse> {
  /**
   * The matching annotation sets.
   *
   * @generated from field: repeated google.genomics.v1.AnnotationSet annotation_sets = 1;
   */
  annotationSets: AnnotationSet[] = [];

  /**
   * The continuation token, which is used to page through large result sets.
   * Provide this value in a subsequent request to return the next page of
   * results. This field will be empty if there aren't any additional results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<SearchAnnotationSetsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.SearchAnnotationSetsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "annotation_sets", kind: "message", T: AnnotationSet, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchAnnotationSetsResponse {
    return new SearchAnnotationSetsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchAnnotationSetsResponse {
    return new SearchAnnotationSetsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchAnnotationSetsResponse {
    return new SearchAnnotationSetsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SearchAnnotationSetsResponse | PlainMessage<SearchAnnotationSetsResponse> | undefined, b: SearchAnnotationSetsResponse | PlainMessage<SearchAnnotationSetsResponse> | undefined): boolean {
    return proto3.util.equals(SearchAnnotationSetsResponse, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.CreateAnnotationRequest
 */
export class CreateAnnotationRequest extends Message<CreateAnnotationRequest> {
  /**
   * The annotation to be created.
   *
   * @generated from field: google.genomics.v1.Annotation annotation = 1;
   */
  annotation?: Annotation;

  constructor(data?: PartialMessage<CreateAnnotationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.CreateAnnotationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "annotation", kind: "message", T: Annotation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateAnnotationRequest {
    return new CreateAnnotationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateAnnotationRequest {
    return new CreateAnnotationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateAnnotationRequest {
    return new CreateAnnotationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateAnnotationRequest | PlainMessage<CreateAnnotationRequest> | undefined, b: CreateAnnotationRequest | PlainMessage<CreateAnnotationRequest> | undefined): boolean {
    return proto3.util.equals(CreateAnnotationRequest, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.BatchCreateAnnotationsRequest
 */
export class BatchCreateAnnotationsRequest extends Message<BatchCreateAnnotationsRequest> {
  /**
   * The annotations to be created. At most 4096 can be specified in a single
   * request.
   *
   * @generated from field: repeated google.genomics.v1.Annotation annotations = 1;
   */
  annotations: Annotation[] = [];

  /**
   * A unique request ID which enables the server to detect duplicated requests.
   * If provided, duplicated requests will result in the same response; if not
   * provided, duplicated requests may result in duplicated data. For a given
   * annotation set, callers should not reuse `request_id`s when writing
   * different batches of annotations - behavior in this case is undefined.
   * A common approach is to use a UUID. For batch jobs where worker crashes are
   * a possibility, consider using some unique variant of a worker or run ID.
   *
   * @generated from field: string request_id = 2;
   */
  requestId = "";

  constructor(data?: PartialMessage<BatchCreateAnnotationsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.BatchCreateAnnotationsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "annotations", kind: "message", T: Annotation, repeated: true },
    { no: 2, name: "request_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchCreateAnnotationsRequest {
    return new BatchCreateAnnotationsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchCreateAnnotationsRequest {
    return new BatchCreateAnnotationsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchCreateAnnotationsRequest {
    return new BatchCreateAnnotationsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: BatchCreateAnnotationsRequest | PlainMessage<BatchCreateAnnotationsRequest> | undefined, b: BatchCreateAnnotationsRequest | PlainMessage<BatchCreateAnnotationsRequest> | undefined): boolean {
    return proto3.util.equals(BatchCreateAnnotationsRequest, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.BatchCreateAnnotationsResponse
 */
export class BatchCreateAnnotationsResponse extends Message<BatchCreateAnnotationsResponse> {
  /**
   * The resulting per-annotation entries, ordered consistently with the
   * original request.
   *
   * @generated from field: repeated google.genomics.v1.BatchCreateAnnotationsResponse.Entry entries = 1;
   */
  entries: BatchCreateAnnotationsResponse_Entry[] = [];

  constructor(data?: PartialMessage<BatchCreateAnnotationsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.BatchCreateAnnotationsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entries", kind: "message", T: BatchCreateAnnotationsResponse_Entry, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchCreateAnnotationsResponse {
    return new BatchCreateAnnotationsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchCreateAnnotationsResponse {
    return new BatchCreateAnnotationsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchCreateAnnotationsResponse {
    return new BatchCreateAnnotationsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: BatchCreateAnnotationsResponse | PlainMessage<BatchCreateAnnotationsResponse> | undefined, b: BatchCreateAnnotationsResponse | PlainMessage<BatchCreateAnnotationsResponse> | undefined): boolean {
    return proto3.util.equals(BatchCreateAnnotationsResponse, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.BatchCreateAnnotationsResponse.Entry
 */
export class BatchCreateAnnotationsResponse_Entry extends Message<BatchCreateAnnotationsResponse_Entry> {
  /**
   * The creation status.
   *
   * @generated from field: google.rpc.Status status = 1;
   */
  status?: Status;

  /**
   * The created annotation, if creation was successful.
   *
   * @generated from field: google.genomics.v1.Annotation annotation = 2;
   */
  annotation?: Annotation;

  constructor(data?: PartialMessage<BatchCreateAnnotationsResponse_Entry>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.BatchCreateAnnotationsResponse.Entry";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status", kind: "message", T: Status },
    { no: 2, name: "annotation", kind: "message", T: Annotation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchCreateAnnotationsResponse_Entry {
    return new BatchCreateAnnotationsResponse_Entry().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchCreateAnnotationsResponse_Entry {
    return new BatchCreateAnnotationsResponse_Entry().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchCreateAnnotationsResponse_Entry {
    return new BatchCreateAnnotationsResponse_Entry().fromJsonString(jsonString, options);
  }

  static equals(a: BatchCreateAnnotationsResponse_Entry | PlainMessage<BatchCreateAnnotationsResponse_Entry> | undefined, b: BatchCreateAnnotationsResponse_Entry | PlainMessage<BatchCreateAnnotationsResponse_Entry> | undefined): boolean {
    return proto3.util.equals(BatchCreateAnnotationsResponse_Entry, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.GetAnnotationRequest
 */
export class GetAnnotationRequest extends Message<GetAnnotationRequest> {
  /**
   * The ID of the annotation to be retrieved.
   *
   * @generated from field: string annotation_id = 1;
   */
  annotationId = "";

  constructor(data?: PartialMessage<GetAnnotationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.GetAnnotationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "annotation_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAnnotationRequest {
    return new GetAnnotationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAnnotationRequest {
    return new GetAnnotationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAnnotationRequest {
    return new GetAnnotationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAnnotationRequest | PlainMessage<GetAnnotationRequest> | undefined, b: GetAnnotationRequest | PlainMessage<GetAnnotationRequest> | undefined): boolean {
    return proto3.util.equals(GetAnnotationRequest, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.UpdateAnnotationRequest
 */
export class UpdateAnnotationRequest extends Message<UpdateAnnotationRequest> {
  /**
   * The ID of the annotation to be updated.
   *
   * @generated from field: string annotation_id = 1;
   */
  annotationId = "";

  /**
   * The new annotation.
   *
   * @generated from field: google.genomics.v1.Annotation annotation = 2;
   */
  annotation?: Annotation;

  /**
   * An optional mask specifying which fields to update. Mutable fields are
   * [name][google.genomics.v1.Annotation.name],
   * [variant][google.genomics.v1.Annotation.variant],
   * [transcript][google.genomics.v1.Annotation.transcript], and
   * [info][google.genomics.v1.Annotation.info]. If unspecified, all mutable
   * fields will be updated.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 3;
   */
  updateMask?: FieldMask;

  constructor(data?: PartialMessage<UpdateAnnotationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.UpdateAnnotationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "annotation_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "annotation", kind: "message", T: Annotation },
    { no: 3, name: "update_mask", kind: "message", T: FieldMask },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateAnnotationRequest {
    return new UpdateAnnotationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateAnnotationRequest {
    return new UpdateAnnotationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateAnnotationRequest {
    return new UpdateAnnotationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateAnnotationRequest | PlainMessage<UpdateAnnotationRequest> | undefined, b: UpdateAnnotationRequest | PlainMessage<UpdateAnnotationRequest> | undefined): boolean {
    return proto3.util.equals(UpdateAnnotationRequest, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.DeleteAnnotationRequest
 */
export class DeleteAnnotationRequest extends Message<DeleteAnnotationRequest> {
  /**
   * The ID of the annotation to be deleted.
   *
   * @generated from field: string annotation_id = 1;
   */
  annotationId = "";

  constructor(data?: PartialMessage<DeleteAnnotationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.DeleteAnnotationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "annotation_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteAnnotationRequest {
    return new DeleteAnnotationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteAnnotationRequest {
    return new DeleteAnnotationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteAnnotationRequest {
    return new DeleteAnnotationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteAnnotationRequest | PlainMessage<DeleteAnnotationRequest> | undefined, b: DeleteAnnotationRequest | PlainMessage<DeleteAnnotationRequest> | undefined): boolean {
    return proto3.util.equals(DeleteAnnotationRequest, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.SearchAnnotationsRequest
 */
export class SearchAnnotationsRequest extends Message<SearchAnnotationsRequest> {
  /**
   * Required. The annotation sets to search within. The caller must have
   * `READ` access to these annotation sets.
   * All queried annotation sets must have the same type.
   *
   * @generated from field: repeated string annotation_set_ids = 1;
   */
  annotationSetIds: string[] = [];

  /**
   * Required. `reference_id` or `reference_name` must be set.
   *
   * @generated from oneof google.genomics.v1.SearchAnnotationsRequest.reference
   */
  reference: {
    /**
     * The ID of the reference to query.
     *
     * @generated from field: string reference_id = 2;
     */
    value: string;
    case: "referenceId";
  } | {
    /**
     * The name of the reference to query, within the reference set associated
     * with this query.
     *
     * @generated from field: string reference_name = 3;
     */
    value: string;
    case: "referenceName";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The start position of the range on the reference, 0-based inclusive. If
   * specified,
   * [referenceId][google.genomics.v1.SearchAnnotationsRequest.reference_id] or
   * [referenceName][google.genomics.v1.SearchAnnotationsRequest.reference_name]
   * must be specified. Defaults to 0.
   *
   * @generated from field: int64 start = 4;
   */
  start = protoInt64.zero;

  /**
   * The end position of the range on the reference, 0-based exclusive. If
   * [referenceId][google.genomics.v1.SearchAnnotationsRequest.reference_id] or
   * [referenceName][google.genomics.v1.SearchAnnotationsRequest.reference_name]
   * must be specified, Defaults to the length of the reference.
   *
   * @generated from field: int64 end = 5;
   */
  end = protoInt64.zero;

  /**
   * The continuation token, which is used to page through large result sets.
   * To get the next page of results, set this parameter to the value of
   * `nextPageToken` from the previous response.
   *
   * @generated from field: string page_token = 6;
   */
  pageToken = "";

  /**
   * The maximum number of results to return in a single page. If unspecified,
   * defaults to 256. The maximum value is 2048.
   *
   * @generated from field: int32 page_size = 7;
   */
  pageSize = 0;

  constructor(data?: PartialMessage<SearchAnnotationsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.SearchAnnotationsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "annotation_set_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "reference_id", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "reference" },
    { no: 3, name: "reference_name", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "reference" },
    { no: 4, name: "start", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "end", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchAnnotationsRequest {
    return new SearchAnnotationsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchAnnotationsRequest {
    return new SearchAnnotationsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchAnnotationsRequest {
    return new SearchAnnotationsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SearchAnnotationsRequest | PlainMessage<SearchAnnotationsRequest> | undefined, b: SearchAnnotationsRequest | PlainMessage<SearchAnnotationsRequest> | undefined): boolean {
    return proto3.util.equals(SearchAnnotationsRequest, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.SearchAnnotationsResponse
 */
export class SearchAnnotationsResponse extends Message<SearchAnnotationsResponse> {
  /**
   * The matching annotations.
   *
   * @generated from field: repeated google.genomics.v1.Annotation annotations = 1;
   */
  annotations: Annotation[] = [];

  /**
   * The continuation token, which is used to page through large result sets.
   * Provide this value in a subsequent request to return the next page of
   * results. This field will be empty if there aren't any additional results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<SearchAnnotationsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.SearchAnnotationsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "annotations", kind: "message", T: Annotation, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchAnnotationsResponse {
    return new SearchAnnotationsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchAnnotationsResponse {
    return new SearchAnnotationsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchAnnotationsResponse {
    return new SearchAnnotationsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SearchAnnotationsResponse | PlainMessage<SearchAnnotationsResponse> | undefined, b: SearchAnnotationsResponse | PlainMessage<SearchAnnotationsResponse> | undefined): boolean {
    return proto3.util.equals(SearchAnnotationsResponse, a, b);
  }
}

