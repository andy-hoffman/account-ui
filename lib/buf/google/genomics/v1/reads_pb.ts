// Copyright 2016 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/genomics/v1/reads.proto (package google.genomics.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { FieldMask, Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { ReadGroupSet } from "./readgroupset_pb.js";
import { Range } from "./range_pb.js";
import { Read } from "./readalignment_pb.js";

/**
 * The read group set search request.
 *
 * @generated from message google.genomics.v1.SearchReadGroupSetsRequest
 */
export class SearchReadGroupSetsRequest extends Message<SearchReadGroupSetsRequest> {
  /**
   * Restricts this query to read group sets within the given datasets. At least
   * one ID must be provided.
   *
   * @generated from field: repeated string dataset_ids = 1;
   */
  datasetIds: string[] = [];

  /**
   * Only return read group sets for which a substring of the name matches this
   * string.
   *
   * @generated from field: string name = 3;
   */
  name = "";

  /**
   * The continuation token, which is used to page through large result sets.
   * To get the next page of results, set this parameter to the value of
   * `nextPageToken` from the previous response.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  /**
   * The maximum number of results to return in a single page. If unspecified,
   * defaults to 256. The maximum value is 1024.
   *
   * @generated from field: int32 page_size = 4;
   */
  pageSize = 0;

  constructor(data?: PartialMessage<SearchReadGroupSetsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.SearchReadGroupSetsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "dataset_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchReadGroupSetsRequest {
    return new SearchReadGroupSetsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchReadGroupSetsRequest {
    return new SearchReadGroupSetsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchReadGroupSetsRequest {
    return new SearchReadGroupSetsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SearchReadGroupSetsRequest | PlainMessage<SearchReadGroupSetsRequest> | undefined, b: SearchReadGroupSetsRequest | PlainMessage<SearchReadGroupSetsRequest> | undefined): boolean {
    return proto3.util.equals(SearchReadGroupSetsRequest, a, b);
  }
}

/**
 * The read group set search response.
 *
 * @generated from message google.genomics.v1.SearchReadGroupSetsResponse
 */
export class SearchReadGroupSetsResponse extends Message<SearchReadGroupSetsResponse> {
  /**
   * The list of matching read group sets.
   *
   * @generated from field: repeated google.genomics.v1.ReadGroupSet read_group_sets = 1;
   */
  readGroupSets: ReadGroupSet[] = [];

  /**
   * The continuation token, which is used to page through large result sets.
   * Provide this value in a subsequent request to return the next page of
   * results. This field will be empty if there aren't any additional results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<SearchReadGroupSetsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.SearchReadGroupSetsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "read_group_sets", kind: "message", T: ReadGroupSet, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchReadGroupSetsResponse {
    return new SearchReadGroupSetsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchReadGroupSetsResponse {
    return new SearchReadGroupSetsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchReadGroupSetsResponse {
    return new SearchReadGroupSetsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SearchReadGroupSetsResponse | PlainMessage<SearchReadGroupSetsResponse> | undefined, b: SearchReadGroupSetsResponse | PlainMessage<SearchReadGroupSetsResponse> | undefined): boolean {
    return proto3.util.equals(SearchReadGroupSetsResponse, a, b);
  }
}

/**
 * The read group set import request.
 *
 * @generated from message google.genomics.v1.ImportReadGroupSetsRequest
 */
export class ImportReadGroupSetsRequest extends Message<ImportReadGroupSetsRequest> {
  /**
   * Required. The ID of the dataset these read group sets will belong to. The
   * caller must have WRITE permissions to this dataset.
   *
   * @generated from field: string dataset_id = 1;
   */
  datasetId = "";

  /**
   * The reference set to which the imported read group sets are aligned to, if
   * any. The reference names of this reference set must be a superset of those
   * found in the imported file headers. If no reference set id is provided, a
   * best effort is made to associate with a matching reference set.
   *
   * @generated from field: string reference_set_id = 4;
   */
  referenceSetId = "";

  /**
   * A list of URIs pointing at [BAM
   * files](https://samtools.github.io/hts-specs/SAMv1.pdf)
   * in Google Cloud Storage.
   * Those URIs can include wildcards (*), but do not add or remove
   * matching files before import has completed.
   *
   * Note that Google Cloud Storage object listing is only eventually
   * consistent: files added may be not be immediately visible to
   * everyone. Thus, if using a wildcard it is preferable not to start
   * the import immediately after the files are created.
   *
   * @generated from field: repeated string source_uris = 2;
   */
  sourceUris: string[] = [];

  /**
   * The partition strategy describes how read groups are partitioned into read
   * group sets.
   *
   * @generated from field: google.genomics.v1.ImportReadGroupSetsRequest.PartitionStrategy partition_strategy = 5;
   */
  partitionStrategy = ImportReadGroupSetsRequest_PartitionStrategy.PARTITION_STRATEGY_UNSPECIFIED;

  constructor(data?: PartialMessage<ImportReadGroupSetsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.ImportReadGroupSetsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "dataset_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "reference_set_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "source_uris", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "partition_strategy", kind: "enum", T: proto3.getEnumType(ImportReadGroupSetsRequest_PartitionStrategy) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImportReadGroupSetsRequest {
    return new ImportReadGroupSetsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImportReadGroupSetsRequest {
    return new ImportReadGroupSetsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImportReadGroupSetsRequest {
    return new ImportReadGroupSetsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ImportReadGroupSetsRequest | PlainMessage<ImportReadGroupSetsRequest> | undefined, b: ImportReadGroupSetsRequest | PlainMessage<ImportReadGroupSetsRequest> | undefined): boolean {
    return proto3.util.equals(ImportReadGroupSetsRequest, a, b);
  }
}

/**
 * @generated from enum google.genomics.v1.ImportReadGroupSetsRequest.PartitionStrategy
 */
export enum ImportReadGroupSetsRequest_PartitionStrategy {
  /**
   * @generated from enum value: PARTITION_STRATEGY_UNSPECIFIED = 0;
   */
  PARTITION_STRATEGY_UNSPECIFIED = 0,

  /**
   * In most cases, this strategy yields one read group set per file. This is
   * the default behavior.
   *
   * Allocate one read group set per file per sample. For BAM files, read
   * groups are considered to share a sample if they have identical sample
   * names. Furthermore, all reads for each file which do not belong to a read
   * group, if any, will be grouped into a single read group set per-file.
   *
   * @generated from enum value: PER_FILE_PER_SAMPLE = 1;
   */
  PER_FILE_PER_SAMPLE = 1,

  /**
   * Includes all read groups in all imported files into a single read group
   * set. Requires that the headers for all imported files are equivalent. All
   * reads which do not belong to a read group, if any, will be grouped into a
   * separate read group set.
   *
   * @generated from enum value: MERGE_ALL = 2;
   */
  MERGE_ALL = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ImportReadGroupSetsRequest_PartitionStrategy)
proto3.util.setEnumType(ImportReadGroupSetsRequest_PartitionStrategy, "google.genomics.v1.ImportReadGroupSetsRequest.PartitionStrategy", [
  { no: 0, name: "PARTITION_STRATEGY_UNSPECIFIED" },
  { no: 1, name: "PER_FILE_PER_SAMPLE" },
  { no: 2, name: "MERGE_ALL" },
]);

/**
 * The read group set import response.
 *
 * @generated from message google.genomics.v1.ImportReadGroupSetsResponse
 */
export class ImportReadGroupSetsResponse extends Message<ImportReadGroupSetsResponse> {
  /**
   * IDs of the read group sets that were created.
   *
   * @generated from field: repeated string read_group_set_ids = 1;
   */
  readGroupSetIds: string[] = [];

  constructor(data?: PartialMessage<ImportReadGroupSetsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.ImportReadGroupSetsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "read_group_set_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ImportReadGroupSetsResponse {
    return new ImportReadGroupSetsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ImportReadGroupSetsResponse {
    return new ImportReadGroupSetsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ImportReadGroupSetsResponse {
    return new ImportReadGroupSetsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ImportReadGroupSetsResponse | PlainMessage<ImportReadGroupSetsResponse> | undefined, b: ImportReadGroupSetsResponse | PlainMessage<ImportReadGroupSetsResponse> | undefined): boolean {
    return proto3.util.equals(ImportReadGroupSetsResponse, a, b);
  }
}

/**
 * The read group set export request.
 *
 * @generated from message google.genomics.v1.ExportReadGroupSetRequest
 */
export class ExportReadGroupSetRequest extends Message<ExportReadGroupSetRequest> {
  /**
   * Required. The Google Cloud project ID that owns this
   * export. The caller must have WRITE access to this project.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * Required. A Google Cloud Storage URI for the exported BAM file.
   * The currently authenticated user must have write access to the new file.
   * An error will be returned if the URI already contains data.
   *
   * @generated from field: string export_uri = 2;
   */
  exportUri = "";

  /**
   * Required. The ID of the read group set to export. The caller must have
   * READ access to this read group set.
   *
   * @generated from field: string read_group_set_id = 3;
   */
  readGroupSetId = "";

  /**
   * The reference names to export. If this is not specified, all reference
   * sequences, including unmapped reads, are exported.
   * Use `*` to export only unmapped reads.
   *
   * @generated from field: repeated string reference_names = 4;
   */
  referenceNames: string[] = [];

  constructor(data?: PartialMessage<ExportReadGroupSetRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.ExportReadGroupSetRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "export_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "read_group_set_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "reference_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExportReadGroupSetRequest {
    return new ExportReadGroupSetRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExportReadGroupSetRequest {
    return new ExportReadGroupSetRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExportReadGroupSetRequest {
    return new ExportReadGroupSetRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExportReadGroupSetRequest | PlainMessage<ExportReadGroupSetRequest> | undefined, b: ExportReadGroupSetRequest | PlainMessage<ExportReadGroupSetRequest> | undefined): boolean {
    return proto3.util.equals(ExportReadGroupSetRequest, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.UpdateReadGroupSetRequest
 */
export class UpdateReadGroupSetRequest extends Message<UpdateReadGroupSetRequest> {
  /**
   * The ID of the read group set to be updated. The caller must have WRITE
   * permissions to the dataset associated with this read group set.
   *
   * @generated from field: string read_group_set_id = 1;
   */
  readGroupSetId = "";

  /**
   * The new read group set data. See `updateMask` for details on mutability of
   * fields.
   *
   * @generated from field: google.genomics.v1.ReadGroupSet read_group_set = 2;
   */
  readGroupSet?: ReadGroupSet;

  /**
   * An optional mask specifying which fields to update. Supported fields:
   *
   * * [name][google.genomics.v1.ReadGroupSet.name].
   * * [referenceSetId][google.genomics.v1.ReadGroupSet.reference_set_id].
   *
   * Leaving `updateMask` unset is equivalent to specifying all mutable
   * fields.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 3;
   */
  updateMask?: FieldMask;

  constructor(data?: PartialMessage<UpdateReadGroupSetRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.UpdateReadGroupSetRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "read_group_set_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "read_group_set", kind: "message", T: ReadGroupSet },
    { no: 3, name: "update_mask", kind: "message", T: FieldMask },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateReadGroupSetRequest {
    return new UpdateReadGroupSetRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateReadGroupSetRequest {
    return new UpdateReadGroupSetRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateReadGroupSetRequest {
    return new UpdateReadGroupSetRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateReadGroupSetRequest | PlainMessage<UpdateReadGroupSetRequest> | undefined, b: UpdateReadGroupSetRequest | PlainMessage<UpdateReadGroupSetRequest> | undefined): boolean {
    return proto3.util.equals(UpdateReadGroupSetRequest, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.DeleteReadGroupSetRequest
 */
export class DeleteReadGroupSetRequest extends Message<DeleteReadGroupSetRequest> {
  /**
   * The ID of the read group set to be deleted. The caller must have WRITE
   * permissions to the dataset associated with this read group set.
   *
   * @generated from field: string read_group_set_id = 1;
   */
  readGroupSetId = "";

  constructor(data?: PartialMessage<DeleteReadGroupSetRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.DeleteReadGroupSetRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "read_group_set_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteReadGroupSetRequest {
    return new DeleteReadGroupSetRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteReadGroupSetRequest {
    return new DeleteReadGroupSetRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteReadGroupSetRequest {
    return new DeleteReadGroupSetRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteReadGroupSetRequest | PlainMessage<DeleteReadGroupSetRequest> | undefined, b: DeleteReadGroupSetRequest | PlainMessage<DeleteReadGroupSetRequest> | undefined): boolean {
    return proto3.util.equals(DeleteReadGroupSetRequest, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.GetReadGroupSetRequest
 */
export class GetReadGroupSetRequest extends Message<GetReadGroupSetRequest> {
  /**
   * The ID of the read group set.
   *
   * @generated from field: string read_group_set_id = 1;
   */
  readGroupSetId = "";

  constructor(data?: PartialMessage<GetReadGroupSetRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.GetReadGroupSetRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "read_group_set_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetReadGroupSetRequest {
    return new GetReadGroupSetRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetReadGroupSetRequest {
    return new GetReadGroupSetRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetReadGroupSetRequest {
    return new GetReadGroupSetRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetReadGroupSetRequest | PlainMessage<GetReadGroupSetRequest> | undefined, b: GetReadGroupSetRequest | PlainMessage<GetReadGroupSetRequest> | undefined): boolean {
    return proto3.util.equals(GetReadGroupSetRequest, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.ListCoverageBucketsRequest
 */
export class ListCoverageBucketsRequest extends Message<ListCoverageBucketsRequest> {
  /**
   * Required. The ID of the read group set over which coverage is requested.
   *
   * @generated from field: string read_group_set_id = 1;
   */
  readGroupSetId = "";

  /**
   * The name of the reference to query, within the reference set associated
   * with this query. Optional.
   *
   * @generated from field: string reference_name = 3;
   */
  referenceName = "";

  /**
   * The start position of the range on the reference, 0-based inclusive. If
   * specified, `referenceName` must also be specified. Defaults to 0.
   *
   * @generated from field: int64 start = 4;
   */
  start = protoInt64.zero;

  /**
   * The end position of the range on the reference, 0-based exclusive. If
   * specified, `referenceName` must also be specified. If unset or 0, defaults
   * to the length of the reference.
   *
   * @generated from field: int64 end = 5;
   */
  end = protoInt64.zero;

  /**
   * The desired width of each reported coverage bucket in base pairs. This
   * will be rounded down to the nearest precomputed bucket width; the value
   * of which is returned as `bucketWidth` in the response. Defaults
   * to infinity (each bucket spans an entire reference sequence) or the length
   * of the target range, if specified. The smallest precomputed
   * `bucketWidth` is currently 2048 base pairs; this is subject to
   * change.
   *
   * @generated from field: int64 target_bucket_width = 6;
   */
  targetBucketWidth = protoInt64.zero;

  /**
   * The continuation token, which is used to page through large result sets.
   * To get the next page of results, set this parameter to the value of
   * `nextPageToken` from the previous response.
   *
   * @generated from field: string page_token = 7;
   */
  pageToken = "";

  /**
   * The maximum number of results to return in a single page. If unspecified,
   * defaults to 1024. The maximum value is 2048.
   *
   * @generated from field: int32 page_size = 8;
   */
  pageSize = 0;

  constructor(data?: PartialMessage<ListCoverageBucketsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.ListCoverageBucketsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "read_group_set_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "reference_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "start", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "end", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "target_bucket_width", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 7, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListCoverageBucketsRequest {
    return new ListCoverageBucketsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListCoverageBucketsRequest {
    return new ListCoverageBucketsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListCoverageBucketsRequest {
    return new ListCoverageBucketsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListCoverageBucketsRequest | PlainMessage<ListCoverageBucketsRequest> | undefined, b: ListCoverageBucketsRequest | PlainMessage<ListCoverageBucketsRequest> | undefined): boolean {
    return proto3.util.equals(ListCoverageBucketsRequest, a, b);
  }
}

/**
 * A bucket over which read coverage has been precomputed. A bucket corresponds
 * to a specific range of the reference sequence.
 *
 * @generated from message google.genomics.v1.CoverageBucket
 */
export class CoverageBucket extends Message<CoverageBucket> {
  /**
   * The genomic coordinate range spanned by this bucket.
   *
   * @generated from field: google.genomics.v1.Range range = 1;
   */
  range?: Range;

  /**
   * The average number of reads which are aligned to each individual
   * reference base in this bucket.
   *
   * @generated from field: float mean_coverage = 2;
   */
  meanCoverage = 0;

  constructor(data?: PartialMessage<CoverageBucket>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.CoverageBucket";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "range", kind: "message", T: Range },
    { no: 2, name: "mean_coverage", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CoverageBucket {
    return new CoverageBucket().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CoverageBucket {
    return new CoverageBucket().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CoverageBucket {
    return new CoverageBucket().fromJsonString(jsonString, options);
  }

  static equals(a: CoverageBucket | PlainMessage<CoverageBucket> | undefined, b: CoverageBucket | PlainMessage<CoverageBucket> | undefined): boolean {
    return proto3.util.equals(CoverageBucket, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.ListCoverageBucketsResponse
 */
export class ListCoverageBucketsResponse extends Message<ListCoverageBucketsResponse> {
  /**
   * The length of each coverage bucket in base pairs. Note that buckets at the
   * end of a reference sequence may be shorter. This value is omitted if the
   * bucket width is infinity (the default behaviour, with no range or
   * `targetBucketWidth`).
   *
   * @generated from field: int64 bucket_width = 1;
   */
  bucketWidth = protoInt64.zero;

  /**
   * The coverage buckets. The list of buckets is sparse; a bucket with 0
   * overlapping reads is not returned. A bucket never crosses more than one
   * reference sequence. Each bucket has width `bucketWidth`, unless
   * its end is the end of the reference sequence.
   *
   * @generated from field: repeated google.genomics.v1.CoverageBucket coverage_buckets = 2;
   */
  coverageBuckets: CoverageBucket[] = [];

  /**
   * The continuation token, which is used to page through large result sets.
   * Provide this value in a subsequent request to return the next page of
   * results. This field will be empty if there aren't any additional results.
   *
   * @generated from field: string next_page_token = 3;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListCoverageBucketsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.ListCoverageBucketsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bucket_width", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "coverage_buckets", kind: "message", T: CoverageBucket, repeated: true },
    { no: 3, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListCoverageBucketsResponse {
    return new ListCoverageBucketsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListCoverageBucketsResponse {
    return new ListCoverageBucketsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListCoverageBucketsResponse {
    return new ListCoverageBucketsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListCoverageBucketsResponse | PlainMessage<ListCoverageBucketsResponse> | undefined, b: ListCoverageBucketsResponse | PlainMessage<ListCoverageBucketsResponse> | undefined): boolean {
    return proto3.util.equals(ListCoverageBucketsResponse, a, b);
  }
}

/**
 * The read search request.
 *
 * @generated from message google.genomics.v1.SearchReadsRequest
 */
export class SearchReadsRequest extends Message<SearchReadsRequest> {
  /**
   * The IDs of the read groups sets within which to search for reads. All
   * specified read group sets must be aligned against a common set of reference
   * sequences; this defines the genomic coordinates for the query. Must specify
   * one of `readGroupSetIds` or `readGroupIds`.
   *
   * @generated from field: repeated string read_group_set_ids = 1;
   */
  readGroupSetIds: string[] = [];

  /**
   * The IDs of the read groups within which to search for reads. All specified
   * read groups must belong to the same read group sets. Must specify one of
   * `readGroupSetIds` or `readGroupIds`.
   *
   * @generated from field: repeated string read_group_ids = 5;
   */
  readGroupIds: string[] = [];

  /**
   * The reference sequence name, for example `chr1`, `1`, or `chrX`. If set to
   * `*`, only unmapped reads are returned. If unspecified, all reads (mapped
   * and unmapped) are returned.
   *
   * @generated from field: string reference_name = 7;
   */
  referenceName = "";

  /**
   * The start position of the range on the reference, 0-based inclusive. If
   * specified, `referenceName` must also be specified.
   *
   * @generated from field: int64 start = 8;
   */
  start = protoInt64.zero;

  /**
   * The end position of the range on the reference, 0-based exclusive. If
   * specified, `referenceName` must also be specified.
   *
   * @generated from field: int64 end = 9;
   */
  end = protoInt64.zero;

  /**
   * The continuation token, which is used to page through large result sets.
   * To get the next page of results, set this parameter to the value of
   * `nextPageToken` from the previous response.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken = "";

  /**
   * The maximum number of results to return in a single page. If unspecified,
   * defaults to 256. The maximum value is 2048.
   *
   * @generated from field: int32 page_size = 4;
   */
  pageSize = 0;

  constructor(data?: PartialMessage<SearchReadsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.SearchReadsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "read_group_set_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "read_group_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "reference_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "start", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 9, name: "end", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchReadsRequest {
    return new SearchReadsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchReadsRequest {
    return new SearchReadsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchReadsRequest {
    return new SearchReadsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SearchReadsRequest | PlainMessage<SearchReadsRequest> | undefined, b: SearchReadsRequest | PlainMessage<SearchReadsRequest> | undefined): boolean {
    return proto3.util.equals(SearchReadsRequest, a, b);
  }
}

/**
 * The read search response.
 *
 * @generated from message google.genomics.v1.SearchReadsResponse
 */
export class SearchReadsResponse extends Message<SearchReadsResponse> {
  /**
   * The list of matching alignments sorted by mapped genomic coordinate,
   * if any, ascending in position within the same reference. Unmapped reads,
   * which have no position, are returned contiguously and are sorted in
   * ascending lexicographic order by fragment name.
   *
   * @generated from field: repeated google.genomics.v1.Read alignments = 1;
   */
  alignments: Read[] = [];

  /**
   * The continuation token, which is used to page through large result sets.
   * Provide this value in a subsequent request to return the next page of
   * results. This field will be empty if there aren't any additional results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<SearchReadsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.SearchReadsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "alignments", kind: "message", T: Read, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchReadsResponse {
    return new SearchReadsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchReadsResponse {
    return new SearchReadsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchReadsResponse {
    return new SearchReadsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SearchReadsResponse | PlainMessage<SearchReadsResponse> | undefined, b: SearchReadsResponse | PlainMessage<SearchReadsResponse> | undefined): boolean {
    return proto3.util.equals(SearchReadsResponse, a, b);
  }
}

/**
 * The stream reads request.
 *
 * @generated from message google.genomics.v1.StreamReadsRequest
 */
export class StreamReadsRequest extends Message<StreamReadsRequest> {
  /**
   * The Google Cloud project ID which will be billed
   * for this access. The caller must have WRITE access to this project.
   * Required.
   *
   * @generated from field: string project_id = 1;
   */
  projectId = "";

  /**
   * The ID of the read group set from which to stream reads.
   *
   * @generated from field: string read_group_set_id = 2;
   */
  readGroupSetId = "";

  /**
   * The reference sequence name, for example `chr1`,
   * `1`, or `chrX`. If set to *, only unmapped reads are
   * returned.
   *
   * @generated from field: string reference_name = 3;
   */
  referenceName = "";

  /**
   * The start position of the range on the reference, 0-based inclusive. If
   * specified, `referenceName` must also be specified.
   *
   * @generated from field: int64 start = 4;
   */
  start = protoInt64.zero;

  /**
   * The end position of the range on the reference, 0-based exclusive. If
   * specified, `referenceName` must also be specified.
   *
   * @generated from field: int64 end = 5;
   */
  end = protoInt64.zero;

  /**
   * Restricts results to a shard containing approximately `1/totalShards`
   * of the normal response payload for this query. Results from a sharded
   * request are disjoint from those returned by all queries which differ only
   * in their shard parameter. A shard may yield 0 results; this is especially
   * likely for large values of `totalShards`.
   *
   * Valid values are `[0, totalShards)`.
   *
   * @generated from field: int32 shard = 6;
   */
  shard = 0;

  /**
   * Specifying `totalShards` causes a disjoint subset of the normal response
   * payload to be returned for each query with a unique `shard` parameter
   * specified. A best effort is made to yield equally sized shards. Sharding
   * can be used to distribute processing amongst workers, where each worker is
   * assigned a unique `shard` number and all workers specify the same
   * `totalShards` number. The union of reads returned for all sharded queries
   * `[0, totalShards)` is equal to those returned by a single unsharded query.
   *
   * Queries for different values of `totalShards` with common divisors will
   * share shard boundaries. For example, streaming `shard` 2 of 5
   * `totalShards` yields the same results as streaming `shard`s 4 and 5 of 10
   * `totalShards`. This property can be leveraged for adaptive retries.
   *
   * @generated from field: int32 total_shards = 7;
   */
  totalShards = 0;

  constructor(data?: PartialMessage<StreamReadsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.StreamReadsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "read_group_set_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "reference_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "start", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "end", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "shard", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 7, name: "total_shards", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamReadsRequest {
    return new StreamReadsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamReadsRequest {
    return new StreamReadsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamReadsRequest {
    return new StreamReadsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StreamReadsRequest | PlainMessage<StreamReadsRequest> | undefined, b: StreamReadsRequest | PlainMessage<StreamReadsRequest> | undefined): boolean {
    return proto3.util.equals(StreamReadsRequest, a, b);
  }
}

/**
 * @generated from message google.genomics.v1.StreamReadsResponse
 */
export class StreamReadsResponse extends Message<StreamReadsResponse> {
  /**
   * @generated from field: repeated google.genomics.v1.Read alignments = 1;
   */
  alignments: Read[] = [];

  constructor(data?: PartialMessage<StreamReadsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.genomics.v1.StreamReadsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "alignments", kind: "message", T: Read, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamReadsResponse {
    return new StreamReadsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamReadsResponse {
    return new StreamReadsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamReadsResponse {
    return new StreamReadsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StreamReadsResponse | PlainMessage<StreamReadsResponse> | undefined, b: StreamReadsResponse | PlainMessage<StreamReadsResponse> | undefined): boolean {
    return proto3.util.equals(StreamReadsResponse, a, b);
  }
}

