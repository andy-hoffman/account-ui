// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/logging/v2/logging.proto (package google.logging.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { MonitoredResource, MonitoredResourceDescriptor } from "../../api/monitored_resource_pb.js";
import { LogEntry } from "./log_entry_pb.js";
import { Status } from "../../rpc/status_pb.js";

/**
 * The parameters to DeleteLog.
 *
 * @generated from message google.logging.v2.DeleteLogRequest
 */
export class DeleteLogRequest extends Message<DeleteLogRequest> {
  /**
   * Required. The resource name of the log to delete:
   *
   *     "projects/[PROJECT_ID]/logs/[LOG_ID]"
   *     "organizations/[ORGANIZATION_ID]/logs/[LOG_ID]"
   *     "billingAccounts/[BILLING_ACCOUNT_ID]/logs/[LOG_ID]"
   *     "folders/[FOLDER_ID]/logs/[LOG_ID]"
   *
   * `[LOG_ID]` must be URL-encoded. For example,
   * `"projects/my-project-id/logs/syslog"`,
   * `"organizations/1234567890/logs/cloudresourcemanager.googleapis.com%2Factivity"`.
   * For more information about log names, see
   * [LogEntry][google.logging.v2.LogEntry].
   *
   * @generated from field: string log_name = 1;
   */
  logName = "";

  constructor(data?: PartialMessage<DeleteLogRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.DeleteLogRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "log_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteLogRequest {
    return new DeleteLogRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteLogRequest {
    return new DeleteLogRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteLogRequest {
    return new DeleteLogRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteLogRequest | PlainMessage<DeleteLogRequest> | undefined, b: DeleteLogRequest | PlainMessage<DeleteLogRequest> | undefined): boolean {
    return proto3.util.equals(DeleteLogRequest, a, b);
  }
}

/**
 * The parameters to WriteLogEntries.
 *
 * @generated from message google.logging.v2.WriteLogEntriesRequest
 */
export class WriteLogEntriesRequest extends Message<WriteLogEntriesRequest> {
  /**
   * Optional. A default log resource name that is assigned to all log entries
   * in `entries` that do not specify a value for `log_name`:
   *
   *     "projects/[PROJECT_ID]/logs/[LOG_ID]"
   *     "organizations/[ORGANIZATION_ID]/logs/[LOG_ID]"
   *     "billingAccounts/[BILLING_ACCOUNT_ID]/logs/[LOG_ID]"
   *     "folders/[FOLDER_ID]/logs/[LOG_ID]"
   *
   * `[LOG_ID]` must be URL-encoded. For example,
   * `"projects/my-project-id/logs/syslog"` or
   * `"organizations/1234567890/logs/cloudresourcemanager.googleapis.com%2Factivity"`.
   * For more information about log names, see
   * [LogEntry][google.logging.v2.LogEntry].
   *
   * @generated from field: string log_name = 1;
   */
  logName = "";

  /**
   * Optional. A default monitored resource object that is assigned to all log
   * entries in `entries` that do not specify a value for `resource`. Example:
   *
   *     { "type": "gce_instance",
   *       "labels": {
   *         "zone": "us-central1-a", "instance_id": "00000000000000000000" }}
   *
   * See [LogEntry][google.logging.v2.LogEntry].
   *
   * @generated from field: google.api.MonitoredResource resource = 2;
   */
  resource?: MonitoredResource;

  /**
   * Optional. Default labels that are added to the `labels` field of all log
   * entries in `entries`. If a log entry already has a label with the same key
   * as a label in this parameter, then the log entry's label is not changed.
   * See [LogEntry][google.logging.v2.LogEntry].
   *
   * @generated from field: map<string, string> labels = 3;
   */
  labels: { [key: string]: string } = {};

  /**
   * Required. The log entries to send to Stackdriver Logging. The order of log
   * entries in this list does not matter. Values supplied in this method's
   * `log_name`, `resource`, and `labels` fields are copied into those log
   * entries in this list that do not include values for their corresponding
   * fields. For more information, see the [LogEntry][google.logging.v2.LogEntry] type.
   *
   * If the `timestamp` or `insert_id` fields are missing in log entries, then
   * this method supplies the current time or a unique identifier, respectively.
   * The supplied values are chosen so that, among the log entries that did not
   * supply their own values, the entries earlier in the list will sort before
   * the entries later in the list. See the `entries.list` method.
   *
   * Log entries with timestamps that are more than the
   * [logs retention period](/logging/quota-policy) in the past or more than
   * 24 hours in the future might be discarded. Discarding does not return
   * an error.
   *
   * To improve throughput and to avoid exceeding the
   * [quota limit](/logging/quota-policy) for calls to `entries.write`,
   * you should try to include several log entries in this list,
   * rather than calling this method for each individual log entry.
   *
   * @generated from field: repeated google.logging.v2.LogEntry entries = 4;
   */
  entries: LogEntry[] = [];

  /**
   * Optional. Whether valid entries should be written even if some other
   * entries fail due to INVALID_ARGUMENT or PERMISSION_DENIED errors. If any
   * entry is not written, then the response status is the error associated
   * with one of the failed entries and the response includes error details
   * keyed by the entries' zero-based index in the `entries.write` method.
   *
   * @generated from field: bool partial_success = 5;
   */
  partialSuccess = false;

  constructor(data?: PartialMessage<WriteLogEntriesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.WriteLogEntriesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "log_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "resource", kind: "message", T: MonitoredResource },
    { no: 3, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 4, name: "entries", kind: "message", T: LogEntry, repeated: true },
    { no: 5, name: "partial_success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WriteLogEntriesRequest {
    return new WriteLogEntriesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WriteLogEntriesRequest {
    return new WriteLogEntriesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WriteLogEntriesRequest {
    return new WriteLogEntriesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: WriteLogEntriesRequest | PlainMessage<WriteLogEntriesRequest> | undefined, b: WriteLogEntriesRequest | PlainMessage<WriteLogEntriesRequest> | undefined): boolean {
    return proto3.util.equals(WriteLogEntriesRequest, a, b);
  }
}

/**
 * Result returned from WriteLogEntries.
 * empty
 *
 * @generated from message google.logging.v2.WriteLogEntriesResponse
 */
export class WriteLogEntriesResponse extends Message<WriteLogEntriesResponse> {
  constructor(data?: PartialMessage<WriteLogEntriesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.WriteLogEntriesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WriteLogEntriesResponse {
    return new WriteLogEntriesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WriteLogEntriesResponse {
    return new WriteLogEntriesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WriteLogEntriesResponse {
    return new WriteLogEntriesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: WriteLogEntriesResponse | PlainMessage<WriteLogEntriesResponse> | undefined, b: WriteLogEntriesResponse | PlainMessage<WriteLogEntriesResponse> | undefined): boolean {
    return proto3.util.equals(WriteLogEntriesResponse, a, b);
  }
}

/**
 * Error details for WriteLogEntries with partial success.
 *
 * @generated from message google.logging.v2.WriteLogEntriesPartialErrors
 */
export class WriteLogEntriesPartialErrors extends Message<WriteLogEntriesPartialErrors> {
  /**
   * When `WriteLogEntriesRequest.partial_success` is true, records the error
   * status for entries that were not written due to a permanent error, keyed
   * by the entry's zero-based index in `WriteLogEntriesRequest.entries`.
   *
   * Failed requests for which no entries are written will not include
   * per-entry errors.
   *
   * @generated from field: map<int32, google.rpc.Status> log_entry_errors = 1;
   */
  logEntryErrors: { [key: number]: Status } = {};

  constructor(data?: PartialMessage<WriteLogEntriesPartialErrors>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.WriteLogEntriesPartialErrors";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "log_entry_errors", kind: "map", K: 5 /* ScalarType.INT32 */, V: {kind: "message", T: Status} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WriteLogEntriesPartialErrors {
    return new WriteLogEntriesPartialErrors().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WriteLogEntriesPartialErrors {
    return new WriteLogEntriesPartialErrors().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WriteLogEntriesPartialErrors {
    return new WriteLogEntriesPartialErrors().fromJsonString(jsonString, options);
  }

  static equals(a: WriteLogEntriesPartialErrors | PlainMessage<WriteLogEntriesPartialErrors> | undefined, b: WriteLogEntriesPartialErrors | PlainMessage<WriteLogEntriesPartialErrors> | undefined): boolean {
    return proto3.util.equals(WriteLogEntriesPartialErrors, a, b);
  }
}

/**
 * The parameters to `ListLogEntries`.
 *
 * @generated from message google.logging.v2.ListLogEntriesRequest
 */
export class ListLogEntriesRequest extends Message<ListLogEntriesRequest> {
  /**
   * Deprecated. Use `resource_names` instead.  One or more project identifiers
   * or project numbers from which to retrieve log entries.  Example:
   * `"my-project-1A"`. If present, these project identifiers are converted to
   * resource name format and added to the list of resources in
   * `resource_names`.
   *
   * @generated from field: repeated string project_ids = 1;
   */
  projectIds: string[] = [];

  /**
   * Required. Names of one or more parent resources from which to
   * retrieve log entries:
   *
   *     "projects/[PROJECT_ID]"
   *     "organizations/[ORGANIZATION_ID]"
   *     "billingAccounts/[BILLING_ACCOUNT_ID]"
   *     "folders/[FOLDER_ID]"
   *
   * Projects listed in the `project_ids` field are added to this list.
   *
   * @generated from field: repeated string resource_names = 8;
   */
  resourceNames: string[] = [];

  /**
   * Optional. A filter that chooses which log entries to return.  See [Advanced
   * Logs Filters](/logging/docs/view/advanced_filters).  Only log entries that
   * match the filter are returned.  An empty filter matches all log entries in
   * the resources listed in `resource_names`. Referencing a parent resource
   * that is not listed in `resource_names` will cause the filter to return no
   * results.
   * The maximum length of the filter is 20000 characters.
   *
   * @generated from field: string filter = 2;
   */
  filter = "";

  /**
   * Optional. How the results should be sorted.  Presently, the only permitted
   * values are `"timestamp asc"` (default) and `"timestamp desc"`. The first
   * option returns entries in order of increasing values of
   * `LogEntry.timestamp` (oldest first), and the second option returns entries
   * in order of decreasing timestamps (newest first).  Entries with equal
   * timestamps are returned in order of their `insert_id` values.
   *
   * @generated from field: string order_by = 3;
   */
  orderBy = "";

  /**
   * Optional. The maximum number of results to return from this request.
   * Non-positive values are ignored.  The presence of `next_page_token` in the
   * response indicates that more results might be available.
   *
   * @generated from field: int32 page_size = 4;
   */
  pageSize = 0;

  /**
   * Optional. If present, then retrieve the next batch of results from the
   * preceding call to this method.  `page_token` must be the value of
   * `next_page_token` from the previous response.  The values of other method
   * parameters should be identical to those in the previous call.
   *
   * @generated from field: string page_token = 5;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListLogEntriesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.ListLogEntriesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "project_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 8, name: "resource_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "order_by", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListLogEntriesRequest {
    return new ListLogEntriesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListLogEntriesRequest {
    return new ListLogEntriesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListLogEntriesRequest {
    return new ListLogEntriesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListLogEntriesRequest | PlainMessage<ListLogEntriesRequest> | undefined, b: ListLogEntriesRequest | PlainMessage<ListLogEntriesRequest> | undefined): boolean {
    return proto3.util.equals(ListLogEntriesRequest, a, b);
  }
}

/**
 * Result returned from `ListLogEntries`.
 *
 * @generated from message google.logging.v2.ListLogEntriesResponse
 */
export class ListLogEntriesResponse extends Message<ListLogEntriesResponse> {
  /**
   * A list of log entries.  If `entries` is empty, `nextPageToken` may still be
   * returned, indicating that more entries may exist.  See `nextPageToken` for
   * more information.
   *
   * @generated from field: repeated google.logging.v2.LogEntry entries = 1;
   */
  entries: LogEntry[] = [];

  /**
   * If there might be more results than those appearing in this response, then
   * `nextPageToken` is included.  To get the next set of results, call this
   * method again using the value of `nextPageToken` as `pageToken`.
   *
   * If a value for `next_page_token` appears and the `entries` field is empty,
   * it means that the search found no log entries so far but it did not have
   * time to search all the possible log entries.  Retry the method with this
   * value for `page_token` to continue the search.  Alternatively, consider
   * speeding up the search by changing your filter to specify a single log name
   * or resource type, or to narrow the time range of the search.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListLogEntriesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.ListLogEntriesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "entries", kind: "message", T: LogEntry, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListLogEntriesResponse {
    return new ListLogEntriesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListLogEntriesResponse {
    return new ListLogEntriesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListLogEntriesResponse {
    return new ListLogEntriesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListLogEntriesResponse | PlainMessage<ListLogEntriesResponse> | undefined, b: ListLogEntriesResponse | PlainMessage<ListLogEntriesResponse> | undefined): boolean {
    return proto3.util.equals(ListLogEntriesResponse, a, b);
  }
}

/**
 * The parameters to ListMonitoredResourceDescriptors
 *
 * @generated from message google.logging.v2.ListMonitoredResourceDescriptorsRequest
 */
export class ListMonitoredResourceDescriptorsRequest extends Message<ListMonitoredResourceDescriptorsRequest> {
  /**
   * Optional. The maximum number of results to return from this request.
   * Non-positive values are ignored.  The presence of `nextPageToken` in the
   * response indicates that more results might be available.
   *
   * @generated from field: int32 page_size = 1;
   */
  pageSize = 0;

  /**
   * Optional. If present, then retrieve the next batch of results from the
   * preceding call to this method.  `pageToken` must be the value of
   * `nextPageToken` from the previous response.  The values of other method
   * parameters should be identical to those in the previous call.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListMonitoredResourceDescriptorsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.ListMonitoredResourceDescriptorsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListMonitoredResourceDescriptorsRequest {
    return new ListMonitoredResourceDescriptorsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListMonitoredResourceDescriptorsRequest {
    return new ListMonitoredResourceDescriptorsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListMonitoredResourceDescriptorsRequest {
    return new ListMonitoredResourceDescriptorsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListMonitoredResourceDescriptorsRequest | PlainMessage<ListMonitoredResourceDescriptorsRequest> | undefined, b: ListMonitoredResourceDescriptorsRequest | PlainMessage<ListMonitoredResourceDescriptorsRequest> | undefined): boolean {
    return proto3.util.equals(ListMonitoredResourceDescriptorsRequest, a, b);
  }
}

/**
 * Result returned from ListMonitoredResourceDescriptors.
 *
 * @generated from message google.logging.v2.ListMonitoredResourceDescriptorsResponse
 */
export class ListMonitoredResourceDescriptorsResponse extends Message<ListMonitoredResourceDescriptorsResponse> {
  /**
   * A list of resource descriptors.
   *
   * @generated from field: repeated google.api.MonitoredResourceDescriptor resource_descriptors = 1;
   */
  resourceDescriptors: MonitoredResourceDescriptor[] = [];

  /**
   * If there might be more results than those appearing in this response, then
   * `nextPageToken` is included.  To get the next set of results, call this
   * method again using the value of `nextPageToken` as `pageToken`.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListMonitoredResourceDescriptorsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.ListMonitoredResourceDescriptorsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource_descriptors", kind: "message", T: MonitoredResourceDescriptor, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListMonitoredResourceDescriptorsResponse {
    return new ListMonitoredResourceDescriptorsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListMonitoredResourceDescriptorsResponse {
    return new ListMonitoredResourceDescriptorsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListMonitoredResourceDescriptorsResponse {
    return new ListMonitoredResourceDescriptorsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListMonitoredResourceDescriptorsResponse | PlainMessage<ListMonitoredResourceDescriptorsResponse> | undefined, b: ListMonitoredResourceDescriptorsResponse | PlainMessage<ListMonitoredResourceDescriptorsResponse> | undefined): boolean {
    return proto3.util.equals(ListMonitoredResourceDescriptorsResponse, a, b);
  }
}

/**
 * The parameters to ListLogs.
 *
 * @generated from message google.logging.v2.ListLogsRequest
 */
export class ListLogsRequest extends Message<ListLogsRequest> {
  /**
   * Required. The resource name that owns the logs:
   *
   *     "projects/[PROJECT_ID]"
   *     "organizations/[ORGANIZATION_ID]"
   *     "billingAccounts/[BILLING_ACCOUNT_ID]"
   *     "folders/[FOLDER_ID]"
   *
   * @generated from field: string parent = 1;
   */
  parent = "";

  /**
   * Optional. The maximum number of results to return from this request.
   * Non-positive values are ignored.  The presence of `nextPageToken` in the
   * response indicates that more results might be available.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * Optional. If present, then retrieve the next batch of results from the
   * preceding call to this method.  `pageToken` must be the value of
   * `nextPageToken` from the previous response.  The values of other method
   * parameters should be identical to those in the previous call.
   *
   * @generated from field: string page_token = 3;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListLogsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.ListLogsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListLogsRequest {
    return new ListLogsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListLogsRequest {
    return new ListLogsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListLogsRequest {
    return new ListLogsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListLogsRequest | PlainMessage<ListLogsRequest> | undefined, b: ListLogsRequest | PlainMessage<ListLogsRequest> | undefined): boolean {
    return proto3.util.equals(ListLogsRequest, a, b);
  }
}

/**
 * Result returned from ListLogs.
 *
 * @generated from message google.logging.v2.ListLogsResponse
 */
export class ListLogsResponse extends Message<ListLogsResponse> {
  /**
   * A list of log names. For example,
   * `"projects/my-project/syslog"` or
   * `"organizations/123/cloudresourcemanager.googleapis.com%2Factivity"`.
   *
   * @generated from field: repeated string log_names = 3;
   */
  logNames: string[] = [];

  /**
   * If there might be more results than those appearing in this response, then
   * `nextPageToken` is included.  To get the next set of results, call this
   * method again using the value of `nextPageToken` as `pageToken`.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListLogsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.ListLogsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "log_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListLogsResponse {
    return new ListLogsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListLogsResponse {
    return new ListLogsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListLogsResponse {
    return new ListLogsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListLogsResponse | PlainMessage<ListLogsResponse> | undefined, b: ListLogsResponse | PlainMessage<ListLogsResponse> | undefined): boolean {
    return proto3.util.equals(ListLogsResponse, a, b);
  }
}

