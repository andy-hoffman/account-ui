// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/logging/v2/logging_config.proto (package google.logging.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { FieldMask, Message, proto3, Timestamp } from "@bufbuild/protobuf";

/**
 * Describes a sink used to export log entries to one of the following
 * destinations in any project: a Cloud Storage bucket, a BigQuery dataset, or a
 * Cloud Pub/Sub topic.  A logs filter controls which log entries are
 * exported. The sink must be created within a project, organization, billing
 * account, or folder.
 *
 * @generated from message google.logging.v2.LogSink
 */
export class LogSink extends Message<LogSink> {
  /**
   * Required. The client-assigned sink identifier, unique within the
   * project. Example: `"my-syslog-errors-to-pubsub"`.  Sink identifiers are
   * limited to 100 characters and can include only the following characters:
   * upper and lower-case alphanumeric characters, underscores, hyphens, and
   * periods.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Required. The export destination:
   *
   *     "storage.googleapis.com/[GCS_BUCKET]"
   *     "bigquery.googleapis.com/projects/[PROJECT_ID]/datasets/[DATASET]"
   *     "pubsub.googleapis.com/projects/[PROJECT_ID]/topics/[TOPIC_ID]"
   *
   * The sink's `writer_identity`, set when the sink is created, must
   * have permission to write to the destination or else the log
   * entries are not exported.  For more information, see
   * [Exporting Logs With Sinks](/logging/docs/api/tasks/exporting-logs).
   *
   * @generated from field: string destination = 3;
   */
  destination = "";

  /**
   * Optional.
   * An [advanced logs filter](/logging/docs/view/advanced_filters).  The only
   * exported log entries are those that are in the resource owning the sink and
   * that match the filter. The filter must use the log entry format specified
   * by the `output_version_format` parameter.  For example, in the v2 format:
   *
   *     logName="projects/[PROJECT_ID]/logs/[LOG_ID]" AND severity>=ERROR
   *
   * @generated from field: string filter = 5;
   */
  filter = "";

  /**
   * Deprecated. The log entry format to use for this sink's exported log
   * entries.  The v2 format is used by default and cannot be changed.
   *
   * @generated from field: google.logging.v2.LogSink.VersionFormat output_version_format = 6;
   */
  outputVersionFormat = LogSink_VersionFormat.VERSION_FORMAT_UNSPECIFIED;

  /**
   * Output only. An IAM identity&mdash;a service account or group&mdash;under
   * which Stackdriver Logging writes the exported log entries to the sink's
   * destination.  This field is set by
   * [sinks.create](/logging/docs/api/reference/rest/v2/projects.sinks/create)
   * and
   * [sinks.update](/logging/docs/api/reference/rest/v2/projects.sinks/update),
   * based on the setting of `unique_writer_identity` in those methods.
   *
   * Until you grant this identity write-access to the destination, log entry
   * exports from this sink will fail. For more information,
   * see [Granting access for a
   * resource](/iam/docs/granting-roles-to-service-accounts#granting_access_to_a_service_account_for_a_resource).
   * Consult the destination service's documentation to determine the
   * appropriate IAM roles to assign to the identity.
   *
   * @generated from field: string writer_identity = 8;
   */
  writerIdentity = "";

  /**
   * Optional. This field applies only to sinks owned by organizations and
   * folders. If the field is false, the default, only the logs owned by the
   * sink's parent resource are available for export. If the field is true, then
   * logs from all the projects, folders, and billing accounts contained in the
   * sink's parent resource are also available for export. Whether a particular
   * log entry from the children is exported depends on the sink's filter
   * expression. For example, if this field is true, then the filter
   * `resource.type=gce_instance` would export all Compute Engine VM instance
   * log entries from all projects in the sink's parent. To only export entries
   * from certain child projects, filter on the project part of the log name:
   *
   *     logName:("projects/test-project1/" OR "projects/test-project2/") AND
   *     resource.type=gce_instance
   *
   * @generated from field: bool include_children = 9;
   */
  includeChildren = false;

  /**
   * Optional. The time at which this sink will begin exporting log entries.
   * Log entries are exported only if their timestamp is not earlier than the
   * start time.  The default value of this field is the time the sink is
   * created or updated.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 10;
   */
  startTime?: Timestamp;

  /**
   * Optional. The time at which this sink will stop exporting log entries.  Log
   * entries are exported only if their timestamp is earlier than the end time.
   * If this field is not supplied, there is no end time.  If both a start time
   * and an end time are provided, then the end time must be later than the
   * start time.
   *
   * @generated from field: google.protobuf.Timestamp end_time = 11;
   */
  endTime?: Timestamp;

  constructor(data?: PartialMessage<LogSink>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.LogSink";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "destination", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "output_version_format", kind: "enum", T: proto3.getEnumType(LogSink_VersionFormat) },
    { no: 8, name: "writer_identity", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "include_children", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "start_time", kind: "message", T: Timestamp },
    { no: 11, name: "end_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogSink {
    return new LogSink().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogSink {
    return new LogSink().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogSink {
    return new LogSink().fromJsonString(jsonString, options);
  }

  static equals(a: LogSink | PlainMessage<LogSink> | undefined, b: LogSink | PlainMessage<LogSink> | undefined): boolean {
    return proto3.util.equals(LogSink, a, b);
  }
}

/**
 * Available log entry formats. Log entries can be written to Stackdriver
 * Logging in either format and can be exported in either format.
 * Version 2 is the preferred format.
 *
 * @generated from enum google.logging.v2.LogSink.VersionFormat
 */
export enum LogSink_VersionFormat {
  /**
   * An unspecified format version that will default to V2.
   *
   * @generated from enum value: VERSION_FORMAT_UNSPECIFIED = 0;
   */
  VERSION_FORMAT_UNSPECIFIED = 0,

  /**
   * `LogEntry` version 2 format.
   *
   * @generated from enum value: V2 = 1;
   */
  V2 = 1,

  /**
   * `LogEntry` version 1 format.
   *
   * @generated from enum value: V1 = 2;
   */
  V1 = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(LogSink_VersionFormat)
proto3.util.setEnumType(LogSink_VersionFormat, "google.logging.v2.LogSink.VersionFormat", [
  { no: 0, name: "VERSION_FORMAT_UNSPECIFIED" },
  { no: 1, name: "V2" },
  { no: 2, name: "V1" },
]);

/**
 * The parameters to `ListSinks`.
 *
 * @generated from message google.logging.v2.ListSinksRequest
 */
export class ListSinksRequest extends Message<ListSinksRequest> {
  /**
   * Required. The parent resource whose sinks are to be listed:
   *
   *     "projects/[PROJECT_ID]"
   *     "organizations/[ORGANIZATION_ID]"
   *     "billingAccounts/[BILLING_ACCOUNT_ID]"
   *     "folders/[FOLDER_ID]"
   *
   * @generated from field: string parent = 1;
   */
  parent = "";

  /**
   * Optional. If present, then retrieve the next batch of results from the
   * preceding call to this method.  `pageToken` must be the value of
   * `nextPageToken` from the previous response.  The values of other method
   * parameters should be identical to those in the previous call.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  /**
   * Optional. The maximum number of results to return from this request.
   * Non-positive values are ignored.  The presence of `nextPageToken` in the
   * response indicates that more results might be available.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize = 0;

  constructor(data?: PartialMessage<ListSinksRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.ListSinksRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSinksRequest {
    return new ListSinksRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSinksRequest {
    return new ListSinksRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSinksRequest {
    return new ListSinksRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListSinksRequest | PlainMessage<ListSinksRequest> | undefined, b: ListSinksRequest | PlainMessage<ListSinksRequest> | undefined): boolean {
    return proto3.util.equals(ListSinksRequest, a, b);
  }
}

/**
 * Result returned from `ListSinks`.
 *
 * @generated from message google.logging.v2.ListSinksResponse
 */
export class ListSinksResponse extends Message<ListSinksResponse> {
  /**
   * A list of sinks.
   *
   * @generated from field: repeated google.logging.v2.LogSink sinks = 1;
   */
  sinks: LogSink[] = [];

  /**
   * If there might be more results than appear in this response, then
   * `nextPageToken` is included.  To get the next set of results, call the same
   * method again using the value of `nextPageToken` as `pageToken`.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListSinksResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.ListSinksResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sinks", kind: "message", T: LogSink, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListSinksResponse {
    return new ListSinksResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListSinksResponse {
    return new ListSinksResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListSinksResponse {
    return new ListSinksResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListSinksResponse | PlainMessage<ListSinksResponse> | undefined, b: ListSinksResponse | PlainMessage<ListSinksResponse> | undefined): boolean {
    return proto3.util.equals(ListSinksResponse, a, b);
  }
}

/**
 * The parameters to `GetSink`.
 *
 * @generated from message google.logging.v2.GetSinkRequest
 */
export class GetSinkRequest extends Message<GetSinkRequest> {
  /**
   * Required. The resource name of the sink:
   *
   *     "projects/[PROJECT_ID]/sinks/[SINK_ID]"
   *     "organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]"
   *     "billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]"
   *     "folders/[FOLDER_ID]/sinks/[SINK_ID]"
   *
   * Example: `"projects/my-project-id/sinks/my-sink-id"`.
   *
   * @generated from field: string sink_name = 1;
   */
  sinkName = "";

  constructor(data?: PartialMessage<GetSinkRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.GetSinkRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sink_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetSinkRequest {
    return new GetSinkRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetSinkRequest {
    return new GetSinkRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetSinkRequest {
    return new GetSinkRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetSinkRequest | PlainMessage<GetSinkRequest> | undefined, b: GetSinkRequest | PlainMessage<GetSinkRequest> | undefined): boolean {
    return proto3.util.equals(GetSinkRequest, a, b);
  }
}

/**
 * The parameters to `CreateSink`.
 *
 * @generated from message google.logging.v2.CreateSinkRequest
 */
export class CreateSinkRequest extends Message<CreateSinkRequest> {
  /**
   * Required. The resource in which to create the sink:
   *
   *     "projects/[PROJECT_ID]"
   *     "organizations/[ORGANIZATION_ID]"
   *     "billingAccounts/[BILLING_ACCOUNT_ID]"
   *     "folders/[FOLDER_ID]"
   *
   * Examples: `"projects/my-logging-project"`, `"organizations/123456789"`.
   *
   * @generated from field: string parent = 1;
   */
  parent = "";

  /**
   * Required. The new sink, whose `name` parameter is a sink identifier that
   * is not already in use.
   *
   * @generated from field: google.logging.v2.LogSink sink = 2;
   */
  sink?: LogSink;

  /**
   * Optional. Determines the kind of IAM identity returned as `writer_identity`
   * in the new sink.  If this value is omitted or set to false, and if the
   * sink's parent is a project, then the value returned as `writer_identity` is
   * the same group or service account used by Stackdriver Logging before the
   * addition of writer identities to this API. The sink's destination must be
   * in the same project as the sink itself.
   *
   * If this field is set to true, or if the sink is owned by a non-project
   * resource such as an organization, then the value of `writer_identity` will
   * be a unique service account used only for exports from the new sink.  For
   * more information, see `writer_identity` in [LogSink][google.logging.v2.LogSink].
   *
   * @generated from field: bool unique_writer_identity = 3;
   */
  uniqueWriterIdentity = false;

  constructor(data?: PartialMessage<CreateSinkRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.CreateSinkRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sink", kind: "message", T: LogSink },
    { no: 3, name: "unique_writer_identity", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateSinkRequest {
    return new CreateSinkRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateSinkRequest {
    return new CreateSinkRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateSinkRequest {
    return new CreateSinkRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateSinkRequest | PlainMessage<CreateSinkRequest> | undefined, b: CreateSinkRequest | PlainMessage<CreateSinkRequest> | undefined): boolean {
    return proto3.util.equals(CreateSinkRequest, a, b);
  }
}

/**
 * The parameters to `UpdateSink`.
 *
 * @generated from message google.logging.v2.UpdateSinkRequest
 */
export class UpdateSinkRequest extends Message<UpdateSinkRequest> {
  /**
   * Required. The full resource name of the sink to update, including the
   * parent resource and the sink identifier:
   *
   *     "projects/[PROJECT_ID]/sinks/[SINK_ID]"
   *     "organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]"
   *     "billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]"
   *     "folders/[FOLDER_ID]/sinks/[SINK_ID]"
   *
   * Example: `"projects/my-project-id/sinks/my-sink-id"`.
   *
   * @generated from field: string sink_name = 1;
   */
  sinkName = "";

  /**
   * Required. The updated sink, whose name is the same identifier that appears
   * as part of `sink_name`.
   *
   * @generated from field: google.logging.v2.LogSink sink = 2;
   */
  sink?: LogSink;

  /**
   * Optional. See
   * [sinks.create](/logging/docs/api/reference/rest/v2/projects.sinks/create)
   * for a description of this field.  When updating a sink, the effect of this
   * field on the value of `writer_identity` in the updated sink depends on both
   * the old and new values of this field:
   *
   * +   If the old and new values of this field are both false or both true,
   *     then there is no change to the sink's `writer_identity`.
   * +   If the old value is false and the new value is true, then
   *     `writer_identity` is changed to a unique service account.
   * +   It is an error if the old value is true and the new value is
   *     set to false or defaulted to false.
   *
   * @generated from field: bool unique_writer_identity = 3;
   */
  uniqueWriterIdentity = false;

  constructor(data?: PartialMessage<UpdateSinkRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.UpdateSinkRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sink_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sink", kind: "message", T: LogSink },
    { no: 3, name: "unique_writer_identity", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateSinkRequest {
    return new UpdateSinkRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateSinkRequest {
    return new UpdateSinkRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateSinkRequest {
    return new UpdateSinkRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateSinkRequest | PlainMessage<UpdateSinkRequest> | undefined, b: UpdateSinkRequest | PlainMessage<UpdateSinkRequest> | undefined): boolean {
    return proto3.util.equals(UpdateSinkRequest, a, b);
  }
}

/**
 * The parameters to `DeleteSink`.
 *
 * @generated from message google.logging.v2.DeleteSinkRequest
 */
export class DeleteSinkRequest extends Message<DeleteSinkRequest> {
  /**
   * Required. The full resource name of the sink to delete, including the
   * parent resource and the sink identifier:
   *
   *     "projects/[PROJECT_ID]/sinks/[SINK_ID]"
   *     "organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]"
   *     "billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]"
   *     "folders/[FOLDER_ID]/sinks/[SINK_ID]"
   *
   * Example: `"projects/my-project-id/sinks/my-sink-id"`.
   *
   * @generated from field: string sink_name = 1;
   */
  sinkName = "";

  constructor(data?: PartialMessage<DeleteSinkRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.DeleteSinkRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sink_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteSinkRequest {
    return new DeleteSinkRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteSinkRequest {
    return new DeleteSinkRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteSinkRequest {
    return new DeleteSinkRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteSinkRequest | PlainMessage<DeleteSinkRequest> | undefined, b: DeleteSinkRequest | PlainMessage<DeleteSinkRequest> | undefined): boolean {
    return proto3.util.equals(DeleteSinkRequest, a, b);
  }
}

/**
 * Specifies a set of log entries that are not to be stored in Stackdriver
 * Logging. If your project receives a large volume of logs, you might be able
 * to use exclusions to reduce your chargeable logs. Exclusions are processed
 * after log sinks, so you can export log entries before they are excluded.
 * Audit log entries and log entries from Amazon Web Services are never
 * excluded.
 *
 * @generated from message google.logging.v2.LogExclusion
 */
export class LogExclusion extends Message<LogExclusion> {
  /**
   * Required. A client-assigned identifier, such as
   * `"load-balancer-exclusion"`. Identifiers are limited to 100 characters and
   * can include only letters, digits, underscores, hyphens, and periods.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Optional. A description of this exclusion.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * Required.
   * An [advanced logs filter](/logging/docs/view/advanced_filters)
   * that matches the log entries to be excluded. By using the
   * [sample function](/logging/docs/view/advanced_filters#sample),
   * you can exclude less than 100% of the matching log entries.
   * For example, the following filter matches 99% of low-severity log
   * entries from load balancers:
   *
   *     "resource.type=http_load_balancer severity<ERROR sample(insertId, 0.99)"
   *
   * @generated from field: string filter = 3;
   */
  filter = "";

  /**
   * Optional. If set to True, then this exclusion is disabled and it does not
   * exclude any log entries. You can use
   * [exclusions.patch](/logging/docs/alpha-exclusion/docs/reference/v2/rest/v2/projects.exclusions/patch)
   * to change the value of this field.
   *
   * @generated from field: bool disabled = 4;
   */
  disabled = false;

  constructor(data?: PartialMessage<LogExclusion>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.LogExclusion";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "disabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogExclusion {
    return new LogExclusion().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogExclusion {
    return new LogExclusion().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogExclusion {
    return new LogExclusion().fromJsonString(jsonString, options);
  }

  static equals(a: LogExclusion | PlainMessage<LogExclusion> | undefined, b: LogExclusion | PlainMessage<LogExclusion> | undefined): boolean {
    return proto3.util.equals(LogExclusion, a, b);
  }
}

/**
 * The parameters to `ListExclusions`.
 *
 * @generated from message google.logging.v2.ListExclusionsRequest
 */
export class ListExclusionsRequest extends Message<ListExclusionsRequest> {
  /**
   * Required. The parent resource whose exclusions are to be listed.
   *
   *     "projects/[PROJECT_ID]"
   *     "organizations/[ORGANIZATION_ID]"
   *     "billingAccounts/[BILLING_ACCOUNT_ID]"
   *     "folders/[FOLDER_ID]"
   *
   * @generated from field: string parent = 1;
   */
  parent = "";

  /**
   * Optional. If present, then retrieve the next batch of results from the
   * preceding call to this method.  `pageToken` must be the value of
   * `nextPageToken` from the previous response.  The values of other method
   * parameters should be identical to those in the previous call.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  /**
   * Optional. The maximum number of results to return from this request.
   * Non-positive values are ignored.  The presence of `nextPageToken` in the
   * response indicates that more results might be available.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize = 0;

  constructor(data?: PartialMessage<ListExclusionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.ListExclusionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListExclusionsRequest {
    return new ListExclusionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListExclusionsRequest {
    return new ListExclusionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListExclusionsRequest {
    return new ListExclusionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListExclusionsRequest | PlainMessage<ListExclusionsRequest> | undefined, b: ListExclusionsRequest | PlainMessage<ListExclusionsRequest> | undefined): boolean {
    return proto3.util.equals(ListExclusionsRequest, a, b);
  }
}

/**
 * Result returned from `ListExclusions`.
 *
 * @generated from message google.logging.v2.ListExclusionsResponse
 */
export class ListExclusionsResponse extends Message<ListExclusionsResponse> {
  /**
   * A list of exclusions.
   *
   * @generated from field: repeated google.logging.v2.LogExclusion exclusions = 1;
   */
  exclusions: LogExclusion[] = [];

  /**
   * If there might be more results than appear in this response, then
   * `nextPageToken` is included.  To get the next set of results, call the same
   * method again using the value of `nextPageToken` as `pageToken`.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListExclusionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.ListExclusionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "exclusions", kind: "message", T: LogExclusion, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListExclusionsResponse {
    return new ListExclusionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListExclusionsResponse {
    return new ListExclusionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListExclusionsResponse {
    return new ListExclusionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListExclusionsResponse | PlainMessage<ListExclusionsResponse> | undefined, b: ListExclusionsResponse | PlainMessage<ListExclusionsResponse> | undefined): boolean {
    return proto3.util.equals(ListExclusionsResponse, a, b);
  }
}

/**
 * The parameters to `GetExclusion`.
 *
 * @generated from message google.logging.v2.GetExclusionRequest
 */
export class GetExclusionRequest extends Message<GetExclusionRequest> {
  /**
   * Required. The resource name of an existing exclusion:
   *
   *     "projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]"
   *     "organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]"
   *     "billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]"
   *     "folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]"
   *
   * Example: `"projects/my-project-id/exclusions/my-exclusion-id"`.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<GetExclusionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.GetExclusionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetExclusionRequest {
    return new GetExclusionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetExclusionRequest {
    return new GetExclusionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetExclusionRequest {
    return new GetExclusionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetExclusionRequest | PlainMessage<GetExclusionRequest> | undefined, b: GetExclusionRequest | PlainMessage<GetExclusionRequest> | undefined): boolean {
    return proto3.util.equals(GetExclusionRequest, a, b);
  }
}

/**
 * The parameters to `CreateExclusion`.
 *
 * @generated from message google.logging.v2.CreateExclusionRequest
 */
export class CreateExclusionRequest extends Message<CreateExclusionRequest> {
  /**
   * Required. The parent resource in which to create the exclusion:
   *
   *     "projects/[PROJECT_ID]"
   *     "organizations/[ORGANIZATION_ID]"
   *     "billingAccounts/[BILLING_ACCOUNT_ID]"
   *     "folders/[FOLDER_ID]"
   *
   * Examples: `"projects/my-logging-project"`, `"organizations/123456789"`.
   *
   * @generated from field: string parent = 1;
   */
  parent = "";

  /**
   * Required. The new exclusion, whose `name` parameter is an exclusion name
   * that is not already used in the parent resource.
   *
   * @generated from field: google.logging.v2.LogExclusion exclusion = 2;
   */
  exclusion?: LogExclusion;

  constructor(data?: PartialMessage<CreateExclusionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.CreateExclusionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "exclusion", kind: "message", T: LogExclusion },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateExclusionRequest {
    return new CreateExclusionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateExclusionRequest {
    return new CreateExclusionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateExclusionRequest {
    return new CreateExclusionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateExclusionRequest | PlainMessage<CreateExclusionRequest> | undefined, b: CreateExclusionRequest | PlainMessage<CreateExclusionRequest> | undefined): boolean {
    return proto3.util.equals(CreateExclusionRequest, a, b);
  }
}

/**
 * The parameters to `UpdateExclusion`.
 *
 * @generated from message google.logging.v2.UpdateExclusionRequest
 */
export class UpdateExclusionRequest extends Message<UpdateExclusionRequest> {
  /**
   * Required. The resource name of the exclusion to update:
   *
   *     "projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]"
   *     "organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]"
   *     "billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]"
   *     "folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]"
   *
   * Example: `"projects/my-project-id/exclusions/my-exclusion-id"`.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Required. New values for the existing exclusion. Only the fields specified
   * in `update_mask` are relevant.
   *
   * @generated from field: google.logging.v2.LogExclusion exclusion = 2;
   */
  exclusion?: LogExclusion;

  /**
   * Required. A nonempty list of fields to change in the existing exclusion.
   * New values for the fields are taken from the corresponding fields in the
   * [LogExclusion][google.logging.v2.LogExclusion] included in this request. Fields not mentioned in
   * `update_mask` are not changed and are ignored in the request.
   *
   * For example, to change the filter and description of an exclusion,
   * specify an `update_mask` of `"filter,description"`.
   *
   * @generated from field: google.protobuf.FieldMask update_mask = 3;
   */
  updateMask?: FieldMask;

  constructor(data?: PartialMessage<UpdateExclusionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.UpdateExclusionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "exclusion", kind: "message", T: LogExclusion },
    { no: 3, name: "update_mask", kind: "message", T: FieldMask },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateExclusionRequest {
    return new UpdateExclusionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateExclusionRequest {
    return new UpdateExclusionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateExclusionRequest {
    return new UpdateExclusionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateExclusionRequest | PlainMessage<UpdateExclusionRequest> | undefined, b: UpdateExclusionRequest | PlainMessage<UpdateExclusionRequest> | undefined): boolean {
    return proto3.util.equals(UpdateExclusionRequest, a, b);
  }
}

/**
 * The parameters to `DeleteExclusion`.
 *
 * @generated from message google.logging.v2.DeleteExclusionRequest
 */
export class DeleteExclusionRequest extends Message<DeleteExclusionRequest> {
  /**
   * Required. The resource name of an existing exclusion to delete:
   *
   *     "projects/[PROJECT_ID]/exclusions/[EXCLUSION_ID]"
   *     "organizations/[ORGANIZATION_ID]/exclusions/[EXCLUSION_ID]"
   *     "billingAccounts/[BILLING_ACCOUNT_ID]/exclusions/[EXCLUSION_ID]"
   *     "folders/[FOLDER_ID]/exclusions/[EXCLUSION_ID]"
   *
   * Example: `"projects/my-project-id/exclusions/my-exclusion-id"`.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<DeleteExclusionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.DeleteExclusionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteExclusionRequest {
    return new DeleteExclusionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteExclusionRequest {
    return new DeleteExclusionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteExclusionRequest {
    return new DeleteExclusionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteExclusionRequest | PlainMessage<DeleteExclusionRequest> | undefined, b: DeleteExclusionRequest | PlainMessage<DeleteExclusionRequest> | undefined): boolean {
    return proto3.util.equals(DeleteExclusionRequest, a, b);
  }
}

