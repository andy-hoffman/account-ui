// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/logging/v2/logging_metrics.proto (package google.logging.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { MetricDescriptor } from "../../api/metric_pb.js";
import { Distribution_BucketOptions } from "../../api/distribution_pb.js";

/**
 * Describes a logs-based metric.  The value of the metric is the
 * number of log entries that match a logs filter in a given time interval.
 *
 * A logs-based metric can also be used to extract values from logs and create a
 * a distribution of the values. The distribution records the statistics of the
 * extracted values along with an optional histogram of the values as specified
 * by the bucket options.
 *
 * @generated from message google.logging.v2.LogMetric
 */
export class LogMetric extends Message<LogMetric> {
  /**
   * Required. The client-assigned metric identifier.
   * Examples: `"error_count"`, `"nginx/requests"`.
   *
   * Metric identifiers are limited to 100 characters and can include
   * only the following characters: `A-Z`, `a-z`, `0-9`, and the
   * special characters `_-.,+!*',()%/`.  The forward-slash character
   * (`/`) denotes a hierarchy of name pieces, and it cannot be the
   * first character of the name.
   *
   * The metric identifier in this field must not be
   * [URL-encoded](https://en.wikipedia.org/wiki/Percent-encoding).
   * However, when the metric identifier appears as the `[METRIC_ID]`
   * part of a `metric_name` API parameter, then the metric identifier
   * must be URL-encoded. Example:
   * `"projects/my-project/metrics/nginx%2Frequests"`.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * Optional. A description of this metric, which is used in documentation.
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * Required. An [advanced logs filter](/logging/docs/view/advanced_filters)
   * which is used to match log entries.
   * Example:
   *
   *     "resource.type=gae_app AND severity>=ERROR"
   *
   * The maximum length of the filter is 20000 characters.
   *
   * @generated from field: string filter = 3;
   */
  filter = "";

  /**
   * Optional. The metric descriptor associated with the logs-based metric.
   * If unspecified, it uses a default metric descriptor with a DELTA metric
   * kind, INT64 value type, with no labels and a unit of "1". Such a metric
   * counts the number of log entries matching the `filter` expression.
   *
   * The `name`, `type`, and `description` fields in the `metric_descriptor`
   * are output only, and is constructed using the `name` and `description`
   * field in the LogMetric.
   *
   * To create a logs-based metric that records a distribution of log values, a
   * DELTA metric kind with a DISTRIBUTION value type must be used along with
   * a `value_extractor` expression in the LogMetric.
   *
   * Each label in the metric descriptor must have a matching label
   * name as the key and an extractor expression as the value in the
   * `label_extractors` map.
   *
   * The `metric_kind` and `value_type` fields in the `metric_descriptor` cannot
   * be updated once initially configured. New labels can be added in the
   * `metric_descriptor`, but existing labels cannot be modified except for
   * their description.
   *
   * @generated from field: google.api.MetricDescriptor metric_descriptor = 5;
   */
  metricDescriptor?: MetricDescriptor;

  /**
   * Optional. A `value_extractor` is required when using a distribution
   * logs-based metric to extract the values to record from a log entry.
   * Two functions are supported for value extraction: `EXTRACT(field)` or
   * `REGEXP_EXTRACT(field, regex)`. The argument are:
   *   1. field: The name of the log entry field from which the value is to be
   *      extracted.
   *   2. regex: A regular expression using the Google RE2 syntax
   *      (https://github.com/google/re2/wiki/Syntax) with a single capture
   *      group to extract data from the specified log entry field. The value
   *      of the field is converted to a string before applying the regex.
   *      It is an error to specify a regex that does not include exactly one
   *      capture group.
   *
   * The result of the extraction must be convertible to a double type, as the
   * distribution always records double values. If either the extraction or
   * the conversion to double fails, then those values are not recorded in the
   * distribution.
   *
   * Example: `REGEXP_EXTRACT(jsonPayload.request, ".*quantity=(\d+).*")`
   *
   * @generated from field: string value_extractor = 6;
   */
  valueExtractor = "";

  /**
   * Optional. A map from a label key string to an extractor expression which is
   * used to extract data from a log entry field and assign as the label value.
   * Each label key specified in the LabelDescriptor must have an associated
   * extractor expression in this map. The syntax of the extractor expression
   * is the same as for the `value_extractor` field.
   *
   * The extracted value is converted to the type defined in the label
   * descriptor. If the either the extraction or the type conversion fails,
   * the label will have a default value. The default value for a string
   * label is an empty string, for an integer label its 0, and for a boolean
   * label its `false`.
   *
   * Note that there are upper bounds on the maximum number of labels and the
   * number of active time series that are allowed in a project.
   *
   * @generated from field: map<string, string> label_extractors = 7;
   */
  labelExtractors: { [key: string]: string } = {};

  /**
   * Optional. The `bucket_options` are required when the logs-based metric is
   * using a DISTRIBUTION value type and it describes the bucket boundaries
   * used to create a histogram of the extracted values.
   *
   * @generated from field: google.api.Distribution.BucketOptions bucket_options = 8;
   */
  bucketOptions?: Distribution_BucketOptions;

  /**
   * Deprecated. The API version that created or updated this metric.
   * The v2 format is used by default and cannot be changed.
   *
   * @generated from field: google.logging.v2.LogMetric.ApiVersion version = 4;
   */
  version = LogMetric_ApiVersion.V2;

  constructor(data?: PartialMessage<LogMetric>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.LogMetric";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "filter", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "metric_descriptor", kind: "message", T: MetricDescriptor },
    { no: 6, name: "value_extractor", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "label_extractors", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 8, name: "bucket_options", kind: "message", T: Distribution_BucketOptions },
    { no: 4, name: "version", kind: "enum", T: proto3.getEnumType(LogMetric_ApiVersion) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogMetric {
    return new LogMetric().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogMetric {
    return new LogMetric().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogMetric {
    return new LogMetric().fromJsonString(jsonString, options);
  }

  static equals(a: LogMetric | PlainMessage<LogMetric> | undefined, b: LogMetric | PlainMessage<LogMetric> | undefined): boolean {
    return proto3.util.equals(LogMetric, a, b);
  }
}

/**
 * Stackdriver Logging API version.
 *
 * @generated from enum google.logging.v2.LogMetric.ApiVersion
 */
export enum LogMetric_ApiVersion {
  /**
   * Stackdriver Logging API v2.
   *
   * @generated from enum value: V2 = 0;
   */
  V2 = 0,

  /**
   * Stackdriver Logging API v1.
   *
   * @generated from enum value: V1 = 1;
   */
  V1 = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(LogMetric_ApiVersion)
proto3.util.setEnumType(LogMetric_ApiVersion, "google.logging.v2.LogMetric.ApiVersion", [
  { no: 0, name: "V2" },
  { no: 1, name: "V1" },
]);

/**
 * The parameters to ListLogMetrics.
 *
 * @generated from message google.logging.v2.ListLogMetricsRequest
 */
export class ListLogMetricsRequest extends Message<ListLogMetricsRequest> {
  /**
   * Required. The name of the project containing the metrics:
   *
   *     "projects/[PROJECT_ID]"
   *
   * @generated from field: string parent = 1;
   */
  parent = "";

  /**
   * Optional. If present, then retrieve the next batch of results from the
   * preceding call to this method.  `pageToken` must be the value of
   * `nextPageToken` from the previous response.  The values of other method
   * parameters should be identical to those in the previous call.
   *
   * @generated from field: string page_token = 2;
   */
  pageToken = "";

  /**
   * Optional. The maximum number of results to return from this request.
   * Non-positive values are ignored.  The presence of `nextPageToken` in the
   * response indicates that more results might be available.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize = 0;

  constructor(data?: PartialMessage<ListLogMetricsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.ListLogMetricsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListLogMetricsRequest {
    return new ListLogMetricsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListLogMetricsRequest {
    return new ListLogMetricsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListLogMetricsRequest {
    return new ListLogMetricsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListLogMetricsRequest | PlainMessage<ListLogMetricsRequest> | undefined, b: ListLogMetricsRequest | PlainMessage<ListLogMetricsRequest> | undefined): boolean {
    return proto3.util.equals(ListLogMetricsRequest, a, b);
  }
}

/**
 * Result returned from ListLogMetrics.
 *
 * @generated from message google.logging.v2.ListLogMetricsResponse
 */
export class ListLogMetricsResponse extends Message<ListLogMetricsResponse> {
  /**
   * A list of logs-based metrics.
   *
   * @generated from field: repeated google.logging.v2.LogMetric metrics = 1;
   */
  metrics: LogMetric[] = [];

  /**
   * If there might be more results than appear in this response, then
   * `nextPageToken` is included.  To get the next set of results, call this
   * method again using the value of `nextPageToken` as `pageToken`.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListLogMetricsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.ListLogMetricsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metrics", kind: "message", T: LogMetric, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListLogMetricsResponse {
    return new ListLogMetricsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListLogMetricsResponse {
    return new ListLogMetricsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListLogMetricsResponse {
    return new ListLogMetricsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListLogMetricsResponse | PlainMessage<ListLogMetricsResponse> | undefined, b: ListLogMetricsResponse | PlainMessage<ListLogMetricsResponse> | undefined): boolean {
    return proto3.util.equals(ListLogMetricsResponse, a, b);
  }
}

/**
 * The parameters to GetLogMetric.
 *
 * @generated from message google.logging.v2.GetLogMetricRequest
 */
export class GetLogMetricRequest extends Message<GetLogMetricRequest> {
  /**
   * The resource name of the desired metric:
   *
   *     "projects/[PROJECT_ID]/metrics/[METRIC_ID]"
   *
   * @generated from field: string metric_name = 1;
   */
  metricName = "";

  constructor(data?: PartialMessage<GetLogMetricRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.GetLogMetricRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metric_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetLogMetricRequest {
    return new GetLogMetricRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetLogMetricRequest {
    return new GetLogMetricRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetLogMetricRequest {
    return new GetLogMetricRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetLogMetricRequest | PlainMessage<GetLogMetricRequest> | undefined, b: GetLogMetricRequest | PlainMessage<GetLogMetricRequest> | undefined): boolean {
    return proto3.util.equals(GetLogMetricRequest, a, b);
  }
}

/**
 * The parameters to CreateLogMetric.
 *
 * @generated from message google.logging.v2.CreateLogMetricRequest
 */
export class CreateLogMetricRequest extends Message<CreateLogMetricRequest> {
  /**
   * The resource name of the project in which to create the metric:
   *
   *     "projects/[PROJECT_ID]"
   *
   * The new metric must be provided in the request.
   *
   * @generated from field: string parent = 1;
   */
  parent = "";

  /**
   * The new logs-based metric, which must not have an identifier that
   * already exists.
   *
   * @generated from field: google.logging.v2.LogMetric metric = 2;
   */
  metric?: LogMetric;

  constructor(data?: PartialMessage<CreateLogMetricRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.CreateLogMetricRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "metric", kind: "message", T: LogMetric },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateLogMetricRequest {
    return new CreateLogMetricRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateLogMetricRequest {
    return new CreateLogMetricRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateLogMetricRequest {
    return new CreateLogMetricRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateLogMetricRequest | PlainMessage<CreateLogMetricRequest> | undefined, b: CreateLogMetricRequest | PlainMessage<CreateLogMetricRequest> | undefined): boolean {
    return proto3.util.equals(CreateLogMetricRequest, a, b);
  }
}

/**
 * The parameters to UpdateLogMetric.
 *
 * @generated from message google.logging.v2.UpdateLogMetricRequest
 */
export class UpdateLogMetricRequest extends Message<UpdateLogMetricRequest> {
  /**
   * The resource name of the metric to update:
   *
   *     "projects/[PROJECT_ID]/metrics/[METRIC_ID]"
   *
   * The updated metric must be provided in the request and it's
   * `name` field must be the same as `[METRIC_ID]` If the metric
   * does not exist in `[PROJECT_ID]`, then a new metric is created.
   *
   * @generated from field: string metric_name = 1;
   */
  metricName = "";

  /**
   * The updated metric.
   *
   * @generated from field: google.logging.v2.LogMetric metric = 2;
   */
  metric?: LogMetric;

  constructor(data?: PartialMessage<UpdateLogMetricRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.UpdateLogMetricRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metric_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "metric", kind: "message", T: LogMetric },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateLogMetricRequest {
    return new UpdateLogMetricRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateLogMetricRequest {
    return new UpdateLogMetricRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateLogMetricRequest {
    return new UpdateLogMetricRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateLogMetricRequest | PlainMessage<UpdateLogMetricRequest> | undefined, b: UpdateLogMetricRequest | PlainMessage<UpdateLogMetricRequest> | undefined): boolean {
    return proto3.util.equals(UpdateLogMetricRequest, a, b);
  }
}

/**
 * The parameters to DeleteLogMetric.
 *
 * @generated from message google.logging.v2.DeleteLogMetricRequest
 */
export class DeleteLogMetricRequest extends Message<DeleteLogMetricRequest> {
  /**
   * The resource name of the metric to delete:
   *
   *     "projects/[PROJECT_ID]/metrics/[METRIC_ID]"
   *
   * @generated from field: string metric_name = 1;
   */
  metricName = "";

  constructor(data?: PartialMessage<DeleteLogMetricRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.logging.v2.DeleteLogMetricRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "metric_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteLogMetricRequest {
    return new DeleteLogMetricRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteLogMetricRequest {
    return new DeleteLogMetricRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteLogMetricRequest {
    return new DeleteLogMetricRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteLogMetricRequest | PlainMessage<DeleteLogMetricRequest> | undefined, b: DeleteLogMetricRequest | PlainMessage<DeleteLogMetricRequest> | undefined): boolean {
    return proto3.util.equals(DeleteLogMetricRequest, a, b);
  }
}

