// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/devtools/remoteexecution/v1test/remote_execution.proto (package google.devtools.remoteexecution.v1test, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Status } from "../../../rpc/status_pb.js";

/**
 * An `Action` captures all the information about an execution which is required
 * to reproduce it.
 *
 * `Action`s are the core component of the [Execution] service. A single
 * `Action` represents a repeatable action that can be performed by the
 * execution service. `Action`s can be succinctly identified by the digest of
 * their wire format encoding and, once an `Action` has been executed, will be
 * cached in the action cache. Future requests can then use the cached result
 * rather than needing to run afresh.
 *
 * When a server completes execution of an
 * [Action][google.devtools.remoteexecution.v1test.Action], it MAY choose to
 * cache the [result][google.devtools.remoteexecution.v1test.ActionResult] in
 * the [ActionCache][google.devtools.remoteexecution.v1test.ActionCache] unless
 * `do_not_cache` is `true`. Clients SHOULD expect the server to do so. By
 * default, future calls to [Execute][] the same `Action` will also serve their
 * results from the cache. Clients must take care to understand the caching
 * behaviour. Ideally, all `Action`s will be reproducible so that serving a
 * result from cache is always desirable and correct.
 *
 * @generated from message google.devtools.remoteexecution.v1test.Action
 */
export class Action extends Message<Action> {
  /**
   * The digest of the [Command][google.devtools.remoteexecution.v1test.Command]
   * to run, which MUST be present in the
   * [ContentAddressableStorage][google.devtools.remoteexecution.v1test.ContentAddressableStorage].
   *
   * @generated from field: google.devtools.remoteexecution.v1test.Digest command_digest = 1;
   */
  commandDigest?: Digest;

  /**
   * The digest of the root
   * [Directory][google.devtools.remoteexecution.v1test.Directory] for the input
   * files. The files in the directory tree are available in the correct
   * location on the build machine before the command is executed. The root
   * directory, as well as every subdirectory and content blob referred to, MUST
   * be in the
   * [ContentAddressableStorage][google.devtools.remoteexecution.v1test.ContentAddressableStorage].
   *
   * @generated from field: google.devtools.remoteexecution.v1test.Digest input_root_digest = 2;
   */
  inputRootDigest?: Digest;

  /**
   * A list of the output files that the client expects to retrieve from the
   * action. Only the listed files, as well as directories listed in
   * `output_directories`, will be returned to the client as output.
   * Other files that may be created during command execution are discarded.
   *
   * The paths are specified using forward slashes (`/`) as path separators,
   * even if the execution platform natively uses a different separator. The
   * path MUST NOT include a trailing slash.
   *
   * In order to ensure consistent hashing of the same Action, the output paths
   * MUST be sorted lexicographically by code point (or, equivalently, by UTF-8
   * bytes).
   *
   * @generated from field: repeated string output_files = 3;
   */
  outputFiles: string[] = [];

  /**
   * A list of the output directories that the client expects to retrieve from
   * the action. Only the contents of the indicated directories (recursively
   * including the contents of their subdirectories) will be
   * returned, as well as files listed in `output_files`. Other files that may
   * be created during command execution are discarded.
   *
   * The paths are specified using forward slashes (`/`) as path separators,
   * even if the execution platform natively uses a different separator. The
   * path MUST NOT include a trailing slash, unless the path is `"/"` (which,
   * although not recommended, can be used to capture the entire working
   * directory tree, including inputs).
   *
   * In order to ensure consistent hashing of the same Action, the output paths
   * MUST be sorted lexicographically by code point (or, equivalently, by UTF-8
   * bytes).
   *
   * @generated from field: repeated string output_directories = 4;
   */
  outputDirectories: string[] = [];

  /**
   * The platform requirements for the execution environment. The server MAY
   * choose to execute the action on any worker satisfying the requirements, so
   * the client SHOULD ensure that running the action on any such worker will
   * have the same result.
   *
   * @generated from field: google.devtools.remoteexecution.v1test.Platform platform = 5;
   */
  platform?: Platform;

  /**
   * A timeout after which the execution should be killed. If the timeout is
   * absent, then the client is specifying that the execution should continue
   * as long as the server will let it. The server SHOULD impose a timeout if
   * the client does not specify one, however, if the client does specify a
   * timeout that is longer than the server's maximum timeout, the server MUST
   * reject the request.
   *
   * The timeout is a part of the
   * [Action][google.devtools.remoteexecution.v1test.Action] message, and
   * therefore two `Actions` with different timeouts are different, even if they
   * are otherwise identical. This is because, if they were not, running an
   * `Action` with a lower timeout than is required might result in a cache hit
   * from an execution run with a longer timeout, hiding the fact that the
   * timeout is too short. By encoding it directly in the `Action`, a lower
   * timeout will result in a cache miss and the execution timeout will fail
   * immediately, rather than whenever the cache entry gets evicted.
   *
   * @generated from field: google.protobuf.Duration timeout = 6;
   */
  timeout?: Duration;

  /**
   * If true, then the `Action`'s result cannot be cached.
   *
   * @generated from field: bool do_not_cache = 7;
   */
  doNotCache = false;

  constructor(data?: PartialMessage<Action>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.Action";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "command_digest", kind: "message", T: Digest },
    { no: 2, name: "input_root_digest", kind: "message", T: Digest },
    { no: 3, name: "output_files", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "output_directories", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "platform", kind: "message", T: Platform },
    { no: 6, name: "timeout", kind: "message", T: Duration },
    { no: 7, name: "do_not_cache", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Action {
    return new Action().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Action {
    return new Action().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Action {
    return new Action().fromJsonString(jsonString, options);
  }

  static equals(a: Action | PlainMessage<Action> | undefined, b: Action | PlainMessage<Action> | undefined): boolean {
    return proto3.util.equals(Action, a, b);
  }
}

/**
 * A `Command` is the actual command executed by a worker running an
 * [Action][google.devtools.remoteexecution.v1test.Action].
 *
 * Except as otherwise required, the environment (such as which system
 * libraries or binaries are available, and what filesystems are mounted where)
 * is defined by and specific to the implementation of the remote execution API.
 *
 * @generated from message google.devtools.remoteexecution.v1test.Command
 */
export class Command extends Message<Command> {
  /**
   * The arguments to the command. The first argument must be the path to the
   * executable, which must be either a relative path, in which case it is
   * evaluated with respect to the input root, or an absolute path. The `PATH`
   * environment variable, or similar functionality on other systems, is not
   * used to determine which executable to run.
   *
   * The working directory will always be the input root.
   *
   * @generated from field: repeated string arguments = 1;
   */
  arguments: string[] = [];

  /**
   * The environment variables to set when running the program. The worker may
   * provide its own default environment variables; these defaults can be
   * overridden using this field. Additional variables can also be specified.
   *
   * In order to ensure that equivalent `Command`s always hash to the same
   * value, the environment variables MUST be lexicographically sorted by name.
   * Sorting of strings is done by code point, equivalently, by the UTF-8 bytes.
   *
   * @generated from field: repeated google.devtools.remoteexecution.v1test.Command.EnvironmentVariable environment_variables = 2;
   */
  environmentVariables: Command_EnvironmentVariable[] = [];

  constructor(data?: PartialMessage<Command>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.Command";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "arguments", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "environment_variables", kind: "message", T: Command_EnvironmentVariable, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Command {
    return new Command().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Command {
    return new Command().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Command {
    return new Command().fromJsonString(jsonString, options);
  }

  static equals(a: Command | PlainMessage<Command> | undefined, b: Command | PlainMessage<Command> | undefined): boolean {
    return proto3.util.equals(Command, a, b);
  }
}

/**
 * An `EnvironmentVariable` is one variable to set in the running program's
 * environment.
 *
 * @generated from message google.devtools.remoteexecution.v1test.Command.EnvironmentVariable
 */
export class Command_EnvironmentVariable extends Message<Command_EnvironmentVariable> {
  /**
   * The variable name.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The variable value.
   *
   * @generated from field: string value = 2;
   */
  value = "";

  constructor(data?: PartialMessage<Command_EnvironmentVariable>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.Command.EnvironmentVariable";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Command_EnvironmentVariable {
    return new Command_EnvironmentVariable().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Command_EnvironmentVariable {
    return new Command_EnvironmentVariable().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Command_EnvironmentVariable {
    return new Command_EnvironmentVariable().fromJsonString(jsonString, options);
  }

  static equals(a: Command_EnvironmentVariable | PlainMessage<Command_EnvironmentVariable> | undefined, b: Command_EnvironmentVariable | PlainMessage<Command_EnvironmentVariable> | undefined): boolean {
    return proto3.util.equals(Command_EnvironmentVariable, a, b);
  }
}

/**
 * A `Platform` is a set of requirements, such as hardware, operation system, or
 * compiler toolchain, for an
 * [Action][google.devtools.remoteexecution.v1test.Action]'s execution
 * environment. A `Platform` is represented as a series of key-value pairs
 * representing the properties that are required of the platform.
 *
 * This message is currently being redeveloped since it is an overly simplistic
 * model of platforms.
 *
 * @generated from message google.devtools.remoteexecution.v1test.Platform
 */
export class Platform extends Message<Platform> {
  /**
   * The properties that make up this platform. In order to ensure that
   * equivalent `Platform`s always hash to the same value, the properties MUST
   * be lexicographically sorted by name, and then by value. Sorting of strings
   * is done by code point, equivalently, by the UTF-8 bytes.
   *
   * @generated from field: repeated google.devtools.remoteexecution.v1test.Platform.Property properties = 1;
   */
  properties: Platform_Property[] = [];

  constructor(data?: PartialMessage<Platform>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.Platform";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "properties", kind: "message", T: Platform_Property, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Platform {
    return new Platform().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Platform {
    return new Platform().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Platform {
    return new Platform().fromJsonString(jsonString, options);
  }

  static equals(a: Platform | PlainMessage<Platform> | undefined, b: Platform | PlainMessage<Platform> | undefined): boolean {
    return proto3.util.equals(Platform, a, b);
  }
}

/**
 * A single property for the environment. The server is responsible for
 * specifying the property `name`s that it accepts. If an unknown `name` is
 * provided in the requirements for an
 * [Action][google.devtools.remoteexecution.v1test.Action], the server SHOULD
 * reject the execution request. If permitted by the server, the same `name`
 * may occur multiple times.
 *
 * The server is also responsible for specifying the interpretation of
 * property `value`s. For instance, a property describing how much RAM must be
 * available may be interpreted as allowing a worker with 16GB to fulfill a
 * request for 8GB, while a property describing the OS environment on which
 * the action must be performed may require an exact match with the worker's
 * OS.
 *
 * The server MAY use the `value` of one or more properties to determine how
 * it sets up the execution environment, such as by making specific system
 * files available to the worker.
 *
 * @generated from message google.devtools.remoteexecution.v1test.Platform.Property
 */
export class Platform_Property extends Message<Platform_Property> {
  /**
   * The property name.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The property value.
   *
   * @generated from field: string value = 2;
   */
  value = "";

  constructor(data?: PartialMessage<Platform_Property>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.Platform.Property";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Platform_Property {
    return new Platform_Property().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Platform_Property {
    return new Platform_Property().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Platform_Property {
    return new Platform_Property().fromJsonString(jsonString, options);
  }

  static equals(a: Platform_Property | PlainMessage<Platform_Property> | undefined, b: Platform_Property | PlainMessage<Platform_Property> | undefined): boolean {
    return proto3.util.equals(Platform_Property, a, b);
  }
}

/**
 * A `Directory` represents a directory node in a file tree, containing zero or
 * more children [FileNodes][google.devtools.remoteexecution.v1test.FileNode]
 * and [DirectoryNodes][google.devtools.remoteexecution.v1test.DirectoryNode].
 * Each `Node` contains its name in the directory, the digest of its content
 * (either a file blob or a `Directory` proto), as well as possibly some
 * metadata about the file or directory.
 *
 * In order to ensure that two equivalent directory trees hash to the same
 * value, the following restrictions MUST be obeyed when constructing a
 * a `Directory`:
 *   - Every child in the directory must have a path of exactly one segment.
 *     Multiple levels of directory hierarchy may not be collapsed.
 *   - Each child in the directory must have a unique path segment (file name).
 *   - The files and directories in the directory must each be sorted in
 *     lexicographical order by path. The path strings must be sorted by code
 *     point, equivalently, by UTF-8 bytes.
 *
 * A `Directory` that obeys the restrictions is said to be in canonical form.
 *
 * As an example, the following could be used for a file named `bar` and a
 * directory named `foo` with an executable file named `baz` (hashes shortened
 * for readability):
 *
 * ```json
 * // (Directory proto)
 * {
 *   files: [
 *     {
 *       name: "bar",
 *       digest: {
 *         hash: "4a73bc9d03...",
 *         size: 65534
 *       }
 *     }
 *   ],
 *   directories: [
 *     {
 *       name: "foo",
 *       digest: {
 *         hash: "4cf2eda940...",
 *         size: 43
 *       }
 *     }
 *   ]
 * }
 *
 * // (Directory proto with hash "4cf2eda940..." and size 43)
 * {
 *   files: [
 *     {
 *       name: "baz",
 *       digest: {
 *         hash: "b2c941073e...",
 *         size: 1294,
 *       },
 *       is_executable: true
 *     }
 *   ]
 * }
 * ```
 *
 * @generated from message google.devtools.remoteexecution.v1test.Directory
 */
export class Directory extends Message<Directory> {
  /**
   * The files in the directory.
   *
   * @generated from field: repeated google.devtools.remoteexecution.v1test.FileNode files = 1;
   */
  files: FileNode[] = [];

  /**
   * The subdirectories in the directory.
   *
   * @generated from field: repeated google.devtools.remoteexecution.v1test.DirectoryNode directories = 2;
   */
  directories: DirectoryNode[] = [];

  constructor(data?: PartialMessage<Directory>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.Directory";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "files", kind: "message", T: FileNode, repeated: true },
    { no: 2, name: "directories", kind: "message", T: DirectoryNode, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Directory {
    return new Directory().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Directory {
    return new Directory().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Directory {
    return new Directory().fromJsonString(jsonString, options);
  }

  static equals(a: Directory | PlainMessage<Directory> | undefined, b: Directory | PlainMessage<Directory> | undefined): boolean {
    return proto3.util.equals(Directory, a, b);
  }
}

/**
 * A `FileNode` represents a single file and associated metadata.
 *
 * @generated from message google.devtools.remoteexecution.v1test.FileNode
 */
export class FileNode extends Message<FileNode> {
  /**
   * The name of the file.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The digest of the file's content.
   *
   * @generated from field: google.devtools.remoteexecution.v1test.Digest digest = 2;
   */
  digest?: Digest;

  /**
   * True if file is executable, false otherwise.
   *
   * @generated from field: bool is_executable = 4;
   */
  isExecutable = false;

  constructor(data?: PartialMessage<FileNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.FileNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "digest", kind: "message", T: Digest },
    { no: 4, name: "is_executable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FileNode {
    return new FileNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FileNode {
    return new FileNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FileNode {
    return new FileNode().fromJsonString(jsonString, options);
  }

  static equals(a: FileNode | PlainMessage<FileNode> | undefined, b: FileNode | PlainMessage<FileNode> | undefined): boolean {
    return proto3.util.equals(FileNode, a, b);
  }
}

/**
 * A `DirectoryNode` represents a child of a
 * [Directory][google.devtools.remoteexecution.v1test.Directory] which is itself
 * a `Directory` and its associated metadata.
 *
 * @generated from message google.devtools.remoteexecution.v1test.DirectoryNode
 */
export class DirectoryNode extends Message<DirectoryNode> {
  /**
   * The name of the directory.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The digest of the
   * [Directory][google.devtools.remoteexecution.v1test.Directory] object
   * represented. See [Digest][google.devtools.remoteexecution.v1test.Digest]
   * for information about how to take the digest of a proto message.
   *
   * @generated from field: google.devtools.remoteexecution.v1test.Digest digest = 2;
   */
  digest?: Digest;

  constructor(data?: PartialMessage<DirectoryNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.DirectoryNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "digest", kind: "message", T: Digest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DirectoryNode {
    return new DirectoryNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DirectoryNode {
    return new DirectoryNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DirectoryNode {
    return new DirectoryNode().fromJsonString(jsonString, options);
  }

  static equals(a: DirectoryNode | PlainMessage<DirectoryNode> | undefined, b: DirectoryNode | PlainMessage<DirectoryNode> | undefined): boolean {
    return proto3.util.equals(DirectoryNode, a, b);
  }
}

/**
 * A content digest. A digest for a given blob consists of the size of the blob
 * and its hash. The hash algorithm to use is defined by the server, but servers
 * SHOULD use SHA-256.
 *
 * The size is considered to be an integral part of the digest and cannot be
 * separated. That is, even if the `hash` field is correctly specified but
 * `size_bytes` is not, the server MUST reject the request.
 *
 * The reason for including the size in the digest is as follows: in a great
 * many cases, the server needs to know the size of the blob it is about to work
 * with prior to starting an operation with it, such as flattening Merkle tree
 * structures or streaming it to a worker. Technically, the server could
 * implement a separate metadata store, but this results in a significantly more
 * complicated implementation as opposed to having the client specify the size
 * up-front (or storing the size along with the digest in every message where
 * digests are embedded). This does mean that the API leaks some implementation
 * details of (what we consider to be) a reasonable server implementation, but
 * we consider this to be a worthwhile tradeoff.
 *
 * When a `Digest` is used to refer to a proto message, it always refers to the
 * message in binary encoded form. To ensure consistent hashing, clients and
 * servers MUST ensure that they serialize messages according to the following
 * rules, even if there are alternate valid encodings for the same message.
 * - Fields are serialized in tag order.
 * - There are no unknown fields.
 * - There are no duplicate fields.
 * - Fields are serialized according to the default semantics for their type.
 *
 * Most protocol buffer implementations will always follow these rules when
 * serializing, but care should be taken to avoid shortcuts. For instance,
 * concatenating two messages to merge them may produce duplicate fields.
 *
 * @generated from message google.devtools.remoteexecution.v1test.Digest
 */
export class Digest extends Message<Digest> {
  /**
   * The hash. In the case of SHA-256, it will always be a lowercase hex string
   * exactly 64 characters long.
   *
   * @generated from field: string hash = 1;
   */
  hash = "";

  /**
   * The size of the blob, in bytes.
   *
   * @generated from field: int64 size_bytes = 2;
   */
  sizeBytes = protoInt64.zero;

  constructor(data?: PartialMessage<Digest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.Digest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "size_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Digest {
    return new Digest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Digest {
    return new Digest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Digest {
    return new Digest().fromJsonString(jsonString, options);
  }

  static equals(a: Digest | PlainMessage<Digest> | undefined, b: Digest | PlainMessage<Digest> | undefined): boolean {
    return proto3.util.equals(Digest, a, b);
  }
}

/**
 * An ActionResult represents the result of an
 * [Action][google.devtools.remoteexecution.v1test.Action] being run.
 *
 * @generated from message google.devtools.remoteexecution.v1test.ActionResult
 */
export class ActionResult extends Message<ActionResult> {
  /**
   * The output files of the action. For each output file requested, if the
   * corresponding file existed after the action completed, a single entry will
   * be present in the output list.
   *
   * If the action does not produce the requested output, or produces a
   * directory where a regular file is expected or vice versa, then that output
   * will be omitted from the list. The server is free to arrange the output
   * list as desired; clients MUST NOT assume that the output list is sorted.
   *
   * @generated from field: repeated google.devtools.remoteexecution.v1test.OutputFile output_files = 2;
   */
  outputFiles: OutputFile[] = [];

  /**
   * The output directories of the action. For each output directory requested,
   * if the corresponding directory existed after the action completed, a single
   * entry will be present in the output list, which will contain the digest of
   * a [Tree][google.devtools.remoteexecution.v1.test.Tree] message containing
   * the directory tree.
   *
   * @generated from field: repeated google.devtools.remoteexecution.v1test.OutputDirectory output_directories = 3;
   */
  outputDirectories: OutputDirectory[] = [];

  /**
   * The exit code of the command.
   *
   * @generated from field: int32 exit_code = 4;
   */
  exitCode = 0;

  /**
   * The standard output buffer of the action. The server will determine, based
   * on the size of the buffer, whether to return it in raw form or to return
   * a digest in `stdout_digest` that points to the buffer. If neither is set,
   * then the buffer is empty. The client SHOULD NOT assume it will get one of
   * the raw buffer or a digest on any given request and should be prepared to
   * handle either.
   *
   * @generated from field: bytes stdout_raw = 5;
   */
  stdoutRaw = new Uint8Array(0);

  /**
   * The digest for a blob containing the standard output of the action, which
   * can be retrieved from the
   * [ContentAddressableStorage][google.devtools.remoteexecution.v1test.ContentAddressableStorage].
   * See `stdout_raw` for when this will be set.
   *
   * @generated from field: google.devtools.remoteexecution.v1test.Digest stdout_digest = 6;
   */
  stdoutDigest?: Digest;

  /**
   * The standard error buffer of the action. The server will determine, based
   * on the size of the buffer, whether to return it in raw form or to return
   * a digest in `stderr_digest` that points to the buffer. If neither is set,
   * then the buffer is empty. The client SHOULD NOT assume it will get one of
   * the raw buffer or a digest on any given request and should be prepared to
   * handle either.
   *
   * @generated from field: bytes stderr_raw = 7;
   */
  stderrRaw = new Uint8Array(0);

  /**
   * The digest for a blob containing the standard error of the action, which
   * can be retrieved from the
   * [ContentAddressableStorage][google.devtools.remoteexecution.v1test.ContentAddressableStorage].
   * See `stderr_raw` for when this will be set.
   *
   * @generated from field: google.devtools.remoteexecution.v1test.Digest stderr_digest = 8;
   */
  stderrDigest?: Digest;

  constructor(data?: PartialMessage<ActionResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.ActionResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "output_files", kind: "message", T: OutputFile, repeated: true },
    { no: 3, name: "output_directories", kind: "message", T: OutputDirectory, repeated: true },
    { no: 4, name: "exit_code", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "stdout_raw", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "stdout_digest", kind: "message", T: Digest },
    { no: 7, name: "stderr_raw", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 8, name: "stderr_digest", kind: "message", T: Digest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ActionResult {
    return new ActionResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ActionResult {
    return new ActionResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ActionResult {
    return new ActionResult().fromJsonString(jsonString, options);
  }

  static equals(a: ActionResult | PlainMessage<ActionResult> | undefined, b: ActionResult | PlainMessage<ActionResult> | undefined): boolean {
    return proto3.util.equals(ActionResult, a, b);
  }
}

/**
 * An `OutputFile` is similar to a
 * [FileNode][google.devtools.remoteexecution.v1test.FileNode], but it is
 * tailored for output as part of an `ActionResult`. It allows a full file path
 * rather than only a name, and allows the server to include content inline.
 *
 * `OutputFile` is binary-compatible with `FileNode`.
 *
 * @generated from message google.devtools.remoteexecution.v1test.OutputFile
 */
export class OutputFile extends Message<OutputFile> {
  /**
   * The full path of the file relative to the input root, including the
   * filename. The path separator is a forward slash `/`.
   *
   * @generated from field: string path = 1;
   */
  path = "";

  /**
   * The digest of the file's content.
   *
   * @generated from field: google.devtools.remoteexecution.v1test.Digest digest = 2;
   */
  digest?: Digest;

  /**
   * The raw content of the file.
   *
   * This field may be used by the server to provide the content of a file
   * inline in an
   * [ActionResult][google.devtools.remoteexecution.v1test.ActionResult] and
   * avoid requiring that the client make a separate call to
   * [ContentAddressableStorage.GetBlob] to retrieve it.
   *
   * The client SHOULD NOT assume that it will get raw content with any request,
   * and always be prepared to retrieve it via `digest`.
   *
   * @generated from field: bytes content = 3;
   */
  content = new Uint8Array(0);

  /**
   * True if file is executable, false otherwise.
   *
   * @generated from field: bool is_executable = 4;
   */
  isExecutable = false;

  constructor(data?: PartialMessage<OutputFile>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.OutputFile";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "digest", kind: "message", T: Digest },
    { no: 3, name: "content", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "is_executable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OutputFile {
    return new OutputFile().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OutputFile {
    return new OutputFile().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OutputFile {
    return new OutputFile().fromJsonString(jsonString, options);
  }

  static equals(a: OutputFile | PlainMessage<OutputFile> | undefined, b: OutputFile | PlainMessage<OutputFile> | undefined): boolean {
    return proto3.util.equals(OutputFile, a, b);
  }
}

/**
 * A `Tree` contains all the
 * [Directory][google.devtools.remoteexecution.v1test.Directory] protos in a
 * single directory Merkle tree, compressed into one message.
 *
 * @generated from message google.devtools.remoteexecution.v1test.Tree
 */
export class Tree extends Message<Tree> {
  /**
   * The root directory in the tree.
   *
   * @generated from field: google.devtools.remoteexecution.v1test.Directory root = 1;
   */
  root?: Directory;

  /**
   * All the child directories: the directories referred to by the root and,
   * recursively, all its children. In order to reconstruct the directory tree,
   * the client must take the digests of each of the child directories and then
   * build up a tree starting from the `root`.
   *
   * @generated from field: repeated google.devtools.remoteexecution.v1test.Directory children = 2;
   */
  children: Directory[] = [];

  constructor(data?: PartialMessage<Tree>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.Tree";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root", kind: "message", T: Directory },
    { no: 2, name: "children", kind: "message", T: Directory, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Tree {
    return new Tree().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Tree {
    return new Tree().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Tree {
    return new Tree().fromJsonString(jsonString, options);
  }

  static equals(a: Tree | PlainMessage<Tree> | undefined, b: Tree | PlainMessage<Tree> | undefined): boolean {
    return proto3.util.equals(Tree, a, b);
  }
}

/**
 * An `OutputDirectory` is the output in an `ActionResult` corresponding to a
 * directory's full contents rather than a single file.
 *
 * @generated from message google.devtools.remoteexecution.v1test.OutputDirectory
 */
export class OutputDirectory extends Message<OutputDirectory> {
  /**
   * The full path of the directory relative to the input root, including the
   * filename. The path separator is a forward slash `/`.
   *
   * @generated from field: string path = 1;
   */
  path = "";

  /**
   * DEPRECATED: This field is deprecated and should no longer be used.
   *
   * @generated from field: google.devtools.remoteexecution.v1test.Digest digest = 2;
   */
  digest?: Digest;

  /**
   * The digest of the encoded
   * [Tree][google.devtools.remoteexecution.v1test.Tree] proto containing the
   * directory's contents.
   *
   * @generated from field: google.devtools.remoteexecution.v1test.Digest tree_digest = 3;
   */
  treeDigest?: Digest;

  constructor(data?: PartialMessage<OutputDirectory>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.OutputDirectory";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "digest", kind: "message", T: Digest },
    { no: 3, name: "tree_digest", kind: "message", T: Digest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OutputDirectory {
    return new OutputDirectory().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OutputDirectory {
    return new OutputDirectory().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OutputDirectory {
    return new OutputDirectory().fromJsonString(jsonString, options);
  }

  static equals(a: OutputDirectory | PlainMessage<OutputDirectory> | undefined, b: OutputDirectory | PlainMessage<OutputDirectory> | undefined): boolean {
    return proto3.util.equals(OutputDirectory, a, b);
  }
}

/**
 * A request message for
 * [Execution.Execute][google.devtools.remoteexecution.v1test.Execution.Execute].
 *
 * @generated from message google.devtools.remoteexecution.v1test.ExecuteRequest
 */
export class ExecuteRequest extends Message<ExecuteRequest> {
  /**
   * The instance of the execution system to operate against. A server may
   * support multiple instances of the execution system (with their own workers,
   * storage, caches, etc.). The server MAY require use of this field to select
   * between them in an implementation-defined fashion, otherwise it can be
   * omitted.
   *
   * @generated from field: string instance_name = 1;
   */
  instanceName = "";

  /**
   * The action to be performed.
   *
   * @generated from field: google.devtools.remoteexecution.v1test.Action action = 2;
   */
  action?: Action;

  /**
   * If true, the action will be executed anew even if its result was already
   * present in the cache. If false, the result may be served from the
   * [ActionCache][google.devtools.remoteexecution.v1test.ActionCache].
   *
   * @generated from field: bool skip_cache_lookup = 3;
   */
  skipCacheLookup = false;

  /**
   * DEPRECATED: This field should be ignored by clients and servers and will be
   * removed.
   *
   * @generated from field: int32 total_input_file_count = 4;
   */
  totalInputFileCount = 0;

  /**
   * DEPRECATED: This field should be ignored by clients and servers and will be
   * removed.
   *
   * @generated from field: int64 total_input_file_bytes = 5;
   */
  totalInputFileBytes = protoInt64.zero;

  constructor(data?: PartialMessage<ExecuteRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.ExecuteRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "action", kind: "message", T: Action },
    { no: 3, name: "skip_cache_lookup", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "total_input_file_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "total_input_file_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecuteRequest {
    return new ExecuteRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecuteRequest {
    return new ExecuteRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecuteRequest {
    return new ExecuteRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ExecuteRequest | PlainMessage<ExecuteRequest> | undefined, b: ExecuteRequest | PlainMessage<ExecuteRequest> | undefined): boolean {
    return proto3.util.equals(ExecuteRequest, a, b);
  }
}

/**
 * A `LogFile` is a log stored in the CAS.
 *
 * @generated from message google.devtools.remoteexecution.v1test.LogFile
 */
export class LogFile extends Message<LogFile> {
  /**
   * The digest of the log contents.
   *
   * @generated from field: google.devtools.remoteexecution.v1test.Digest digest = 1;
   */
  digest?: Digest;

  /**
   * This is a hint as to the purpose of the log, and is set to true if the log
   * is human-readable text that can be usefully displayed to a user, and false
   * otherwise. For instance, if a command-line client wishes to print the
   * server logs to the terminal for a failed action, this allows it to avoid
   * displaying a binary file.
   *
   * @generated from field: bool human_readable = 2;
   */
  humanReadable = false;

  constructor(data?: PartialMessage<LogFile>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.LogFile";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "digest", kind: "message", T: Digest },
    { no: 2, name: "human_readable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogFile {
    return new LogFile().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogFile {
    return new LogFile().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogFile {
    return new LogFile().fromJsonString(jsonString, options);
  }

  static equals(a: LogFile | PlainMessage<LogFile> | undefined, b: LogFile | PlainMessage<LogFile> | undefined): boolean {
    return proto3.util.equals(LogFile, a, b);
  }
}

/**
 * The response message for
 * [Execution.Execute][google.devtools.remoteexecution.v1test.Execution.Execute],
 * which will be contained in the [response
 * field][google.longrunning.Operation.response] of the
 * [Operation][google.longrunning.Operation].
 *
 * @generated from message google.devtools.remoteexecution.v1test.ExecuteResponse
 */
export class ExecuteResponse extends Message<ExecuteResponse> {
  /**
   * The result of the action.
   *
   * @generated from field: google.devtools.remoteexecution.v1test.ActionResult result = 1;
   */
  result?: ActionResult;

  /**
   * True if the result was served from cache, false if it was executed.
   *
   * @generated from field: bool cached_result = 2;
   */
  cachedResult = false;

  /**
   * If the status has a code other than `OK`, it indicates that the action did
   * not finish execution. For example, if the operation times out during
   * execution, the status will have a `DEADLINE_EXCEEDED` code. Servers MUST
   * use this field for errors in execution, rather than the error field on the
   * `Operation` object.
   *
   * If the status code is other than `OK`, then the result MUST NOT be cached.
   * For an error status, the `result` field is optional; the server may
   * populate the output-, stdout-, and stderr-related fields if it has any
   * information available, such as the stdout and stderr of a timed-out action.
   *
   * @generated from field: google.rpc.Status status = 3;
   */
  status?: Status;

  /**
   * An optional list of additional log outputs the server wishes to provide. A
   * server can use this to return execution-specific logs however it wishes.
   * This is intended primarily to make it easier for users to debug issues that
   * may be outside of the actual job execution, such as by identifying the
   * worker executing the action or by providing logs from the worker's setup
   * phase. The keys SHOULD be human readable so that a client can display them
   * to a user.
   *
   * @generated from field: map<string, google.devtools.remoteexecution.v1test.LogFile> server_logs = 4;
   */
  serverLogs: { [key: string]: LogFile } = {};

  constructor(data?: PartialMessage<ExecuteResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.ExecuteResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "result", kind: "message", T: ActionResult },
    { no: 2, name: "cached_result", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "status", kind: "message", T: Status },
    { no: 4, name: "server_logs", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: LogFile} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecuteResponse {
    return new ExecuteResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecuteResponse {
    return new ExecuteResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecuteResponse {
    return new ExecuteResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ExecuteResponse | PlainMessage<ExecuteResponse> | undefined, b: ExecuteResponse | PlainMessage<ExecuteResponse> | undefined): boolean {
    return proto3.util.equals(ExecuteResponse, a, b);
  }
}

/**
 * Metadata about an ongoing
 * [execution][google.devtools.remoteexecution.v1test.Execution.Execute], which
 * will be contained in the [metadata
 * field][google.longrunning.Operation.response] of the
 * [Operation][google.longrunning.Operation].
 *
 * @generated from message google.devtools.remoteexecution.v1test.ExecuteOperationMetadata
 */
export class ExecuteOperationMetadata extends Message<ExecuteOperationMetadata> {
  /**
   * @generated from field: google.devtools.remoteexecution.v1test.ExecuteOperationMetadata.Stage stage = 1;
   */
  stage = ExecuteOperationMetadata_Stage.UNKNOWN;

  /**
   * The digest of the [Action][google.devtools.remoteexecution.v1test.Action]
   * being executed.
   *
   * @generated from field: google.devtools.remoteexecution.v1test.Digest action_digest = 2;
   */
  actionDigest?: Digest;

  /**
   * If set, the client can use this name with
   * [ByteStream.Read][google.bytestream.ByteStream.Read] to stream the
   * standard output.
   *
   * @generated from field: string stdout_stream_name = 3;
   */
  stdoutStreamName = "";

  /**
   * If set, the client can use this name with
   * [ByteStream.Read][google.bytestream.ByteStream.Read] to stream the
   * standard error.
   *
   * @generated from field: string stderr_stream_name = 4;
   */
  stderrStreamName = "";

  constructor(data?: PartialMessage<ExecuteOperationMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.ExecuteOperationMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stage", kind: "enum", T: proto3.getEnumType(ExecuteOperationMetadata_Stage) },
    { no: 2, name: "action_digest", kind: "message", T: Digest },
    { no: 3, name: "stdout_stream_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "stderr_stream_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecuteOperationMetadata {
    return new ExecuteOperationMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecuteOperationMetadata {
    return new ExecuteOperationMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecuteOperationMetadata {
    return new ExecuteOperationMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: ExecuteOperationMetadata | PlainMessage<ExecuteOperationMetadata> | undefined, b: ExecuteOperationMetadata | PlainMessage<ExecuteOperationMetadata> | undefined): boolean {
    return proto3.util.equals(ExecuteOperationMetadata, a, b);
  }
}

/**
 * The current stage of execution.
 *
 * @generated from enum google.devtools.remoteexecution.v1test.ExecuteOperationMetadata.Stage
 */
export enum ExecuteOperationMetadata_Stage {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Checking the result against the cache.
   *
   * @generated from enum value: CACHE_CHECK = 1;
   */
  CACHE_CHECK = 1,

  /**
   * Currently idle, awaiting a free machine to execute.
   *
   * @generated from enum value: QUEUED = 2;
   */
  QUEUED = 2,

  /**
   * Currently being executed by a worker.
   *
   * @generated from enum value: EXECUTING = 3;
   */
  EXECUTING = 3,

  /**
   * Finished execution.
   *
   * @generated from enum value: COMPLETED = 4;
   */
  COMPLETED = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(ExecuteOperationMetadata_Stage)
proto3.util.setEnumType(ExecuteOperationMetadata_Stage, "google.devtools.remoteexecution.v1test.ExecuteOperationMetadata.Stage", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "CACHE_CHECK" },
  { no: 2, name: "QUEUED" },
  { no: 3, name: "EXECUTING" },
  { no: 4, name: "COMPLETED" },
]);

/**
 * A request message for
 * [ActionCache.GetActionResult][google.devtools.remoteexecution.v1test.ActionCache.GetActionResult].
 *
 * @generated from message google.devtools.remoteexecution.v1test.GetActionResultRequest
 */
export class GetActionResultRequest extends Message<GetActionResultRequest> {
  /**
   * The instance of the execution system to operate against. A server may
   * support multiple instances of the execution system (with their own workers,
   * storage, caches, etc.). The server MAY require use of this field to select
   * between them in an implementation-defined fashion, otherwise it can be
   * omitted.
   *
   * @generated from field: string instance_name = 1;
   */
  instanceName = "";

  /**
   * The digest of the [Action][google.devtools.remoteexecution.v1test.Action]
   * whose result is requested.
   *
   * @generated from field: google.devtools.remoteexecution.v1test.Digest action_digest = 2;
   */
  actionDigest?: Digest;

  constructor(data?: PartialMessage<GetActionResultRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.GetActionResultRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "action_digest", kind: "message", T: Digest },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetActionResultRequest {
    return new GetActionResultRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetActionResultRequest {
    return new GetActionResultRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetActionResultRequest {
    return new GetActionResultRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetActionResultRequest | PlainMessage<GetActionResultRequest> | undefined, b: GetActionResultRequest | PlainMessage<GetActionResultRequest> | undefined): boolean {
    return proto3.util.equals(GetActionResultRequest, a, b);
  }
}

/**
 * A request message for
 * [ActionCache.UpdateActionResult][google.devtools.remoteexecution.v1test.ActionCache.UpdateActionResult].
 *
 * @generated from message google.devtools.remoteexecution.v1test.UpdateActionResultRequest
 */
export class UpdateActionResultRequest extends Message<UpdateActionResultRequest> {
  /**
   * The instance of the execution system to operate against. A server may
   * support multiple instances of the execution system (with their own workers,
   * storage, caches, etc.). The server MAY require use of this field to select
   * between them in an implementation-defined fashion, otherwise it can be
   * omitted.
   *
   * @generated from field: string instance_name = 1;
   */
  instanceName = "";

  /**
   * The digest of the [Action][google.devtools.remoteexecution.v1test.Action]
   * whose result is being uploaded.
   *
   * @generated from field: google.devtools.remoteexecution.v1test.Digest action_digest = 2;
   */
  actionDigest?: Digest;

  /**
   * The [ActionResult][google.devtools.remoteexecution.v1test.ActionResult]
   * to store in the cache.
   *
   * @generated from field: google.devtools.remoteexecution.v1test.ActionResult action_result = 3;
   */
  actionResult?: ActionResult;

  constructor(data?: PartialMessage<UpdateActionResultRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.UpdateActionResultRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "action_digest", kind: "message", T: Digest },
    { no: 3, name: "action_result", kind: "message", T: ActionResult },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateActionResultRequest {
    return new UpdateActionResultRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateActionResultRequest {
    return new UpdateActionResultRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateActionResultRequest {
    return new UpdateActionResultRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateActionResultRequest | PlainMessage<UpdateActionResultRequest> | undefined, b: UpdateActionResultRequest | PlainMessage<UpdateActionResultRequest> | undefined): boolean {
    return proto3.util.equals(UpdateActionResultRequest, a, b);
  }
}

/**
 * A request message for
 * [ContentAddressableStorage.FindMissingBlobs][google.devtools.remoteexecution.v1test.ContentAddressableStorage.FindMissingBlobs].
 *
 * @generated from message google.devtools.remoteexecution.v1test.FindMissingBlobsRequest
 */
export class FindMissingBlobsRequest extends Message<FindMissingBlobsRequest> {
  /**
   * The instance of the execution system to operate against. A server may
   * support multiple instances of the execution system (with their own workers,
   * storage, caches, etc.). The server MAY require use of this field to select
   * between them in an implementation-defined fashion, otherwise it can be
   * omitted.
   *
   * @generated from field: string instance_name = 1;
   */
  instanceName = "";

  /**
   * A list of the blobs to check.
   *
   * @generated from field: repeated google.devtools.remoteexecution.v1test.Digest blob_digests = 2;
   */
  blobDigests: Digest[] = [];

  constructor(data?: PartialMessage<FindMissingBlobsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.FindMissingBlobsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "blob_digests", kind: "message", T: Digest, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindMissingBlobsRequest {
    return new FindMissingBlobsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindMissingBlobsRequest {
    return new FindMissingBlobsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FindMissingBlobsRequest {
    return new FindMissingBlobsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FindMissingBlobsRequest | PlainMessage<FindMissingBlobsRequest> | undefined, b: FindMissingBlobsRequest | PlainMessage<FindMissingBlobsRequest> | undefined): boolean {
    return proto3.util.equals(FindMissingBlobsRequest, a, b);
  }
}

/**
 * A response message for
 * [ContentAddressableStorage.FindMissingBlobs][google.devtools.remoteexecution.v1test.ContentAddressableStorage.FindMissingBlobs].
 *
 * @generated from message google.devtools.remoteexecution.v1test.FindMissingBlobsResponse
 */
export class FindMissingBlobsResponse extends Message<FindMissingBlobsResponse> {
  /**
   * A list of the blobs requested *not* present in the storage.
   *
   * @generated from field: repeated google.devtools.remoteexecution.v1test.Digest missing_blob_digests = 2;
   */
  missingBlobDigests: Digest[] = [];

  constructor(data?: PartialMessage<FindMissingBlobsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.FindMissingBlobsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "missing_blob_digests", kind: "message", T: Digest, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FindMissingBlobsResponse {
    return new FindMissingBlobsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FindMissingBlobsResponse {
    return new FindMissingBlobsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FindMissingBlobsResponse {
    return new FindMissingBlobsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FindMissingBlobsResponse | PlainMessage<FindMissingBlobsResponse> | undefined, b: FindMissingBlobsResponse | PlainMessage<FindMissingBlobsResponse> | undefined): boolean {
    return proto3.util.equals(FindMissingBlobsResponse, a, b);
  }
}

/**
 * A single request message for
 * [ContentAddressableStorage.BatchUpdateBlobs][google.devtools.remoteexecution.v1test.ContentAddressableStorage.BatchUpdateBlobs].
 *
 * @generated from message google.devtools.remoteexecution.v1test.UpdateBlobRequest
 */
export class UpdateBlobRequest extends Message<UpdateBlobRequest> {
  /**
   * The digest of the blob. This MUST be the digest of `data`.
   *
   * @generated from field: google.devtools.remoteexecution.v1test.Digest content_digest = 1;
   */
  contentDigest?: Digest;

  /**
   * The raw binary data.
   *
   * @generated from field: bytes data = 2;
   */
  data = new Uint8Array(0);

  constructor(data?: PartialMessage<UpdateBlobRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.UpdateBlobRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "content_digest", kind: "message", T: Digest },
    { no: 2, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateBlobRequest {
    return new UpdateBlobRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateBlobRequest {
    return new UpdateBlobRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateBlobRequest {
    return new UpdateBlobRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateBlobRequest | PlainMessage<UpdateBlobRequest> | undefined, b: UpdateBlobRequest | PlainMessage<UpdateBlobRequest> | undefined): boolean {
    return proto3.util.equals(UpdateBlobRequest, a, b);
  }
}

/**
 * A request message for
 * [ContentAddressableStorage.BatchUpdateBlobs][google.devtools.remoteexecution.v1test.ContentAddressableStorage.BatchUpdateBlobs].
 *
 * @generated from message google.devtools.remoteexecution.v1test.BatchUpdateBlobsRequest
 */
export class BatchUpdateBlobsRequest extends Message<BatchUpdateBlobsRequest> {
  /**
   * The instance of the execution system to operate against. A server may
   * support multiple instances of the execution system (with their own workers,
   * storage, caches, etc.). The server MAY require use of this field to select
   * between them in an implementation-defined fashion, otherwise it can be
   * omitted.
   *
   * @generated from field: string instance_name = 1;
   */
  instanceName = "";

  /**
   * The individual upload requests.
   *
   * @generated from field: repeated google.devtools.remoteexecution.v1test.UpdateBlobRequest requests = 2;
   */
  requests: UpdateBlobRequest[] = [];

  constructor(data?: PartialMessage<BatchUpdateBlobsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.BatchUpdateBlobsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "requests", kind: "message", T: UpdateBlobRequest, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchUpdateBlobsRequest {
    return new BatchUpdateBlobsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchUpdateBlobsRequest {
    return new BatchUpdateBlobsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchUpdateBlobsRequest {
    return new BatchUpdateBlobsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: BatchUpdateBlobsRequest | PlainMessage<BatchUpdateBlobsRequest> | undefined, b: BatchUpdateBlobsRequest | PlainMessage<BatchUpdateBlobsRequest> | undefined): boolean {
    return proto3.util.equals(BatchUpdateBlobsRequest, a, b);
  }
}

/**
 * A response message for
 * [ContentAddressableStorage.BatchUpdateBlobs][google.devtools.remoteexecution.v1test.ContentAddressableStorage.BatchUpdateBlobs].
 *
 * @generated from message google.devtools.remoteexecution.v1test.BatchUpdateBlobsResponse
 */
export class BatchUpdateBlobsResponse extends Message<BatchUpdateBlobsResponse> {
  /**
   * The responses to the requests.
   *
   * @generated from field: repeated google.devtools.remoteexecution.v1test.BatchUpdateBlobsResponse.Response responses = 1;
   */
  responses: BatchUpdateBlobsResponse_Response[] = [];

  constructor(data?: PartialMessage<BatchUpdateBlobsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.BatchUpdateBlobsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "responses", kind: "message", T: BatchUpdateBlobsResponse_Response, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchUpdateBlobsResponse {
    return new BatchUpdateBlobsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchUpdateBlobsResponse {
    return new BatchUpdateBlobsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchUpdateBlobsResponse {
    return new BatchUpdateBlobsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: BatchUpdateBlobsResponse | PlainMessage<BatchUpdateBlobsResponse> | undefined, b: BatchUpdateBlobsResponse | PlainMessage<BatchUpdateBlobsResponse> | undefined): boolean {
    return proto3.util.equals(BatchUpdateBlobsResponse, a, b);
  }
}

/**
 * A response corresponding to a single blob that the client tried to upload.
 *
 * @generated from message google.devtools.remoteexecution.v1test.BatchUpdateBlobsResponse.Response
 */
export class BatchUpdateBlobsResponse_Response extends Message<BatchUpdateBlobsResponse_Response> {
  /**
   * The digest to which this response corresponds.
   *
   * @generated from field: google.devtools.remoteexecution.v1test.Digest blob_digest = 1;
   */
  blobDigest?: Digest;

  /**
   * The result of attempting to upload that blob.
   *
   * @generated from field: google.rpc.Status status = 2;
   */
  status?: Status;

  constructor(data?: PartialMessage<BatchUpdateBlobsResponse_Response>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.BatchUpdateBlobsResponse.Response";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "blob_digest", kind: "message", T: Digest },
    { no: 2, name: "status", kind: "message", T: Status },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchUpdateBlobsResponse_Response {
    return new BatchUpdateBlobsResponse_Response().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchUpdateBlobsResponse_Response {
    return new BatchUpdateBlobsResponse_Response().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchUpdateBlobsResponse_Response {
    return new BatchUpdateBlobsResponse_Response().fromJsonString(jsonString, options);
  }

  static equals(a: BatchUpdateBlobsResponse_Response | PlainMessage<BatchUpdateBlobsResponse_Response> | undefined, b: BatchUpdateBlobsResponse_Response | PlainMessage<BatchUpdateBlobsResponse_Response> | undefined): boolean {
    return proto3.util.equals(BatchUpdateBlobsResponse_Response, a, b);
  }
}

/**
 * A request message for
 * [ContentAddressableStorage.GetTree][google.devtools.remoteexecution.v1test.ContentAddressableStorage.GetTree].
 * This message is deprecated and should no longer be used.
 *
 * @generated from message google.devtools.remoteexecution.v1test.GetTreeRequest
 */
export class GetTreeRequest extends Message<GetTreeRequest> {
  /**
   * The instance of the execution system to operate against. A server may
   * support multiple instances of the execution system (with their own workers,
   * storage, caches, etc.). The server MAY require use of this field to select
   * between them in an implementation-defined fashion, otherwise it can be
   * omitted.
   *
   * @generated from field: string instance_name = 1;
   */
  instanceName = "";

  /**
   * The digest of the root, which must be an encoded
   * [Directory][google.devtools.remoteexecution.v1test.Directory] message
   * stored in the
   * [ContentAddressableStorage][google.devtools.remoteexecution.v1test.ContentAddressableStorage].
   *
   * @generated from field: google.devtools.remoteexecution.v1test.Digest root_digest = 2;
   */
  rootDigest?: Digest;

  /**
   * A maximum page size to request. If present, the server will request no more
   * than this many items. Regardless of whether a page size is specified, the
   * server may place its own limit on the number of items to be returned and
   * require the client to retrieve more items using a subsequent request.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize = 0;

  /**
   * A page token, which must be a value received in a previous
   * [GetTreeResponse][google.devtools.remoteexecution.v1test.GetTreeResponse].
   * If present, the server will use it to return the following page of results.
   *
   * @generated from field: string page_token = 4;
   */
  pageToken = "";

  constructor(data?: PartialMessage<GetTreeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.GetTreeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "instance_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "root_digest", kind: "message", T: Digest },
    { no: 3, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTreeRequest {
    return new GetTreeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTreeRequest {
    return new GetTreeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTreeRequest {
    return new GetTreeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetTreeRequest | PlainMessage<GetTreeRequest> | undefined, b: GetTreeRequest | PlainMessage<GetTreeRequest> | undefined): boolean {
    return proto3.util.equals(GetTreeRequest, a, b);
  }
}

/**
 * A response message for
 * [ContentAddressableStorage.GetTree][google.devtools.remoteexecution.v1test.ContentAddressableStorage.GetTree].
 * This message is deprecated and should no longer be used.
 *
 * @generated from message google.devtools.remoteexecution.v1test.GetTreeResponse
 */
export class GetTreeResponse extends Message<GetTreeResponse> {
  /**
   * The directories descended from the requested root.
   *
   * @generated from field: repeated google.devtools.remoteexecution.v1test.Directory directories = 1;
   */
  directories: Directory[] = [];

  /**
   * If present, signifies that there are more results which the client can
   * retrieve by passing this as the page_token in a subsequent
   * [request][google.devtools.remoteexecution.v1test.GetTreeRequest].
   * If empty, signifies that this is the last page of results.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<GetTreeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.GetTreeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "directories", kind: "message", T: Directory, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTreeResponse {
    return new GetTreeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTreeResponse {
    return new GetTreeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTreeResponse {
    return new GetTreeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetTreeResponse | PlainMessage<GetTreeResponse> | undefined, b: GetTreeResponse | PlainMessage<GetTreeResponse> | undefined): boolean {
    return proto3.util.equals(GetTreeResponse, a, b);
  }
}

/**
 * Details for the tool used to call the API.
 *
 * @generated from message google.devtools.remoteexecution.v1test.ToolDetails
 */
export class ToolDetails extends Message<ToolDetails> {
  /**
   * Name of the tool, e.g. bazel.
   *
   * @generated from field: string tool_name = 1;
   */
  toolName = "";

  /**
   * Version of the tool used for the request, e.g. 5.0.3.
   *
   * @generated from field: string tool_version = 2;
   */
  toolVersion = "";

  constructor(data?: PartialMessage<ToolDetails>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.ToolDetails";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tool_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "tool_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ToolDetails {
    return new ToolDetails().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ToolDetails {
    return new ToolDetails().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ToolDetails {
    return new ToolDetails().fromJsonString(jsonString, options);
  }

  static equals(a: ToolDetails | PlainMessage<ToolDetails> | undefined, b: ToolDetails | PlainMessage<ToolDetails> | undefined): boolean {
    return proto3.util.equals(ToolDetails, a, b);
  }
}

/**
 * An optional Metadata to attach to any RPC request to tell the server about an
 * external context of the request. The server may use this for logging or other
 * purposes. To use it, the client attaches the header to the call using the
 * canonical proto serialization:
 * name: google.devtools.remoteexecution.v1test.requestmetadata-bin
 * contents: the base64 encoded binary RequestMetadata message.
 *
 * @generated from message google.devtools.remoteexecution.v1test.RequestMetadata
 */
export class RequestMetadata extends Message<RequestMetadata> {
  /**
   * The details for the tool invoking the requests.
   *
   * @generated from field: google.devtools.remoteexecution.v1test.ToolDetails tool_details = 1;
   */
  toolDetails?: ToolDetails;

  /**
   * An identifier that ties multiple requests to the same action.
   * For example, multiple requests to the CAS, Action Cache, and Execution
   * API are used in order to compile foo.cc.
   *
   * @generated from field: string action_id = 2;
   */
  actionId = "";

  /**
   * An identifier that ties multiple actions together to a final result.
   * For example, multiple actions are required to build and run foo_test.
   *
   * @generated from field: string tool_invocation_id = 3;
   */
  toolInvocationId = "";

  /**
   * An identifier to tie multiple tool invocations together. For example,
   * runs of foo_test, bar_test and baz_test on a post-submit of a given patch.
   *
   * @generated from field: string correlated_invocations_id = 4;
   */
  correlatedInvocationsId = "";

  constructor(data?: PartialMessage<RequestMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.remoteexecution.v1test.RequestMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tool_details", kind: "message", T: ToolDetails },
    { no: 2, name: "action_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "tool_invocation_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "correlated_invocations_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RequestMetadata {
    return new RequestMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RequestMetadata {
    return new RequestMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RequestMetadata {
    return new RequestMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: RequestMetadata | PlainMessage<RequestMetadata> | undefined, b: RequestMetadata | PlainMessage<RequestMetadata> | undefined): boolean {
    return proto3.util.equals(RequestMetadata, a, b);
  }
}

