// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/devtools/clouddebugger/v2/controller.proto (package google.devtools.clouddebugger.v2, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Breakpoint, Debuggee } from "./data_pb.js";

/**
 * Request to register a debuggee.
 *
 * @generated from message google.devtools.clouddebugger.v2.RegisterDebuggeeRequest
 */
export class RegisterDebuggeeRequest extends Message<RegisterDebuggeeRequest> {
  /**
   * Debuggee information to register.
   * The fields `project`, `uniquifier`, `description` and `agent_version`
   * of the debuggee must be set.
   *
   * @generated from field: google.devtools.clouddebugger.v2.Debuggee debuggee = 1;
   */
  debuggee?: Debuggee;

  constructor(data?: PartialMessage<RegisterDebuggeeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.clouddebugger.v2.RegisterDebuggeeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "debuggee", kind: "message", T: Debuggee },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterDebuggeeRequest {
    return new RegisterDebuggeeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterDebuggeeRequest {
    return new RegisterDebuggeeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterDebuggeeRequest {
    return new RegisterDebuggeeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterDebuggeeRequest | PlainMessage<RegisterDebuggeeRequest> | undefined, b: RegisterDebuggeeRequest | PlainMessage<RegisterDebuggeeRequest> | undefined): boolean {
    return proto3.util.equals(RegisterDebuggeeRequest, a, b);
  }
}

/**
 * Response for registering a debuggee.
 *
 * @generated from message google.devtools.clouddebugger.v2.RegisterDebuggeeResponse
 */
export class RegisterDebuggeeResponse extends Message<RegisterDebuggeeResponse> {
  /**
   * Debuggee resource.
   * The field `id` is guranteed to be set (in addition to the echoed fields).
   * If the field `is_disabled` is set to `true`, the agent should disable
   * itself by removing all breakpoints and detaching from the application.
   * It should however continue to poll `RegisterDebuggee` until reenabled.
   *
   * @generated from field: google.devtools.clouddebugger.v2.Debuggee debuggee = 1;
   */
  debuggee?: Debuggee;

  constructor(data?: PartialMessage<RegisterDebuggeeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.clouddebugger.v2.RegisterDebuggeeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "debuggee", kind: "message", T: Debuggee },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterDebuggeeResponse {
    return new RegisterDebuggeeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterDebuggeeResponse {
    return new RegisterDebuggeeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterDebuggeeResponse {
    return new RegisterDebuggeeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterDebuggeeResponse | PlainMessage<RegisterDebuggeeResponse> | undefined, b: RegisterDebuggeeResponse | PlainMessage<RegisterDebuggeeResponse> | undefined): boolean {
    return proto3.util.equals(RegisterDebuggeeResponse, a, b);
  }
}

/**
 * Request to list active breakpoints.
 *
 * @generated from message google.devtools.clouddebugger.v2.ListActiveBreakpointsRequest
 */
export class ListActiveBreakpointsRequest extends Message<ListActiveBreakpointsRequest> {
  /**
   * Identifies the debuggee.
   *
   * @generated from field: string debuggee_id = 1;
   */
  debuggeeId = "";

  /**
   * A token that, if specified, blocks the method call until the list
   * of active breakpoints has changed, or a server-selected timeout has
   * expired. The value should be set from the `next_wait_token` field in
   * the last response. The initial value should be set to `"init"`.
   *
   * @generated from field: string wait_token = 2;
   */
  waitToken = "";

  /**
   * If set to `true` (recommended), returns `google.rpc.Code.OK` status and
   * sets the `wait_expired` response field to `true` when the server-selected
   * timeout has expired.
   *
   * If set to `false` (deprecated), returns `google.rpc.Code.ABORTED` status
   * when the server-selected timeout has expired.
   *
   * @generated from field: bool success_on_timeout = 3;
   */
  successOnTimeout = false;

  constructor(data?: PartialMessage<ListActiveBreakpointsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.clouddebugger.v2.ListActiveBreakpointsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "debuggee_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "wait_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "success_on_timeout", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListActiveBreakpointsRequest {
    return new ListActiveBreakpointsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListActiveBreakpointsRequest {
    return new ListActiveBreakpointsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListActiveBreakpointsRequest {
    return new ListActiveBreakpointsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListActiveBreakpointsRequest | PlainMessage<ListActiveBreakpointsRequest> | undefined, b: ListActiveBreakpointsRequest | PlainMessage<ListActiveBreakpointsRequest> | undefined): boolean {
    return proto3.util.equals(ListActiveBreakpointsRequest, a, b);
  }
}

/**
 * Response for listing active breakpoints.
 *
 * @generated from message google.devtools.clouddebugger.v2.ListActiveBreakpointsResponse
 */
export class ListActiveBreakpointsResponse extends Message<ListActiveBreakpointsResponse> {
  /**
   * List of all active breakpoints.
   * The fields `id` and `location` are guaranteed to be set on each breakpoint.
   *
   * @generated from field: repeated google.devtools.clouddebugger.v2.Breakpoint breakpoints = 1;
   */
  breakpoints: Breakpoint[] = [];

  /**
   * A token that can be used in the next method call to block until
   * the list of breakpoints changes.
   *
   * @generated from field: string next_wait_token = 2;
   */
  nextWaitToken = "";

  /**
   * If set to `true`, indicates that there is no change to the
   * list of active breakpoints and the server-selected timeout has expired.
   * The `breakpoints` field would be empty and should be ignored.
   *
   * @generated from field: bool wait_expired = 3;
   */
  waitExpired = false;

  constructor(data?: PartialMessage<ListActiveBreakpointsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.clouddebugger.v2.ListActiveBreakpointsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "breakpoints", kind: "message", T: Breakpoint, repeated: true },
    { no: 2, name: "next_wait_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "wait_expired", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListActiveBreakpointsResponse {
    return new ListActiveBreakpointsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListActiveBreakpointsResponse {
    return new ListActiveBreakpointsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListActiveBreakpointsResponse {
    return new ListActiveBreakpointsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListActiveBreakpointsResponse | PlainMessage<ListActiveBreakpointsResponse> | undefined, b: ListActiveBreakpointsResponse | PlainMessage<ListActiveBreakpointsResponse> | undefined): boolean {
    return proto3.util.equals(ListActiveBreakpointsResponse, a, b);
  }
}

/**
 * Request to update an active breakpoint.
 *
 * @generated from message google.devtools.clouddebugger.v2.UpdateActiveBreakpointRequest
 */
export class UpdateActiveBreakpointRequest extends Message<UpdateActiveBreakpointRequest> {
  /**
   * Identifies the debuggee being debugged.
   *
   * @generated from field: string debuggee_id = 1;
   */
  debuggeeId = "";

  /**
   * Updated breakpoint information.
   * The field `id` must be set.
   * The agent must echo all Breakpoint specification fields in the update.
   *
   * @generated from field: google.devtools.clouddebugger.v2.Breakpoint breakpoint = 2;
   */
  breakpoint?: Breakpoint;

  constructor(data?: PartialMessage<UpdateActiveBreakpointRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.clouddebugger.v2.UpdateActiveBreakpointRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "debuggee_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "breakpoint", kind: "message", T: Breakpoint },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateActiveBreakpointRequest {
    return new UpdateActiveBreakpointRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateActiveBreakpointRequest {
    return new UpdateActiveBreakpointRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateActiveBreakpointRequest {
    return new UpdateActiveBreakpointRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateActiveBreakpointRequest | PlainMessage<UpdateActiveBreakpointRequest> | undefined, b: UpdateActiveBreakpointRequest | PlainMessage<UpdateActiveBreakpointRequest> | undefined): boolean {
    return proto3.util.equals(UpdateActiveBreakpointRequest, a, b);
  }
}

/**
 * Response for updating an active breakpoint.
 * The message is defined to allow future extensions.
 *
 * @generated from message google.devtools.clouddebugger.v2.UpdateActiveBreakpointResponse
 */
export class UpdateActiveBreakpointResponse extends Message<UpdateActiveBreakpointResponse> {
  constructor(data?: PartialMessage<UpdateActiveBreakpointResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.devtools.clouddebugger.v2.UpdateActiveBreakpointResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateActiveBreakpointResponse {
    return new UpdateActiveBreakpointResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateActiveBreakpointResponse {
    return new UpdateActiveBreakpointResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateActiveBreakpointResponse {
    return new UpdateActiveBreakpointResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateActiveBreakpointResponse | PlainMessage<UpdateActiveBreakpointResponse> | undefined, b: UpdateActiveBreakpointResponse | PlainMessage<UpdateActiveBreakpointResponse> | undefined): boolean {
    return proto3.util.equals(UpdateActiveBreakpointResponse, a, b);
  }
}

