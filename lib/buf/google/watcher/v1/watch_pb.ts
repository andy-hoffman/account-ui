// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/watcher/v1/watch.proto (package google.watcher.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Any, Message, proto3 } from "@bufbuild/protobuf";

/**
 * The message used by the client to register interest in an entity.
 *
 * @generated from message google.watcher.v1.Request
 */
export class Request extends Message<Request> {
  /**
   * The `target` value **must** be a valid URL path pointing to an entity
   * to watch. Note that the service name **must** be
   * removed from the target field (e.g., the target field must say
   * "/foo/bar", not "myservice.googleapis.com/foo/bar"). A client is
   * also allowed to pass system-specific parameters in the URL that
   * are only obeyed by some implementations. Some parameters will be
   * implementation-specific. However, some have predefined meaning
   * and are listed here:
   *
   *  * recursive = true|false [default=false]
   *    If set to true, indicates that the client wants to watch all elements
   *    of entities in the subtree rooted at the entity's name in `target`. For
   *    descendants that are not the immediate children of the target, the
   *    `Change.element` will contain slashes.
   *
   *    Note that some namespaces and entities will not support recursive
   *    watching. When watching such an entity, a client must not set recursive
   *    to true. Otherwise, it will receive an `UNIMPLEMENTED` error.
   *
   * Normal URL encoding must be used inside `target`.  For example, if a query
   * parameter name or value, or the non-query parameter portion of `target`
   * contains a special character, it must be %-encoded.  We recommend that
   * clients and servers use their runtime's URL library to produce and consume
   * target values.
   *
   * @generated from field: string target = 1;
   */
  target = "";

  /**
   * The `resume_marker` specifies how much of the existing underlying state is
   * delivered to the client when the watch request is received by the
   * system. The client can set this marker in one of the following ways to get
   * different semantics:
   *
   * *   Parameter is not specified or has the value "".
   *     Semantics: Fetch initial state.
   *     The client wants the entity's initial state to be delivered. See the
   *     description in "Initial State".
   *
   * *   Parameter is set to the string "now" (UTF-8 encoding).
   *     Semantics: Fetch new changes only.
   *     The client just wants to get the changes received by the system after
   *     the watch point. The system may deliver changes from before the watch
   *     point as well.
   *
   * *   Parameter is set to a value received in an earlier
   *     `Change.resume_marker` field while watching the same entity.
   *     Semantics: Resume from a specific point.
   *     The client wants to receive the changes from a specific point; this
   *     value must correspond to a value received in the `Change.resume_marker`
   *     field. The system may deliver changes from before the `resume_marker`
   *     as well. If the system cannot resume the stream from this point (e.g.,
   *     if it is too far behind in the stream), it can raise the
   *     `FAILED_PRECONDITION` error.
   *
   * An implementation MUST support an unspecified parameter and the
   * empty string "" marker (initial state fetching) and the "now" marker.
   * It need not support resuming from a specific point.
   *
   * @generated from field: bytes resume_marker = 2;
   */
  resumeMarker = new Uint8Array(0);

  constructor(data?: PartialMessage<Request>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.watcher.v1.Request";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "target", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "resume_marker", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Request {
    return new Request().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Request {
    return new Request().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Request {
    return new Request().fromJsonString(jsonString, options);
  }

  static equals(a: Request | PlainMessage<Request> | undefined, b: Request | PlainMessage<Request> | undefined): boolean {
    return proto3.util.equals(Request, a, b);
  }
}

/**
 * A batch of Change messages.
 *
 * @generated from message google.watcher.v1.ChangeBatch
 */
export class ChangeBatch extends Message<ChangeBatch> {
  /**
   * A list of Change messages.
   *
   * @generated from field: repeated google.watcher.v1.Change changes = 1;
   */
  changes: Change[] = [];

  constructor(data?: PartialMessage<ChangeBatch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.watcher.v1.ChangeBatch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "changes", kind: "message", T: Change, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChangeBatch {
    return new ChangeBatch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChangeBatch {
    return new ChangeBatch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChangeBatch {
    return new ChangeBatch().fromJsonString(jsonString, options);
  }

  static equals(a: ChangeBatch | PlainMessage<ChangeBatch> | undefined, b: ChangeBatch | PlainMessage<ChangeBatch> | undefined): boolean {
    return proto3.util.equals(ChangeBatch, a, b);
  }
}

/**
 * A Change indicates the most recent state of an element.
 *
 * @generated from message google.watcher.v1.Change
 */
export class Change extends Message<Change> {
  /**
   * Name of the element, interpreted relative to the entity's actual
   * name. "" refers to the entity itself. The element name is a valid
   * UTF-8 string.
   *
   * @generated from field: string element = 1;
   */
  element = "";

  /**
   * The state of the `element`.
   *
   * @generated from field: google.watcher.v1.Change.State state = 2;
   */
  state = Change_State.EXISTS;

  /**
   * The actual change data. This field is present only when `state() == EXISTS`
   * or `state() == ERROR`. Please see [google.protobuf.Any][google.protobuf.Any] about how to use
   * the Any type.
   *
   * @generated from field: google.protobuf.Any data = 6;
   */
  data?: Any;

  /**
   * If present, provides a compact representation of all the messages that have
   * been received by the caller for the given entity, e.g., it could be a
   * sequence number or a multi-part timestamp/version vector. This marker can
   * be provided in the Request message, allowing the caller to resume the stream
   * watching at a specific point without fetching the initial state.
   *
   * @generated from field: bytes resume_marker = 4;
   */
  resumeMarker = new Uint8Array(0);

  /**
   * If true, this Change is followed by more Changes that are in the same group
   * as this Change.
   *
   * @generated from field: bool continued = 5;
   */
  continued = false;

  constructor(data?: PartialMessage<Change>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.watcher.v1.Change";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "element", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "state", kind: "enum", T: proto3.getEnumType(Change_State) },
    { no: 6, name: "data", kind: "message", T: Any },
    { no: 4, name: "resume_marker", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "continued", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Change {
    return new Change().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Change {
    return new Change().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Change {
    return new Change().fromJsonString(jsonString, options);
  }

  static equals(a: Change | PlainMessage<Change> | undefined, b: Change | PlainMessage<Change> | undefined): boolean {
    return proto3.util.equals(Change, a, b);
  }
}

/**
 * A reported value can be in one of the following states:
 *
 * @generated from enum google.watcher.v1.Change.State
 */
export enum Change_State {
  /**
   * The element exists and its full value is included in data.
   *
   * @generated from enum value: EXISTS = 0;
   */
  EXISTS = 0,

  /**
   * The element does not exist.
   *
   * @generated from enum value: DOES_NOT_EXIST = 1;
   */
  DOES_NOT_EXIST = 1,

  /**
   * Element may or may not exist. Used only for initial state delivery when
   * the client is not interested in fetching the initial state. See the
   * "Initial State" section above.
   *
   * @generated from enum value: INITIAL_STATE_SKIPPED = 2;
   */
  INITIAL_STATE_SKIPPED = 2,

  /**
   * The element may exist, but some error has occurred. More information is
   * available in the data field - the value is a serialized Status
   * proto (from [google.rpc.Status][])
   *
   * @generated from enum value: ERROR = 3;
   */
  ERROR = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(Change_State)
proto3.util.setEnumType(Change_State, "google.watcher.v1.Change.State", [
  { no: 0, name: "EXISTS" },
  { no: 1, name: "DOES_NOT_EXIST" },
  { no: 2, name: "INITIAL_STATE_SKIPPED" },
  { no: 3, name: "ERROR" },
]);

