// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/firestore/v1beta1/write.proto (package google.firestore.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { Document, Value } from "./document_pb.js";
import { DocumentMask, Precondition } from "./common_pb.js";

/**
 * A write on a document.
 *
 * @generated from message google.firestore.v1beta1.Write
 */
export class Write extends Message<Write> {
  /**
   * The operation to execute.
   *
   * @generated from oneof google.firestore.v1beta1.Write.operation
   */
  operation: {
    /**
     * A document to write.
     *
     * @generated from field: google.firestore.v1beta1.Document update = 1;
     */
    value: Document;
    case: "update";
  } | {
    /**
     * A document name to delete. In the format:
     * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
     *
     * @generated from field: string delete = 2;
     */
    value: string;
    case: "delete";
  } | {
    /**
     * Applies a tranformation to a document.
     * At most one `transform` per document is allowed in a given request.
     * An `update` cannot follow a `transform` on the same document in a given
     * request.
     *
     * @generated from field: google.firestore.v1beta1.DocumentTransform transform = 6;
     */
    value: DocumentTransform;
    case: "transform";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The fields to update in this write.
   *
   * This field can be set only when the operation is `update`.
   * None of the field paths in the mask may contain a reserved name.
   * If the document exists on the server and has fields not referenced in the
   * mask, they are left unchanged.
   * Fields referenced in the mask, but not present in the input document, are
   * deleted from the document on the server.
   * The field paths in this mask must not contain a reserved field name.
   *
   * @generated from field: google.firestore.v1beta1.DocumentMask update_mask = 3;
   */
  updateMask?: DocumentMask;

  /**
   * An optional precondition on the document.
   *
   * The write will fail if this is set and not met by the target document.
   *
   * @generated from field: google.firestore.v1beta1.Precondition current_document = 4;
   */
  currentDocument?: Precondition;

  constructor(data?: PartialMessage<Write>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.Write";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "update", kind: "message", T: Document, oneof: "operation" },
    { no: 2, name: "delete", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "operation" },
    { no: 6, name: "transform", kind: "message", T: DocumentTransform, oneof: "operation" },
    { no: 3, name: "update_mask", kind: "message", T: DocumentMask },
    { no: 4, name: "current_document", kind: "message", T: Precondition },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Write {
    return new Write().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Write {
    return new Write().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Write {
    return new Write().fromJsonString(jsonString, options);
  }

  static equals(a: Write | PlainMessage<Write> | undefined, b: Write | PlainMessage<Write> | undefined): boolean {
    return proto3.util.equals(Write, a, b);
  }
}

/**
 * A transformation of a document.
 *
 * @generated from message google.firestore.v1beta1.DocumentTransform
 */
export class DocumentTransform extends Message<DocumentTransform> {
  /**
   * The name of the document to transform.
   *
   * @generated from field: string document = 1;
   */
  document = "";

  /**
   * The list of transformations to apply to the fields of the document, in
   * order.
   *
   * @generated from field: repeated google.firestore.v1beta1.DocumentTransform.FieldTransform field_transforms = 2;
   */
  fieldTransforms: DocumentTransform_FieldTransform[] = [];

  constructor(data?: PartialMessage<DocumentTransform>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.DocumentTransform";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "field_transforms", kind: "message", T: DocumentTransform_FieldTransform, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DocumentTransform {
    return new DocumentTransform().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DocumentTransform {
    return new DocumentTransform().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DocumentTransform {
    return new DocumentTransform().fromJsonString(jsonString, options);
  }

  static equals(a: DocumentTransform | PlainMessage<DocumentTransform> | undefined, b: DocumentTransform | PlainMessage<DocumentTransform> | undefined): boolean {
    return proto3.util.equals(DocumentTransform, a, b);
  }
}

/**
 * A transformation of a field of the document.
 *
 * @generated from message google.firestore.v1beta1.DocumentTransform.FieldTransform
 */
export class DocumentTransform_FieldTransform extends Message<DocumentTransform_FieldTransform> {
  /**
   * The path of the field. See [Document.fields][google.firestore.v1beta1.Document.fields] for the field path syntax
   * reference.
   *
   * @generated from field: string field_path = 1;
   */
  fieldPath = "";

  /**
   * The transformation to apply on the field.
   *
   * @generated from oneof google.firestore.v1beta1.DocumentTransform.FieldTransform.transform_type
   */
  transformType: {
    /**
     * Sets the field to the given server value.
     *
     * @generated from field: google.firestore.v1beta1.DocumentTransform.FieldTransform.ServerValue set_to_server_value = 2;
     */
    value: DocumentTransform_FieldTransform_ServerValue;
    case: "setToServerValue";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<DocumentTransform_FieldTransform>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.DocumentTransform.FieldTransform";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "set_to_server_value", kind: "enum", T: proto3.getEnumType(DocumentTransform_FieldTransform_ServerValue), oneof: "transform_type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DocumentTransform_FieldTransform {
    return new DocumentTransform_FieldTransform().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DocumentTransform_FieldTransform {
    return new DocumentTransform_FieldTransform().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DocumentTransform_FieldTransform {
    return new DocumentTransform_FieldTransform().fromJsonString(jsonString, options);
  }

  static equals(a: DocumentTransform_FieldTransform | PlainMessage<DocumentTransform_FieldTransform> | undefined, b: DocumentTransform_FieldTransform | PlainMessage<DocumentTransform_FieldTransform> | undefined): boolean {
    return proto3.util.equals(DocumentTransform_FieldTransform, a, b);
  }
}

/**
 * A value that is calculated by the server.
 *
 * @generated from enum google.firestore.v1beta1.DocumentTransform.FieldTransform.ServerValue
 */
export enum DocumentTransform_FieldTransform_ServerValue {
  /**
   * Unspecified. This value must not be used.
   *
   * @generated from enum value: SERVER_VALUE_UNSPECIFIED = 0;
   */
  SERVER_VALUE_UNSPECIFIED = 0,

  /**
   * The time at which the server processed the request.
   *
   * @generated from enum value: REQUEST_TIME = 1;
   */
  REQUEST_TIME = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(DocumentTransform_FieldTransform_ServerValue)
proto3.util.setEnumType(DocumentTransform_FieldTransform_ServerValue, "google.firestore.v1beta1.DocumentTransform.FieldTransform.ServerValue", [
  { no: 0, name: "SERVER_VALUE_UNSPECIFIED" },
  { no: 1, name: "REQUEST_TIME" },
]);

/**
 * The result of applying a write.
 *
 * @generated from message google.firestore.v1beta1.WriteResult
 */
export class WriteResult extends Message<WriteResult> {
  /**
   * The last update time of the document after applying the write. Not set
   * after a `delete`.
   *
   * If the write did not actually change the document, this will be the
   * previous update_time.
   *
   * @generated from field: google.protobuf.Timestamp update_time = 1;
   */
  updateTime?: Timestamp;

  /**
   * The results of applying each [DocumentTransform.FieldTransform][google.firestore.v1beta1.DocumentTransform.FieldTransform], in the
   * same order.
   *
   * @generated from field: repeated google.firestore.v1beta1.Value transform_results = 2;
   */
  transformResults: Value[] = [];

  constructor(data?: PartialMessage<WriteResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.WriteResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "update_time", kind: "message", T: Timestamp },
    { no: 2, name: "transform_results", kind: "message", T: Value, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WriteResult {
    return new WriteResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WriteResult {
    return new WriteResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WriteResult {
    return new WriteResult().fromJsonString(jsonString, options);
  }

  static equals(a: WriteResult | PlainMessage<WriteResult> | undefined, b: WriteResult | PlainMessage<WriteResult> | undefined): boolean {
    return proto3.util.equals(WriteResult, a, b);
  }
}

/**
 * A [Document][google.firestore.v1beta1.Document] has changed.
 *
 * May be the result of multiple [writes][google.firestore.v1beta1.Write], including deletes, that
 * ultimately resulted in a new value for the [Document][google.firestore.v1beta1.Document].
 *
 * Multiple [DocumentChange][google.firestore.v1beta1.DocumentChange] messages may be returned for the same logical
 * change, if multiple targets are affected.
 *
 * @generated from message google.firestore.v1beta1.DocumentChange
 */
export class DocumentChange extends Message<DocumentChange> {
  /**
   * The new state of the [Document][google.firestore.v1beta1.Document].
   *
   * If `mask` is set, contains only fields that were updated or added.
   *
   * @generated from field: google.firestore.v1beta1.Document document = 1;
   */
  document?: Document;

  /**
   * A set of target IDs of targets that match this document.
   *
   * @generated from field: repeated int32 target_ids = 5;
   */
  targetIds: number[] = [];

  /**
   * A set of target IDs for targets that no longer match this document.
   *
   * @generated from field: repeated int32 removed_target_ids = 6;
   */
  removedTargetIds: number[] = [];

  constructor(data?: PartialMessage<DocumentChange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.DocumentChange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document", kind: "message", T: Document },
    { no: 5, name: "target_ids", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 6, name: "removed_target_ids", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DocumentChange {
    return new DocumentChange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DocumentChange {
    return new DocumentChange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DocumentChange {
    return new DocumentChange().fromJsonString(jsonString, options);
  }

  static equals(a: DocumentChange | PlainMessage<DocumentChange> | undefined, b: DocumentChange | PlainMessage<DocumentChange> | undefined): boolean {
    return proto3.util.equals(DocumentChange, a, b);
  }
}

/**
 * A [Document][google.firestore.v1beta1.Document] has been deleted.
 *
 * May be the result of multiple [writes][google.firestore.v1beta1.Write], including updates, the
 * last of which deleted the [Document][google.firestore.v1beta1.Document].
 *
 * Multiple [DocumentDelete][google.firestore.v1beta1.DocumentDelete] messages may be returned for the same logical
 * delete, if multiple targets are affected.
 *
 * @generated from message google.firestore.v1beta1.DocumentDelete
 */
export class DocumentDelete extends Message<DocumentDelete> {
  /**
   * The resource name of the [Document][google.firestore.v1beta1.Document] that was deleted.
   *
   * @generated from field: string document = 1;
   */
  document = "";

  /**
   * A set of target IDs for targets that previously matched this entity.
   *
   * @generated from field: repeated int32 removed_target_ids = 6;
   */
  removedTargetIds: number[] = [];

  /**
   * The read timestamp at which the delete was observed.
   *
   * Greater or equal to the `commit_time` of the delete.
   *
   * @generated from field: google.protobuf.Timestamp read_time = 4;
   */
  readTime?: Timestamp;

  constructor(data?: PartialMessage<DocumentDelete>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.DocumentDelete";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "removed_target_ids", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 4, name: "read_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DocumentDelete {
    return new DocumentDelete().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DocumentDelete {
    return new DocumentDelete().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DocumentDelete {
    return new DocumentDelete().fromJsonString(jsonString, options);
  }

  static equals(a: DocumentDelete | PlainMessage<DocumentDelete> | undefined, b: DocumentDelete | PlainMessage<DocumentDelete> | undefined): boolean {
    return proto3.util.equals(DocumentDelete, a, b);
  }
}

/**
 * A [Document][google.firestore.v1beta1.Document] has been removed from the view of the targets.
 *
 * Sent if the document is no longer relevant to a target and is out of view.
 * Can be sent instead of a DocumentDelete or a DocumentChange if the server
 * can not send the new value of the document.
 *
 * Multiple [DocumentRemove][google.firestore.v1beta1.DocumentRemove] messages may be returned for the same logical
 * write or delete, if multiple targets are affected.
 *
 * @generated from message google.firestore.v1beta1.DocumentRemove
 */
export class DocumentRemove extends Message<DocumentRemove> {
  /**
   * The resource name of the [Document][google.firestore.v1beta1.Document] that has gone out of view.
   *
   * @generated from field: string document = 1;
   */
  document = "";

  /**
   * A set of target IDs for targets that previously matched this document.
   *
   * @generated from field: repeated int32 removed_target_ids = 2;
   */
  removedTargetIds: number[] = [];

  /**
   * The read timestamp at which the remove was observed.
   *
   * Greater or equal to the `commit_time` of the change/delete/remove.
   *
   * @generated from field: google.protobuf.Timestamp read_time = 4;
   */
  readTime?: Timestamp;

  constructor(data?: PartialMessage<DocumentRemove>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.DocumentRemove";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "removed_target_ids", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 4, name: "read_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DocumentRemove {
    return new DocumentRemove().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DocumentRemove {
    return new DocumentRemove().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DocumentRemove {
    return new DocumentRemove().fromJsonString(jsonString, options);
  }

  static equals(a: DocumentRemove | PlainMessage<DocumentRemove> | undefined, b: DocumentRemove | PlainMessage<DocumentRemove> | undefined): boolean {
    return proto3.util.equals(DocumentRemove, a, b);
  }
}

/**
 * A digest of all the documents that match a given target.
 *
 * @generated from message google.firestore.v1beta1.ExistenceFilter
 */
export class ExistenceFilter extends Message<ExistenceFilter> {
  /**
   * The target ID to which this filter applies.
   *
   * @generated from field: int32 target_id = 1;
   */
  targetId = 0;

  /**
   * The total count of documents that match [target_id][google.firestore.v1beta1.ExistenceFilter.target_id].
   *
   * If different from the count of documents in the client that match, the
   * client must manually determine which documents no longer match the target.
   *
   * @generated from field: int32 count = 2;
   */
  count = 0;

  constructor(data?: PartialMessage<ExistenceFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.ExistenceFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "target_id", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExistenceFilter {
    return new ExistenceFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExistenceFilter {
    return new ExistenceFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExistenceFilter {
    return new ExistenceFilter().fromJsonString(jsonString, options);
  }

  static equals(a: ExistenceFilter | PlainMessage<ExistenceFilter> | undefined, b: ExistenceFilter | PlainMessage<ExistenceFilter> | undefined): boolean {
    return proto3.util.equals(ExistenceFilter, a, b);
  }
}

