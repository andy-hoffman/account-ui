// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/firestore/v1beta1/common.proto (package google.firestore.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";

/**
 * A set of field paths on a document.
 * Used to restrict a get or update operation on a document to a subset of its
 * fields.
 * This is different from standard field masks, as this is always scoped to a
 * [Document][google.firestore.v1beta1.Document], and takes in account the dynamic nature of [Value][google.firestore.v1beta1.Value].
 *
 * @generated from message google.firestore.v1beta1.DocumentMask
 */
export class DocumentMask extends Message<DocumentMask> {
  /**
   * The list of field paths in the mask. See [Document.fields][google.firestore.v1beta1.Document.fields] for a field
   * path syntax reference.
   *
   * @generated from field: repeated string field_paths = 1;
   */
  fieldPaths: string[] = [];

  constructor(data?: PartialMessage<DocumentMask>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.DocumentMask";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field_paths", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DocumentMask {
    return new DocumentMask().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DocumentMask {
    return new DocumentMask().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DocumentMask {
    return new DocumentMask().fromJsonString(jsonString, options);
  }

  static equals(a: DocumentMask | PlainMessage<DocumentMask> | undefined, b: DocumentMask | PlainMessage<DocumentMask> | undefined): boolean {
    return proto3.util.equals(DocumentMask, a, b);
  }
}

/**
 * A precondition on a document, used for conditional operations.
 *
 * @generated from message google.firestore.v1beta1.Precondition
 */
export class Precondition extends Message<Precondition> {
  /**
   * The type of precondition.
   *
   * @generated from oneof google.firestore.v1beta1.Precondition.condition_type
   */
  conditionType: {
    /**
     * When set to `true`, the target document must exist.
     * When set to `false`, the target document must not exist.
     *
     * @generated from field: bool exists = 1;
     */
    value: boolean;
    case: "exists";
  } | {
    /**
     * When set, the target document must exist and have been last updated at
     * that time.
     *
     * @generated from field: google.protobuf.Timestamp update_time = 2;
     */
    value: Timestamp;
    case: "updateTime";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Precondition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.Precondition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "exists", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "condition_type" },
    { no: 2, name: "update_time", kind: "message", T: Timestamp, oneof: "condition_type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Precondition {
    return new Precondition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Precondition {
    return new Precondition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Precondition {
    return new Precondition().fromJsonString(jsonString, options);
  }

  static equals(a: Precondition | PlainMessage<Precondition> | undefined, b: Precondition | PlainMessage<Precondition> | undefined): boolean {
    return proto3.util.equals(Precondition, a, b);
  }
}

/**
 * Options for creating a new transaction.
 *
 * @generated from message google.firestore.v1beta1.TransactionOptions
 */
export class TransactionOptions extends Message<TransactionOptions> {
  /**
   * The mode of the transaction.
   *
   * @generated from oneof google.firestore.v1beta1.TransactionOptions.mode
   */
  mode: {
    /**
     * The transaction can only be used for read operations.
     *
     * @generated from field: google.firestore.v1beta1.TransactionOptions.ReadOnly read_only = 2;
     */
    value: TransactionOptions_ReadOnly;
    case: "readOnly";
  } | {
    /**
     * The transaction can be used for both read and write operations.
     *
     * @generated from field: google.firestore.v1beta1.TransactionOptions.ReadWrite read_write = 3;
     */
    value: TransactionOptions_ReadWrite;
    case: "readWrite";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<TransactionOptions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.TransactionOptions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "read_only", kind: "message", T: TransactionOptions_ReadOnly, oneof: "mode" },
    { no: 3, name: "read_write", kind: "message", T: TransactionOptions_ReadWrite, oneof: "mode" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionOptions {
    return new TransactionOptions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionOptions {
    return new TransactionOptions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionOptions {
    return new TransactionOptions().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionOptions | PlainMessage<TransactionOptions> | undefined, b: TransactionOptions | PlainMessage<TransactionOptions> | undefined): boolean {
    return proto3.util.equals(TransactionOptions, a, b);
  }
}

/**
 * Options for a transaction that can be used to read and write documents.
 *
 * @generated from message google.firestore.v1beta1.TransactionOptions.ReadWrite
 */
export class TransactionOptions_ReadWrite extends Message<TransactionOptions_ReadWrite> {
  /**
   * An optional transaction to retry.
   *
   * @generated from field: bytes retry_transaction = 1;
   */
  retryTransaction = new Uint8Array(0);

  constructor(data?: PartialMessage<TransactionOptions_ReadWrite>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.TransactionOptions.ReadWrite";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "retry_transaction", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionOptions_ReadWrite {
    return new TransactionOptions_ReadWrite().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionOptions_ReadWrite {
    return new TransactionOptions_ReadWrite().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionOptions_ReadWrite {
    return new TransactionOptions_ReadWrite().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionOptions_ReadWrite | PlainMessage<TransactionOptions_ReadWrite> | undefined, b: TransactionOptions_ReadWrite | PlainMessage<TransactionOptions_ReadWrite> | undefined): boolean {
    return proto3.util.equals(TransactionOptions_ReadWrite, a, b);
  }
}

/**
 * Options for a transaction that can only be used to read documents.
 *
 * @generated from message google.firestore.v1beta1.TransactionOptions.ReadOnly
 */
export class TransactionOptions_ReadOnly extends Message<TransactionOptions_ReadOnly> {
  /**
   * The consistency mode for this transaction. If not set, defaults to strong
   * consistency.
   *
   * @generated from oneof google.firestore.v1beta1.TransactionOptions.ReadOnly.consistency_selector
   */
  consistencySelector: {
    /**
     * Reads documents at the given time.
     * This may not be older than 60 seconds.
     *
     * @generated from field: google.protobuf.Timestamp read_time = 2;
     */
    value: Timestamp;
    case: "readTime";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<TransactionOptions_ReadOnly>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.TransactionOptions.ReadOnly";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "read_time", kind: "message", T: Timestamp, oneof: "consistency_selector" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TransactionOptions_ReadOnly {
    return new TransactionOptions_ReadOnly().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TransactionOptions_ReadOnly {
    return new TransactionOptions_ReadOnly().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TransactionOptions_ReadOnly {
    return new TransactionOptions_ReadOnly().fromJsonString(jsonString, options);
  }

  static equals(a: TransactionOptions_ReadOnly | PlainMessage<TransactionOptions_ReadOnly> | undefined, b: TransactionOptions_ReadOnly | PlainMessage<TransactionOptions_ReadOnly> | undefined): boolean {
    return proto3.util.equals(TransactionOptions_ReadOnly, a, b);
  }
}

