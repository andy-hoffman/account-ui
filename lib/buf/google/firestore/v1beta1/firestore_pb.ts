// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.3.0 with parameter "target=ts"
// @generated from file google/firestore/v1beta1/firestore.proto (package google.firestore.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { DocumentMask, Precondition, TransactionOptions } from "./common_pb.js";
import { Document } from "./document_pb.js";
import { DocumentChange, DocumentDelete, DocumentRemove, ExistenceFilter, Write, WriteResult } from "./write_pb.js";
import { StructuredQuery } from "./query_pb.js";
import { Status } from "../../rpc/status_pb.js";

/**
 * The request for [Firestore.GetDocument][google.firestore.v1beta1.Firestore.GetDocument].
 *
 * @generated from message google.firestore.v1beta1.GetDocumentRequest
 */
export class GetDocumentRequest extends Message<GetDocumentRequest> {
  /**
   * The resource name of the Document to get. In the format:
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The fields to return. If not set, returns all fields.
   *
   * If the document has a field that is not present in this mask, that field
   * will not be returned in the response.
   *
   * @generated from field: google.firestore.v1beta1.DocumentMask mask = 2;
   */
  mask?: DocumentMask;

  /**
   * The consistency mode for this transaction.
   * If not set, defaults to strong consistency.
   *
   * @generated from oneof google.firestore.v1beta1.GetDocumentRequest.consistency_selector
   */
  consistencySelector: {
    /**
     * Reads the document in a transaction.
     *
     * @generated from field: bytes transaction = 3;
     */
    value: Uint8Array;
    case: "transaction";
  } | {
    /**
     * Reads the version of the document at the given time.
     * This may not be older than 60 seconds.
     *
     * @generated from field: google.protobuf.Timestamp read_time = 5;
     */
    value: Timestamp;
    case: "readTime";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<GetDocumentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.GetDocumentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "mask", kind: "message", T: DocumentMask },
    { no: 3, name: "transaction", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "consistency_selector" },
    { no: 5, name: "read_time", kind: "message", T: Timestamp, oneof: "consistency_selector" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetDocumentRequest {
    return new GetDocumentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetDocumentRequest {
    return new GetDocumentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetDocumentRequest {
    return new GetDocumentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetDocumentRequest | PlainMessage<GetDocumentRequest> | undefined, b: GetDocumentRequest | PlainMessage<GetDocumentRequest> | undefined): boolean {
    return proto3.util.equals(GetDocumentRequest, a, b);
  }
}

/**
 * The request for [Firestore.ListDocuments][google.firestore.v1beta1.Firestore.ListDocuments].
 *
 * @generated from message google.firestore.v1beta1.ListDocumentsRequest
 */
export class ListDocumentsRequest extends Message<ListDocumentsRequest> {
  /**
   * The parent resource name. In the format:
   * `projects/{project_id}/databases/{database_id}/documents` or
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   * For example:
   * `projects/my-project/databases/my-database/documents` or
   * `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
   *
   * @generated from field: string parent = 1;
   */
  parent = "";

  /**
   * The collection ID, relative to `parent`, to list. For example: `chatrooms`
   * or `messages`.
   *
   * @generated from field: string collection_id = 2;
   */
  collectionId = "";

  /**
   * The maximum number of documents to return.
   *
   * @generated from field: int32 page_size = 3;
   */
  pageSize = 0;

  /**
   * The `next_page_token` value returned from a previous List request, if any.
   *
   * @generated from field: string page_token = 4;
   */
  pageToken = "";

  /**
   * The order to sort results by. For example: `priority desc, name`.
   *
   * @generated from field: string order_by = 6;
   */
  orderBy = "";

  /**
   * The fields to return. If not set, returns all fields.
   *
   * If a document has a field that is not present in this mask, that field
   * will not be returned in the response.
   *
   * @generated from field: google.firestore.v1beta1.DocumentMask mask = 7;
   */
  mask?: DocumentMask;

  /**
   * The consistency mode for this transaction.
   * If not set, defaults to strong consistency.
   *
   * @generated from oneof google.firestore.v1beta1.ListDocumentsRequest.consistency_selector
   */
  consistencySelector: {
    /**
     * Reads documents in a transaction.
     *
     * @generated from field: bytes transaction = 8;
     */
    value: Uint8Array;
    case: "transaction";
  } | {
    /**
     * Reads documents as they were at the given time.
     * This may not be older than 60 seconds.
     *
     * @generated from field: google.protobuf.Timestamp read_time = 10;
     */
    value: Timestamp;
    case: "readTime";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * If the list should show missing documents. A missing document is a
   * document that does not exist but has sub-documents. These documents will
   * be returned with a key but will not have fields, [Document.create_time][google.firestore.v1beta1.Document.create_time],
   * or [Document.update_time][google.firestore.v1beta1.Document.update_time] set.
   *
   * Requests with `show_missing` may not specify `where` or
   * `order_by`.
   *
   * @generated from field: bool show_missing = 12;
   */
  showMissing = false;

  constructor(data?: PartialMessage<ListDocumentsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.ListDocumentsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "order_by", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "mask", kind: "message", T: DocumentMask },
    { no: 8, name: "transaction", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "consistency_selector" },
    { no: 10, name: "read_time", kind: "message", T: Timestamp, oneof: "consistency_selector" },
    { no: 12, name: "show_missing", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListDocumentsRequest {
    return new ListDocumentsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListDocumentsRequest {
    return new ListDocumentsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListDocumentsRequest {
    return new ListDocumentsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListDocumentsRequest | PlainMessage<ListDocumentsRequest> | undefined, b: ListDocumentsRequest | PlainMessage<ListDocumentsRequest> | undefined): boolean {
    return proto3.util.equals(ListDocumentsRequest, a, b);
  }
}

/**
 * The response for [Firestore.ListDocuments][google.firestore.v1beta1.Firestore.ListDocuments].
 *
 * @generated from message google.firestore.v1beta1.ListDocumentsResponse
 */
export class ListDocumentsResponse extends Message<ListDocumentsResponse> {
  /**
   * The Documents found.
   *
   * @generated from field: repeated google.firestore.v1beta1.Document documents = 1;
   */
  documents: Document[] = [];

  /**
   * The next page token.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListDocumentsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.ListDocumentsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "documents", kind: "message", T: Document, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListDocumentsResponse {
    return new ListDocumentsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListDocumentsResponse {
    return new ListDocumentsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListDocumentsResponse {
    return new ListDocumentsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListDocumentsResponse | PlainMessage<ListDocumentsResponse> | undefined, b: ListDocumentsResponse | PlainMessage<ListDocumentsResponse> | undefined): boolean {
    return proto3.util.equals(ListDocumentsResponse, a, b);
  }
}

/**
 * The request for [Firestore.CreateDocument][google.firestore.v1beta1.Firestore.CreateDocument].
 *
 * @generated from message google.firestore.v1beta1.CreateDocumentRequest
 */
export class CreateDocumentRequest extends Message<CreateDocumentRequest> {
  /**
   * The parent resource. For example:
   * `projects/{project_id}/databases/{database_id}/documents` or
   * `projects/{project_id}/databases/{database_id}/documents/chatrooms/{chatroom_id}`
   *
   * @generated from field: string parent = 1;
   */
  parent = "";

  /**
   * The collection ID, relative to `parent`, to list. For example: `chatrooms`.
   *
   * @generated from field: string collection_id = 2;
   */
  collectionId = "";

  /**
   * The client-assigned document ID to use for this document.
   *
   * Optional. If not specified, an ID will be assigned by the service.
   *
   * @generated from field: string document_id = 3;
   */
  documentId = "";

  /**
   * The document to create. `name` must not be set.
   *
   * @generated from field: google.firestore.v1beta1.Document document = 4;
   */
  document?: Document;

  /**
   * The fields to return. If not set, returns all fields.
   *
   * If the document has a field that is not present in this mask, that field
   * will not be returned in the response.
   *
   * @generated from field: google.firestore.v1beta1.DocumentMask mask = 5;
   */
  mask?: DocumentMask;

  constructor(data?: PartialMessage<CreateDocumentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.CreateDocumentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "collection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "document_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "document", kind: "message", T: Document },
    { no: 5, name: "mask", kind: "message", T: DocumentMask },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateDocumentRequest {
    return new CreateDocumentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateDocumentRequest {
    return new CreateDocumentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateDocumentRequest {
    return new CreateDocumentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateDocumentRequest | PlainMessage<CreateDocumentRequest> | undefined, b: CreateDocumentRequest | PlainMessage<CreateDocumentRequest> | undefined): boolean {
    return proto3.util.equals(CreateDocumentRequest, a, b);
  }
}

/**
 * The request for [Firestore.UpdateDocument][google.firestore.v1beta1.Firestore.UpdateDocument].
 *
 * @generated from message google.firestore.v1beta1.UpdateDocumentRequest
 */
export class UpdateDocumentRequest extends Message<UpdateDocumentRequest> {
  /**
   * The updated document.
   * Creates the document if it does not already exist.
   *
   * @generated from field: google.firestore.v1beta1.Document document = 1;
   */
  document?: Document;

  /**
   * The fields to update.
   * None of the field paths in the mask may contain a reserved name.
   *
   * If the document exists on the server and has fields not referenced in the
   * mask, they are left unchanged.
   * Fields referenced in the mask, but not present in the input document, are
   * deleted from the document on the server.
   *
   * @generated from field: google.firestore.v1beta1.DocumentMask update_mask = 2;
   */
  updateMask?: DocumentMask;

  /**
   * The fields to return. If not set, returns all fields.
   *
   * If the document has a field that is not present in this mask, that field
   * will not be returned in the response.
   *
   * @generated from field: google.firestore.v1beta1.DocumentMask mask = 3;
   */
  mask?: DocumentMask;

  /**
   * An optional precondition on the document.
   * The request will fail if this is set and not met by the target document.
   *
   * @generated from field: google.firestore.v1beta1.Precondition current_document = 4;
   */
  currentDocument?: Precondition;

  constructor(data?: PartialMessage<UpdateDocumentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.UpdateDocumentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "document", kind: "message", T: Document },
    { no: 2, name: "update_mask", kind: "message", T: DocumentMask },
    { no: 3, name: "mask", kind: "message", T: DocumentMask },
    { no: 4, name: "current_document", kind: "message", T: Precondition },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UpdateDocumentRequest {
    return new UpdateDocumentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UpdateDocumentRequest {
    return new UpdateDocumentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UpdateDocumentRequest {
    return new UpdateDocumentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UpdateDocumentRequest | PlainMessage<UpdateDocumentRequest> | undefined, b: UpdateDocumentRequest | PlainMessage<UpdateDocumentRequest> | undefined): boolean {
    return proto3.util.equals(UpdateDocumentRequest, a, b);
  }
}

/**
 * The request for [Firestore.DeleteDocument][google.firestore.v1beta1.Firestore.DeleteDocument].
 *
 * @generated from message google.firestore.v1beta1.DeleteDocumentRequest
 */
export class DeleteDocumentRequest extends Message<DeleteDocumentRequest> {
  /**
   * The resource name of the Document to delete. In the format:
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * An optional precondition on the document.
   * The request will fail if this is set and not met by the target document.
   *
   * @generated from field: google.firestore.v1beta1.Precondition current_document = 2;
   */
  currentDocument?: Precondition;

  constructor(data?: PartialMessage<DeleteDocumentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.DeleteDocumentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "current_document", kind: "message", T: Precondition },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteDocumentRequest {
    return new DeleteDocumentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteDocumentRequest {
    return new DeleteDocumentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteDocumentRequest {
    return new DeleteDocumentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteDocumentRequest | PlainMessage<DeleteDocumentRequest> | undefined, b: DeleteDocumentRequest | PlainMessage<DeleteDocumentRequest> | undefined): boolean {
    return proto3.util.equals(DeleteDocumentRequest, a, b);
  }
}

/**
 * The request for [Firestore.BatchGetDocuments][google.firestore.v1beta1.Firestore.BatchGetDocuments].
 *
 * @generated from message google.firestore.v1beta1.BatchGetDocumentsRequest
 */
export class BatchGetDocumentsRequest extends Message<BatchGetDocumentsRequest> {
  /**
   * The database name. In the format:
   * `projects/{project_id}/databases/{database_id}`.
   *
   * @generated from field: string database = 1;
   */
  database = "";

  /**
   * The names of the documents to retrieve. In the format:
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   * The request will fail if any of the document is not a child resource of the
   * given `database`. Duplicate names will be elided.
   *
   * @generated from field: repeated string documents = 2;
   */
  documents: string[] = [];

  /**
   * The fields to return. If not set, returns all fields.
   *
   * If a document has a field that is not present in this mask, that field will
   * not be returned in the response.
   *
   * @generated from field: google.firestore.v1beta1.DocumentMask mask = 3;
   */
  mask?: DocumentMask;

  /**
   * The consistency mode for this transaction.
   * If not set, defaults to strong consistency.
   *
   * @generated from oneof google.firestore.v1beta1.BatchGetDocumentsRequest.consistency_selector
   */
  consistencySelector: {
    /**
     * Reads documents in a transaction.
     *
     * @generated from field: bytes transaction = 4;
     */
    value: Uint8Array;
    case: "transaction";
  } | {
    /**
     * Starts a new transaction and reads the documents.
     * Defaults to a read-only transaction.
     * The new transaction ID will be returned as the first response in the
     * stream.
     *
     * @generated from field: google.firestore.v1beta1.TransactionOptions new_transaction = 5;
     */
    value: TransactionOptions;
    case: "newTransaction";
  } | {
    /**
     * Reads documents as they were at the given time.
     * This may not be older than 60 seconds.
     *
     * @generated from field: google.protobuf.Timestamp read_time = 7;
     */
    value: Timestamp;
    case: "readTime";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<BatchGetDocumentsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.BatchGetDocumentsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "database", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "documents", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "mask", kind: "message", T: DocumentMask },
    { no: 4, name: "transaction", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "consistency_selector" },
    { no: 5, name: "new_transaction", kind: "message", T: TransactionOptions, oneof: "consistency_selector" },
    { no: 7, name: "read_time", kind: "message", T: Timestamp, oneof: "consistency_selector" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchGetDocumentsRequest {
    return new BatchGetDocumentsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchGetDocumentsRequest {
    return new BatchGetDocumentsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchGetDocumentsRequest {
    return new BatchGetDocumentsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: BatchGetDocumentsRequest | PlainMessage<BatchGetDocumentsRequest> | undefined, b: BatchGetDocumentsRequest | PlainMessage<BatchGetDocumentsRequest> | undefined): boolean {
    return proto3.util.equals(BatchGetDocumentsRequest, a, b);
  }
}

/**
 * The streamed response for [Firestore.BatchGetDocuments][google.firestore.v1beta1.Firestore.BatchGetDocuments].
 *
 * @generated from message google.firestore.v1beta1.BatchGetDocumentsResponse
 */
export class BatchGetDocumentsResponse extends Message<BatchGetDocumentsResponse> {
  /**
   * A single result.
   * This can be empty if the server is just returning a transaction.
   *
   * @generated from oneof google.firestore.v1beta1.BatchGetDocumentsResponse.result
   */
  result: {
    /**
     * A document that was requested.
     *
     * @generated from field: google.firestore.v1beta1.Document found = 1;
     */
    value: Document;
    case: "found";
  } | {
    /**
     * A document name that was requested but does not exist. In the format:
     * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
     *
     * @generated from field: string missing = 2;
     */
    value: string;
    case: "missing";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The transaction that was started as part of this request.
   * Will only be set in the first response, and only if
   * [BatchGetDocumentsRequest.new_transaction][google.firestore.v1beta1.BatchGetDocumentsRequest.new_transaction] was set in the request.
   *
   * @generated from field: bytes transaction = 3;
   */
  transaction = new Uint8Array(0);

  /**
   * The time at which the document was read.
   * This may be monotically increasing, in this case the previous documents in
   * the result stream are guaranteed not to have changed between their
   * read_time and this one.
   *
   * @generated from field: google.protobuf.Timestamp read_time = 4;
   */
  readTime?: Timestamp;

  constructor(data?: PartialMessage<BatchGetDocumentsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.BatchGetDocumentsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "found", kind: "message", T: Document, oneof: "result" },
    { no: 2, name: "missing", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "result" },
    { no: 3, name: "transaction", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "read_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BatchGetDocumentsResponse {
    return new BatchGetDocumentsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BatchGetDocumentsResponse {
    return new BatchGetDocumentsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BatchGetDocumentsResponse {
    return new BatchGetDocumentsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: BatchGetDocumentsResponse | PlainMessage<BatchGetDocumentsResponse> | undefined, b: BatchGetDocumentsResponse | PlainMessage<BatchGetDocumentsResponse> | undefined): boolean {
    return proto3.util.equals(BatchGetDocumentsResponse, a, b);
  }
}

/**
 * The request for [Firestore.BeginTransaction][google.firestore.v1beta1.Firestore.BeginTransaction].
 *
 * @generated from message google.firestore.v1beta1.BeginTransactionRequest
 */
export class BeginTransactionRequest extends Message<BeginTransactionRequest> {
  /**
   * The database name. In the format:
   * `projects/{project_id}/databases/{database_id}`.
   *
   * @generated from field: string database = 1;
   */
  database = "";

  /**
   * The options for the transaction.
   * Defaults to a read-write transaction.
   *
   * @generated from field: google.firestore.v1beta1.TransactionOptions options = 2;
   */
  options?: TransactionOptions;

  constructor(data?: PartialMessage<BeginTransactionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.BeginTransactionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "database", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "options", kind: "message", T: TransactionOptions },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BeginTransactionRequest {
    return new BeginTransactionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BeginTransactionRequest {
    return new BeginTransactionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BeginTransactionRequest {
    return new BeginTransactionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: BeginTransactionRequest | PlainMessage<BeginTransactionRequest> | undefined, b: BeginTransactionRequest | PlainMessage<BeginTransactionRequest> | undefined): boolean {
    return proto3.util.equals(BeginTransactionRequest, a, b);
  }
}

/**
 * The response for [Firestore.BeginTransaction][google.firestore.v1beta1.Firestore.BeginTransaction].
 *
 * @generated from message google.firestore.v1beta1.BeginTransactionResponse
 */
export class BeginTransactionResponse extends Message<BeginTransactionResponse> {
  /**
   * The transaction that was started.
   *
   * @generated from field: bytes transaction = 1;
   */
  transaction = new Uint8Array(0);

  constructor(data?: PartialMessage<BeginTransactionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.BeginTransactionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "transaction", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BeginTransactionResponse {
    return new BeginTransactionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BeginTransactionResponse {
    return new BeginTransactionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BeginTransactionResponse {
    return new BeginTransactionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: BeginTransactionResponse | PlainMessage<BeginTransactionResponse> | undefined, b: BeginTransactionResponse | PlainMessage<BeginTransactionResponse> | undefined): boolean {
    return proto3.util.equals(BeginTransactionResponse, a, b);
  }
}

/**
 * The request for [Firestore.Commit][google.firestore.v1beta1.Firestore.Commit].
 *
 * @generated from message google.firestore.v1beta1.CommitRequest
 */
export class CommitRequest extends Message<CommitRequest> {
  /**
   * The database name. In the format:
   * `projects/{project_id}/databases/{database_id}`.
   *
   * @generated from field: string database = 1;
   */
  database = "";

  /**
   * The writes to apply.
   *
   * Always executed atomically and in order.
   *
   * @generated from field: repeated google.firestore.v1beta1.Write writes = 2;
   */
  writes: Write[] = [];

  /**
   * If set, applies all writes in this transaction, and commits it.
   *
   * @generated from field: bytes transaction = 3;
   */
  transaction = new Uint8Array(0);

  constructor(data?: PartialMessage<CommitRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.CommitRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "database", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "writes", kind: "message", T: Write, repeated: true },
    { no: 3, name: "transaction", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommitRequest {
    return new CommitRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommitRequest {
    return new CommitRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommitRequest {
    return new CommitRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CommitRequest | PlainMessage<CommitRequest> | undefined, b: CommitRequest | PlainMessage<CommitRequest> | undefined): boolean {
    return proto3.util.equals(CommitRequest, a, b);
  }
}

/**
 * The response for [Firestore.Commit][google.firestore.v1beta1.Firestore.Commit].
 *
 * @generated from message google.firestore.v1beta1.CommitResponse
 */
export class CommitResponse extends Message<CommitResponse> {
  /**
   * The result of applying the writes.
   *
   * This i-th write result corresponds to the i-th write in the
   * request.
   *
   * @generated from field: repeated google.firestore.v1beta1.WriteResult write_results = 1;
   */
  writeResults: WriteResult[] = [];

  /**
   * The time at which the commit occurred.
   *
   * @generated from field: google.protobuf.Timestamp commit_time = 2;
   */
  commitTime?: Timestamp;

  constructor(data?: PartialMessage<CommitResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.CommitResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "write_results", kind: "message", T: WriteResult, repeated: true },
    { no: 2, name: "commit_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CommitResponse {
    return new CommitResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CommitResponse {
    return new CommitResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CommitResponse {
    return new CommitResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CommitResponse | PlainMessage<CommitResponse> | undefined, b: CommitResponse | PlainMessage<CommitResponse> | undefined): boolean {
    return proto3.util.equals(CommitResponse, a, b);
  }
}

/**
 * The request for [Firestore.Rollback][google.firestore.v1beta1.Firestore.Rollback].
 *
 * @generated from message google.firestore.v1beta1.RollbackRequest
 */
export class RollbackRequest extends Message<RollbackRequest> {
  /**
   * The database name. In the format:
   * `projects/{project_id}/databases/{database_id}`.
   *
   * @generated from field: string database = 1;
   */
  database = "";

  /**
   * The transaction to roll back.
   *
   * @generated from field: bytes transaction = 2;
   */
  transaction = new Uint8Array(0);

  constructor(data?: PartialMessage<RollbackRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.RollbackRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "database", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "transaction", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RollbackRequest {
    return new RollbackRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RollbackRequest {
    return new RollbackRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RollbackRequest {
    return new RollbackRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RollbackRequest | PlainMessage<RollbackRequest> | undefined, b: RollbackRequest | PlainMessage<RollbackRequest> | undefined): boolean {
    return proto3.util.equals(RollbackRequest, a, b);
  }
}

/**
 * The request for [Firestore.RunQuery][google.firestore.v1beta1.Firestore.RunQuery].
 *
 * @generated from message google.firestore.v1beta1.RunQueryRequest
 */
export class RunQueryRequest extends Message<RunQueryRequest> {
  /**
   * The parent resource name. In the format:
   * `projects/{project_id}/databases/{database_id}/documents` or
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   * For example:
   * `projects/my-project/databases/my-database/documents` or
   * `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
   *
   * @generated from field: string parent = 1;
   */
  parent = "";

  /**
   * The query to run.
   *
   * @generated from oneof google.firestore.v1beta1.RunQueryRequest.query_type
   */
  queryType: {
    /**
     * A structured query.
     *
     * @generated from field: google.firestore.v1beta1.StructuredQuery structured_query = 2;
     */
    value: StructuredQuery;
    case: "structuredQuery";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * The consistency mode for this transaction.
   * If not set, defaults to strong consistency.
   *
   * @generated from oneof google.firestore.v1beta1.RunQueryRequest.consistency_selector
   */
  consistencySelector: {
    /**
     * Reads documents in a transaction.
     *
     * @generated from field: bytes transaction = 5;
     */
    value: Uint8Array;
    case: "transaction";
  } | {
    /**
     * Starts a new transaction and reads the documents.
     * Defaults to a read-only transaction.
     * The new transaction ID will be returned as the first response in the
     * stream.
     *
     * @generated from field: google.firestore.v1beta1.TransactionOptions new_transaction = 6;
     */
    value: TransactionOptions;
    case: "newTransaction";
  } | {
    /**
     * Reads documents as they were at the given time.
     * This may not be older than 60 seconds.
     *
     * @generated from field: google.protobuf.Timestamp read_time = 7;
     */
    value: Timestamp;
    case: "readTime";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<RunQueryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.RunQueryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "structured_query", kind: "message", T: StructuredQuery, oneof: "query_type" },
    { no: 5, name: "transaction", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "consistency_selector" },
    { no: 6, name: "new_transaction", kind: "message", T: TransactionOptions, oneof: "consistency_selector" },
    { no: 7, name: "read_time", kind: "message", T: Timestamp, oneof: "consistency_selector" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RunQueryRequest {
    return new RunQueryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RunQueryRequest {
    return new RunQueryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RunQueryRequest {
    return new RunQueryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RunQueryRequest | PlainMessage<RunQueryRequest> | undefined, b: RunQueryRequest | PlainMessage<RunQueryRequest> | undefined): boolean {
    return proto3.util.equals(RunQueryRequest, a, b);
  }
}

/**
 * The response for [Firestore.RunQuery][google.firestore.v1beta1.Firestore.RunQuery].
 *
 * @generated from message google.firestore.v1beta1.RunQueryResponse
 */
export class RunQueryResponse extends Message<RunQueryResponse> {
  /**
   * The transaction that was started as part of this request.
   * Can only be set in the first response, and only if
   * [RunQueryRequest.new_transaction][google.firestore.v1beta1.RunQueryRequest.new_transaction] was set in the request.
   * If set, no other fields will be set in this response.
   *
   * @generated from field: bytes transaction = 2;
   */
  transaction = new Uint8Array(0);

  /**
   * A query result.
   * Not set when reporting partial progress.
   *
   * @generated from field: google.firestore.v1beta1.Document document = 1;
   */
  document?: Document;

  /**
   * The time at which the document was read. This may be monotonically
   * increasing; in this case, the previous documents in the result stream are
   * guaranteed not to have changed between their `read_time` and this one.
   *
   * If the query returns no results, a response with `read_time` and no
   * `document` will be sent, and this represents the time at which the query
   * was run.
   *
   * @generated from field: google.protobuf.Timestamp read_time = 3;
   */
  readTime?: Timestamp;

  /**
   * The number of results that have been skipped due to an offset between
   * the last response and the current response.
   *
   * @generated from field: int32 skipped_results = 4;
   */
  skippedResults = 0;

  constructor(data?: PartialMessage<RunQueryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.RunQueryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "transaction", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 1, name: "document", kind: "message", T: Document },
    { no: 3, name: "read_time", kind: "message", T: Timestamp },
    { no: 4, name: "skipped_results", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RunQueryResponse {
    return new RunQueryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RunQueryResponse {
    return new RunQueryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RunQueryResponse {
    return new RunQueryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RunQueryResponse | PlainMessage<RunQueryResponse> | undefined, b: RunQueryResponse | PlainMessage<RunQueryResponse> | undefined): boolean {
    return proto3.util.equals(RunQueryResponse, a, b);
  }
}

/**
 * The request for [Firestore.Write][google.firestore.v1beta1.Firestore.Write].
 *
 * The first request creates a stream, or resumes an existing one from a token.
 *
 * When creating a new stream, the server replies with a response containing
 * only an ID and a token, to use in the next request.
 *
 * When resuming a stream, the server first streams any responses later than the
 * given token, then a response containing only an up-to-date token, to use in
 * the next request.
 *
 * @generated from message google.firestore.v1beta1.WriteRequest
 */
export class WriteRequest extends Message<WriteRequest> {
  /**
   * The database name. In the format:
   * `projects/{project_id}/databases/{database_id}`.
   * This is only required in the first message.
   *
   * @generated from field: string database = 1;
   */
  database = "";

  /**
   * The ID of the write stream to resume.
   * This may only be set in the first message. When left empty, a new write
   * stream will be created.
   *
   * @generated from field: string stream_id = 2;
   */
  streamId = "";

  /**
   * The writes to apply.
   *
   * Always executed atomically and in order.
   * This must be empty on the first request.
   * This may be empty on the last request.
   * This must not be empty on all other requests.
   *
   * @generated from field: repeated google.firestore.v1beta1.Write writes = 3;
   */
  writes: Write[] = [];

  /**
   * A stream token that was previously sent by the server.
   *
   * The client should set this field to the token from the most recent
   * [WriteResponse][google.firestore.v1beta1.WriteResponse] it has received. This acknowledges that the client has
   * received responses up to this token. After sending this token, earlier
   * tokens may not be used anymore.
   *
   * The server may close the stream if there are too many unacknowledged
   * responses.
   *
   * Leave this field unset when creating a new stream. To resume a stream at
   * a specific point, set this field and the `stream_id` field.
   *
   * Leave this field unset when creating a new stream.
   *
   * @generated from field: bytes stream_token = 4;
   */
  streamToken = new Uint8Array(0);

  /**
   * Labels associated with this write request.
   *
   * @generated from field: map<string, string> labels = 5;
   */
  labels: { [key: string]: string } = {};

  constructor(data?: PartialMessage<WriteRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.WriteRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "database", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "stream_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "writes", kind: "message", T: Write, repeated: true },
    { no: 4, name: "stream_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 5, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WriteRequest {
    return new WriteRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WriteRequest {
    return new WriteRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WriteRequest {
    return new WriteRequest().fromJsonString(jsonString, options);
  }

  static equals(a: WriteRequest | PlainMessage<WriteRequest> | undefined, b: WriteRequest | PlainMessage<WriteRequest> | undefined): boolean {
    return proto3.util.equals(WriteRequest, a, b);
  }
}

/**
 * The response for [Firestore.Write][google.firestore.v1beta1.Firestore.Write].
 *
 * @generated from message google.firestore.v1beta1.WriteResponse
 */
export class WriteResponse extends Message<WriteResponse> {
  /**
   * The ID of the stream.
   * Only set on the first message, when a new stream was created.
   *
   * @generated from field: string stream_id = 1;
   */
  streamId = "";

  /**
   * A token that represents the position of this response in the stream.
   * This can be used by a client to resume the stream at this point.
   *
   * This field is always set.
   *
   * @generated from field: bytes stream_token = 2;
   */
  streamToken = new Uint8Array(0);

  /**
   * The result of applying the writes.
   *
   * This i-th write result corresponds to the i-th write in the
   * request.
   *
   * @generated from field: repeated google.firestore.v1beta1.WriteResult write_results = 3;
   */
  writeResults: WriteResult[] = [];

  /**
   * The time at which the commit occurred.
   *
   * @generated from field: google.protobuf.Timestamp commit_time = 4;
   */
  commitTime?: Timestamp;

  constructor(data?: PartialMessage<WriteResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.WriteResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stream_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "stream_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "write_results", kind: "message", T: WriteResult, repeated: true },
    { no: 4, name: "commit_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WriteResponse {
    return new WriteResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WriteResponse {
    return new WriteResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WriteResponse {
    return new WriteResponse().fromJsonString(jsonString, options);
  }

  static equals(a: WriteResponse | PlainMessage<WriteResponse> | undefined, b: WriteResponse | PlainMessage<WriteResponse> | undefined): boolean {
    return proto3.util.equals(WriteResponse, a, b);
  }
}

/**
 * A request for [Firestore.Listen][google.firestore.v1beta1.Firestore.Listen]
 *
 * @generated from message google.firestore.v1beta1.ListenRequest
 */
export class ListenRequest extends Message<ListenRequest> {
  /**
   * The database name. In the format:
   * `projects/{project_id}/databases/{database_id}`.
   *
   * @generated from field: string database = 1;
   */
  database = "";

  /**
   * The supported target changes.
   *
   * @generated from oneof google.firestore.v1beta1.ListenRequest.target_change
   */
  targetChange: {
    /**
     * A target to add to this stream.
     *
     * @generated from field: google.firestore.v1beta1.Target add_target = 2;
     */
    value: Target;
    case: "addTarget";
  } | {
    /**
     * The ID of a target to remove from this stream.
     *
     * @generated from field: int32 remove_target = 3;
     */
    value: number;
    case: "removeTarget";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Labels associated with this target change.
   *
   * @generated from field: map<string, string> labels = 4;
   */
  labels: { [key: string]: string } = {};

  constructor(data?: PartialMessage<ListenRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.ListenRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "database", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "add_target", kind: "message", T: Target, oneof: "target_change" },
    { no: 3, name: "remove_target", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "target_change" },
    { no: 4, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListenRequest {
    return new ListenRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListenRequest {
    return new ListenRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListenRequest {
    return new ListenRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListenRequest | PlainMessage<ListenRequest> | undefined, b: ListenRequest | PlainMessage<ListenRequest> | undefined): boolean {
    return proto3.util.equals(ListenRequest, a, b);
  }
}

/**
 * The response for [Firestore.Listen][google.firestore.v1beta1.Firestore.Listen].
 *
 * @generated from message google.firestore.v1beta1.ListenResponse
 */
export class ListenResponse extends Message<ListenResponse> {
  /**
   * The supported responses.
   *
   * @generated from oneof google.firestore.v1beta1.ListenResponse.response_type
   */
  responseType: {
    /**
     * Targets have changed.
     *
     * @generated from field: google.firestore.v1beta1.TargetChange target_change = 2;
     */
    value: TargetChange;
    case: "targetChange";
  } | {
    /**
     * A [Document][google.firestore.v1beta1.Document] has changed.
     *
     * @generated from field: google.firestore.v1beta1.DocumentChange document_change = 3;
     */
    value: DocumentChange;
    case: "documentChange";
  } | {
    /**
     * A [Document][google.firestore.v1beta1.Document] has been deleted.
     *
     * @generated from field: google.firestore.v1beta1.DocumentDelete document_delete = 4;
     */
    value: DocumentDelete;
    case: "documentDelete";
  } | {
    /**
     * A [Document][google.firestore.v1beta1.Document] has been removed from a target (because it is no longer
     * relevant to that target).
     *
     * @generated from field: google.firestore.v1beta1.DocumentRemove document_remove = 6;
     */
    value: DocumentRemove;
    case: "documentRemove";
  } | {
    /**
     * A filter to apply to the set of documents previously returned for the
     * given target.
     *
     * Returned when documents may have been removed from the given target, but
     * the exact documents are unknown.
     *
     * @generated from field: google.firestore.v1beta1.ExistenceFilter filter = 5;
     */
    value: ExistenceFilter;
    case: "filter";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ListenResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.ListenResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "target_change", kind: "message", T: TargetChange, oneof: "response_type" },
    { no: 3, name: "document_change", kind: "message", T: DocumentChange, oneof: "response_type" },
    { no: 4, name: "document_delete", kind: "message", T: DocumentDelete, oneof: "response_type" },
    { no: 6, name: "document_remove", kind: "message", T: DocumentRemove, oneof: "response_type" },
    { no: 5, name: "filter", kind: "message", T: ExistenceFilter, oneof: "response_type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListenResponse {
    return new ListenResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListenResponse {
    return new ListenResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListenResponse {
    return new ListenResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListenResponse | PlainMessage<ListenResponse> | undefined, b: ListenResponse | PlainMessage<ListenResponse> | undefined): boolean {
    return proto3.util.equals(ListenResponse, a, b);
  }
}

/**
 * A specification of a set of documents to listen to.
 *
 * @generated from message google.firestore.v1beta1.Target
 */
export class Target extends Message<Target> {
  /**
   * The type of target to listen to.
   *
   * @generated from oneof google.firestore.v1beta1.Target.target_type
   */
  targetType: {
    /**
     * A target specified by a query.
     *
     * @generated from field: google.firestore.v1beta1.Target.QueryTarget query = 2;
     */
    value: Target_QueryTarget;
    case: "query";
  } | {
    /**
     * A target specified by a set of document names.
     *
     * @generated from field: google.firestore.v1beta1.Target.DocumentsTarget documents = 3;
     */
    value: Target_DocumentsTarget;
    case: "documents";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * When to start listening.
   *
   * If not specified, all matching Documents are returned before any
   * subsequent changes.
   *
   * @generated from oneof google.firestore.v1beta1.Target.resume_type
   */
  resumeType: {
    /**
     * A resume token from a prior [TargetChange][google.firestore.v1beta1.TargetChange] for an identical target.
     *
     * Using a resume token with a different target is unsupported and may fail.
     *
     * @generated from field: bytes resume_token = 4;
     */
    value: Uint8Array;
    case: "resumeToken";
  } | {
    /**
     * Start listening after a specific `read_time`.
     *
     * The client must know the state of matching documents at this time.
     *
     * @generated from field: google.protobuf.Timestamp read_time = 11;
     */
    value: Timestamp;
    case: "readTime";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * A client provided target ID.
   *
   * If not set, the server will assign an ID for the target.
   *
   * Used for resuming a target without changing IDs. The IDs can either be
   * client-assigned or be server-assigned in a previous stream. All targets
   * with client provided IDs must be added before adding a target that needs
   * a server-assigned id.
   *
   * @generated from field: int32 target_id = 5;
   */
  targetId = 0;

  /**
   * If the target should be removed once it is current and consistent.
   *
   * @generated from field: bool once = 6;
   */
  once = false;

  constructor(data?: PartialMessage<Target>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.Target";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "query", kind: "message", T: Target_QueryTarget, oneof: "target_type" },
    { no: 3, name: "documents", kind: "message", T: Target_DocumentsTarget, oneof: "target_type" },
    { no: 4, name: "resume_token", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "resume_type" },
    { no: 11, name: "read_time", kind: "message", T: Timestamp, oneof: "resume_type" },
    { no: 5, name: "target_id", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "once", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Target {
    return new Target().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Target {
    return new Target().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Target {
    return new Target().fromJsonString(jsonString, options);
  }

  static equals(a: Target | PlainMessage<Target> | undefined, b: Target | PlainMessage<Target> | undefined): boolean {
    return proto3.util.equals(Target, a, b);
  }
}

/**
 * A target specified by a set of documents names.
 *
 * @generated from message google.firestore.v1beta1.Target.DocumentsTarget
 */
export class Target_DocumentsTarget extends Message<Target_DocumentsTarget> {
  /**
   * The names of the documents to retrieve. In the format:
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   * The request will fail if any of the document is not a child resource of
   * the given `database`. Duplicate names will be elided.
   *
   * @generated from field: repeated string documents = 2;
   */
  documents: string[] = [];

  constructor(data?: PartialMessage<Target_DocumentsTarget>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.Target.DocumentsTarget";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "documents", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Target_DocumentsTarget {
    return new Target_DocumentsTarget().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Target_DocumentsTarget {
    return new Target_DocumentsTarget().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Target_DocumentsTarget {
    return new Target_DocumentsTarget().fromJsonString(jsonString, options);
  }

  static equals(a: Target_DocumentsTarget | PlainMessage<Target_DocumentsTarget> | undefined, b: Target_DocumentsTarget | PlainMessage<Target_DocumentsTarget> | undefined): boolean {
    return proto3.util.equals(Target_DocumentsTarget, a, b);
  }
}

/**
 * A target specified by a query.
 *
 * @generated from message google.firestore.v1beta1.Target.QueryTarget
 */
export class Target_QueryTarget extends Message<Target_QueryTarget> {
  /**
   * The parent resource name. In the format:
   * `projects/{project_id}/databases/{database_id}/documents` or
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   * For example:
   * `projects/my-project/databases/my-database/documents` or
   * `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
   *
   * @generated from field: string parent = 1;
   */
  parent = "";

  /**
   * The query to run.
   *
   * @generated from oneof google.firestore.v1beta1.Target.QueryTarget.query_type
   */
  queryType: {
    /**
     * A structured query.
     *
     * @generated from field: google.firestore.v1beta1.StructuredQuery structured_query = 2;
     */
    value: StructuredQuery;
    case: "structuredQuery";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Target_QueryTarget>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.Target.QueryTarget";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "structured_query", kind: "message", T: StructuredQuery, oneof: "query_type" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Target_QueryTarget {
    return new Target_QueryTarget().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Target_QueryTarget {
    return new Target_QueryTarget().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Target_QueryTarget {
    return new Target_QueryTarget().fromJsonString(jsonString, options);
  }

  static equals(a: Target_QueryTarget | PlainMessage<Target_QueryTarget> | undefined, b: Target_QueryTarget | PlainMessage<Target_QueryTarget> | undefined): boolean {
    return proto3.util.equals(Target_QueryTarget, a, b);
  }
}

/**
 * Targets being watched have changed.
 *
 * @generated from message google.firestore.v1beta1.TargetChange
 */
export class TargetChange extends Message<TargetChange> {
  /**
   * The type of change that occurred.
   *
   * @generated from field: google.firestore.v1beta1.TargetChange.TargetChangeType target_change_type = 1;
   */
  targetChangeType = TargetChange_TargetChangeType.NO_CHANGE;

  /**
   * The target IDs of targets that have changed.
   *
   * If empty, the change applies to all targets.
   *
   * For `target_change_type=ADD`, the order of the target IDs matches the order
   * of the requests to add the targets. This allows clients to unambiguously
   * associate server-assigned target IDs with added targets.
   *
   * For other states, the order of the target IDs is not defined.
   *
   * @generated from field: repeated int32 target_ids = 2;
   */
  targetIds: number[] = [];

  /**
   * The error that resulted in this change, if applicable.
   *
   * @generated from field: google.rpc.Status cause = 3;
   */
  cause?: Status;

  /**
   * A token that can be used to resume the stream for the given `target_ids`,
   * or all targets if `target_ids` is empty.
   *
   * Not set on every target change.
   *
   * @generated from field: bytes resume_token = 4;
   */
  resumeToken = new Uint8Array(0);

  /**
   * The consistent `read_time` for the given `target_ids` (omitted when the
   * target_ids are not at a consistent snapshot).
   *
   * The stream is guaranteed to send a `read_time` with `target_ids` empty
   * whenever the entire stream reaches a new consistent snapshot. ADD,
   * CURRENT, and RESET messages are guaranteed to (eventually) result in a
   * new consistent snapshot (while NO_CHANGE and REMOVE messages are not).
   *
   * For a given stream, `read_time` is guaranteed to be monotonically
   * increasing.
   *
   * @generated from field: google.protobuf.Timestamp read_time = 6;
   */
  readTime?: Timestamp;

  constructor(data?: PartialMessage<TargetChange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.TargetChange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "target_change_type", kind: "enum", T: proto3.getEnumType(TargetChange_TargetChangeType) },
    { no: 2, name: "target_ids", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
    { no: 3, name: "cause", kind: "message", T: Status },
    { no: 4, name: "resume_token", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 6, name: "read_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TargetChange {
    return new TargetChange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TargetChange {
    return new TargetChange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TargetChange {
    return new TargetChange().fromJsonString(jsonString, options);
  }

  static equals(a: TargetChange | PlainMessage<TargetChange> | undefined, b: TargetChange | PlainMessage<TargetChange> | undefined): boolean {
    return proto3.util.equals(TargetChange, a, b);
  }
}

/**
 * The type of change.
 *
 * @generated from enum google.firestore.v1beta1.TargetChange.TargetChangeType
 */
export enum TargetChange_TargetChangeType {
  /**
   * No change has occurred. Used only to send an updated `resume_token`.
   *
   * @generated from enum value: NO_CHANGE = 0;
   */
  NO_CHANGE = 0,

  /**
   * The targets have been added.
   *
   * @generated from enum value: ADD = 1;
   */
  ADD = 1,

  /**
   * The targets have been removed.
   *
   * @generated from enum value: REMOVE = 2;
   */
  REMOVE = 2,

  /**
   * The targets reflect all changes committed before the targets were added
   * to the stream.
   *
   * This will be sent after or with a `read_time` that is greater than or
   * equal to the time at which the targets were added.
   *
   * Listeners can wait for this change if read-after-write semantics
   * are desired.
   *
   * @generated from enum value: CURRENT = 3;
   */
  CURRENT = 3,

  /**
   * The targets have been reset, and a new initial state for the targets
   * will be returned in subsequent changes.
   *
   * After the initial state is complete, `CURRENT` will be returned even
   * if the target was previously indicated to be `CURRENT`.
   *
   * @generated from enum value: RESET = 4;
   */
  RESET = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(TargetChange_TargetChangeType)
proto3.util.setEnumType(TargetChange_TargetChangeType, "google.firestore.v1beta1.TargetChange.TargetChangeType", [
  { no: 0, name: "NO_CHANGE" },
  { no: 1, name: "ADD" },
  { no: 2, name: "REMOVE" },
  { no: 3, name: "CURRENT" },
  { no: 4, name: "RESET" },
]);

/**
 * The request for [Firestore.ListCollectionIds][google.firestore.v1beta1.Firestore.ListCollectionIds].
 *
 * @generated from message google.firestore.v1beta1.ListCollectionIdsRequest
 */
export class ListCollectionIdsRequest extends Message<ListCollectionIdsRequest> {
  /**
   * The parent document. In the format:
   * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
   * For example:
   * `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`
   *
   * @generated from field: string parent = 1;
   */
  parent = "";

  /**
   * The maximum number of results to return.
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * A page token. Must be a value from
   * [ListCollectionIdsResponse][google.firestore.v1beta1.ListCollectionIdsResponse].
   *
   * @generated from field: string page_token = 3;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListCollectionIdsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.ListCollectionIdsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListCollectionIdsRequest {
    return new ListCollectionIdsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListCollectionIdsRequest {
    return new ListCollectionIdsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListCollectionIdsRequest {
    return new ListCollectionIdsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ListCollectionIdsRequest | PlainMessage<ListCollectionIdsRequest> | undefined, b: ListCollectionIdsRequest | PlainMessage<ListCollectionIdsRequest> | undefined): boolean {
    return proto3.util.equals(ListCollectionIdsRequest, a, b);
  }
}

/**
 * The response from [Firestore.ListCollectionIds][google.firestore.v1beta1.Firestore.ListCollectionIds].
 *
 * @generated from message google.firestore.v1beta1.ListCollectionIdsResponse
 */
export class ListCollectionIdsResponse extends Message<ListCollectionIdsResponse> {
  /**
   * The collection ids.
   *
   * @generated from field: repeated string collection_ids = 1;
   */
  collectionIds: string[] = [];

  /**
   * A page token that may be used to continue the list.
   *
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  constructor(data?: PartialMessage<ListCollectionIdsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "google.firestore.v1beta1.ListCollectionIdsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "collection_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListCollectionIdsResponse {
    return new ListCollectionIdsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListCollectionIdsResponse {
    return new ListCollectionIdsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListCollectionIdsResponse {
    return new ListCollectionIdsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ListCollectionIdsResponse | PlainMessage<ListCollectionIdsResponse> | undefined, b: ListCollectionIdsResponse | PlainMessage<ListCollectionIdsResponse> | undefined): boolean {
    return proto3.util.equals(ListCollectionIdsResponse, a, b);
  }
}

